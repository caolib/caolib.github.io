<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>npm、yarn 包管理器</title>
      <link href="/2024/03/27/npm-yarn/"/>
      <url>/2024/03/27/npm-yarn/</url>
      
        <content type="html"><![CDATA[<h2 id="npm">npm</h2><h3 id="简介">简介</h3><p>npm 由三个独立的部分组成：</p><ul><li>网站</li><li>注册表（registry）</li><li>命令行工具 (CLI)</li></ul><p><a href="https://npmjs.com/"><em>网站</em></a> 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。</p><p><em>注册表</em> 是一个巨大的数据库，保存了每个包（package）的信息。</p><p><a href="https://docs.npmjs.com/cli/npm"><em>CLI</em></a> 通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。</p><hr><h3 id="下载nodejs">下载nodejs</h3><p><a href="https://nodejs.org/en/download/">Node.js下载</a></p><p>下载后查看版本</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">node -v<br></code></pre></td></tr></table></figure><hr><h3 id="安装路径设置">安装路径设置</h3><p>先查看当前缓存和全局安装包路径，默认在C盘</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm config get prefix<br>npm config get cache<br></code></pre></td></tr></table></figure><p>设置为其他路径,路径自定义</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm config <span class="hljs-built_in">set</span> prefix D:\npm\node_global<br>npm config <span class="hljs-built_in">set</span> cache D:\npm\node_cache<br></code></pre></td></tr></table></figure><h3 id="设置淘宝镜像"><a href="https://npmmirror.com/">设置淘宝镜像</a></h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com<br></code></pre></td></tr></table></figure><p>设置完成后可以查看npm全局配置</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm config list -g<br></code></pre></td></tr></table></figure><p>输出信息中有这样一条信息<code>&quot;user&quot; config from C:\Users\onebot\.npmrc</code>,这就是npm的全局配置文件，也可以直接修改配置文件来配置</p><hr><h3 id="常用命令">常用命令</h3><ol><li>安装命令</li></ol><ul><li><p>根据现有脚手架初始化项目,例初始化一个vue项目</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm create vue@latest<br></code></pre></td></tr></table></figure></li><li><p>安装项目中所有依赖(项目中有package.json文件)</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install<br></code></pre></td></tr></table></figure></li><li><p><strong>安装模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install 模块名<br></code></pre></td></tr></table></figure><p>在使用npm安装模块时，参数的使用会影响模块的安装方式和位置，以及如何在<code>package.json</code>文件中记录这些模块。以下是各参数的区别：</p><ul><li><strong>无参数</strong>：当你运行<code>npm install module_name</code>而不加任何参数时，npm5开始，默认行为与<code>--save</code>相同，即模块会被安装在本地<code>node_modules</code>目录下，并且模块的条目会被添加到<code>package.json</code>文件的<code>dependencies</code>字段中。</li><li><strong>-g 或 --global</strong>：这个参数用于全局安装模块。全局安装的模块不会被添加到当前项目的<code>node_modules</code>目录或<code>package.json</code>文件中，而是安装在系统范围内的位置，这样你可以在任何地方使用它们。</li><li><strong>-S 或 --save</strong>：这个参数将模块添加到<code>package.json</code>文件的<code>dependencies</code>字段中。这些依赖项是在生产环境中需要的，即在实际运行应用程序时需要的模块。</li><li><strong>-D 或 --save-dev</strong>：这个参数将模块添加到<code>package.json</code>文件的<code>devDependencies</code>字段中。<code>devDependencies</code>通常用于开发环境，比如编译工具或测试框架，这些模块不会在生产环境中使用。</li></ul><p>简而言之，无参安装会将模块添加到<code>dependencies</code>，<code>-g</code>用于全局安装，<code>-S</code>用于生产环境依赖，而<code>-D</code>用于开发环境依赖</p></li><li><p>卸载模块</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm uninstall 模块 <br>npm uninstall 模块 -g <br>npm uninstall 模块 -s <br>npm uninstall 模块 -d<br></code></pre></td></tr></table></figure><p>当您使用<code>npm uninstall</code>命令卸载模块时，可以通过添加不同的参数来改变命令的行为。以下是各个参数的解释：</p><ul><li><code>npm uninstall 模块</code>：从项目的<code>node_modules</code>目录中卸载指定的模块，并且会从<code>package.json</code>文件的<code>dependencies</code>字段中移除该模块的条目</li><li><code>npm uninstall 模块 -g</code>：添加<code>-g</code>参数表示全局卸载模块。这将从全局安装位置卸载模块，而不是从当前项目中卸载。</li><li><code>npm uninstall 模块 -D</code>：添加<code>-D</code>或<code>--save-dev</code>参数时，卸载操作会从<code>package.json</code>文件的<code>devDependencies</code>字段中移除模块的条目。这通常用于开发依赖，即那些只在开发过程中需要的模块</li></ul></li><li><p>更新模块</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm update express  <span class="hljs-comment"># 更新最新版本</span><br>npm update express@2.1.0  <span class="hljs-comment"># 更新到指定版本</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="yarn"><a href="https://www.yarnpkg.cn/getting-started">yarn</a></h2><h3 id="简介-2">简介</h3><p>Yarn是一个现代的包管理工具，它是<strong>为了解决一些npm的缺陷</strong>而被创建的。它由Facebook、Google、Exponent（现在为Expo.dev）、Tilde（Ember.js背后的公司）共同开发。Yarn提供了速度快、安全性高和跨平台一致性等优势</p><h3 id="安装">安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install -g yarn<br></code></pre></td></tr></table></figure><p>2、安装成功后，查看版本号：</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn --version<br></code></pre></td></tr></table></figure><h3 id="常用命令-2">常用命令</h3><h4 id="显示所有配置">显示所有配置</h4><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn config list <span class="hljs-comment"># 显示所有配置项</span><br></code></pre></td></tr></table></figure><h4 id="设置淘宝镜像-2">设置淘宝镜像</h4><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com <span class="hljs-comment"># 添加淘宝源</span><br></code></pre></td></tr></table></figure><h4 id="安装模块"><strong>安装模块</strong></h4><p><code>yarn install</code> 和 <code>yarn add</code> 命令都是用于管理项目依赖的 Yarn 包管理工具的命令，但它们的用途和行为有所不同</p><p><code>yarn install</code> 命令用于安装 <code>package.json</code> 文件中列出的所有依赖项。当你克隆一个项目或者需要更新/安装其他开发者添加的依赖时，通常会运行这个命令。如果项目中有 <code>yarn.lock</code> 文件，Yarn 会使用该文件中锁定的版本来确保依赖的一致性。</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn install<br></code></pre></td></tr></table></figure><p><code>yarn add</code> 命令用于将新的包添加到项目的依赖中。当你想要添加一个新的库或工具到你的项目时，你会使用这个命令。它会更新 <code>package.json</code> 和 <code>yarn.lock</code> 文件，以包含新添加的依赖项。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yarn add &lt;package&gt;<br></code></pre></td></tr></table></figure><p>例如，如果你想要添加 <code>lodash</code> 作为项目依赖，你可以运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yarn add lodash<br></code></pre></td></tr></table></figure><p>如果你想将依赖项添加到开发依赖（<code>devDependencies</code>），可以使用 <code>--dev</code> 标志：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yarn add &lt;package&gt; --dev<br></code></pre></td></tr></table></figure><blockquote><p>总结一下，<code>yarn install</code> 是用来安装所有已经在 <code>package.json</code> 中声明的依赖项，而 <code>yarn add</code> 是用来添加新的依赖项到你的项目中，并更新 <code>package.json</code> 和 <code>yarn.lock</code> 文件</p></blockquote><h4 id="移除模块">移除模块</h4><p>移除后,自动更新package.json和yarn.lock</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn remove &lt;packageName&gt;<br></code></pre></td></tr></table></figure><h4 id="运行脚本">运行脚本</h4><p>用来执行在 package.json 中 scripts 属性下定义的脚本</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn run <br></code></pre></td></tr></table></figure><h4 id="缓存">缓存</h4><p>列出已缓存的每个包</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn cache list <br></code></pre></td></tr></table></figure><p>返回 全局缓存位置</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn cache <span class="hljs-built_in">dir</span> <br></code></pre></td></tr></table></figure><p>清除缓存</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn cache clean <br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git版本控制系统</title>
      <link href="/2024/03/25/git/"/>
      <url>/2024/03/25/git/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://nulab.com/zh-cn/learn/software-development/git-tutorial/">Git</a></h1><p><a href="https://git-scm.com/">Git官网</a></p><h2 id="介绍">介绍</h2><blockquote><p>Git是一个开源的<strong>分布式版本控制系统</strong>，用于高效地处理从小到大的项目。Git由Linus Torvalds创建，用于管理Linux内核开发。与集中式版本控制系统不同，如CVS或Subversion，Git采用分布式版本库的方式，不需要服务器端软件支持。这使得源代码的发布和交流变得非常方便。Git的速度很快，特别适合大型项目的版本管理。</p></blockquote><h2 id="常用命令">常用命令</h2><p>Git的常用命令包括但不限于以下几个：</p><ul><li><code>git init</code>：初始化一个Git仓库。</li><li><code>git clone [url]</code>：克隆一个仓库到本地。</li><li><code>git add [file]</code>：添加文件到暂存区。</li><li><code>git commit -m &quot;[message]&quot;</code>：提交更新，并附加一条提交信息。</li><li><code>git status</code>：查看仓库当前的状态，显示有变更的文件。</li><li><code>git push [alias] [branch]</code>：将本地分支的更新推送到远程仓库。</li><li><code>git pull [alias] [branch]</code>：从远程仓库拉取更新并合并到本地。</li><li><code>git branch</code>：列出所有本地分支。</li><li><code>git checkout [branch-name]</code>：切换到指定分支。</li><li><code>git merge [branch]</code>：合并指定分支到当前分支。</li></ul><p>工作流程图</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20240325220023918.png" alt="image-20240325220023918"></p><h2 id="撤消提交">撤消提交</h2><p>使用<a href="https://nulab.com/zh-cn/learn/software-development/git-tutorial/git-commands-settings/basic-git-commands/#undo-changes-from-previous-commit">git revert 命令</a>撤消以前的提交。这是撤消更改的最常用方法。</p><p>Revert 命令可创建一个新的提交，用于恢复先前提交所做的更改。它允许您撤消不需要的更改，而无需完全移除提交或修改存储库的历史记录。它是一个有用的工具，用于管理对 Git 存储库的更改，同时保留其历史记录。</p><p>虽然你可以用<a href="https://nulab.com/zh-cn/learn/software-development/git-tutorial/git-commands-settings/git-commit-history-commands/#remove-previous-commit">git reset</a>或<a href="https://nulab.com/zh-cn/learn/software-development/git-tutorial/git-commands-settings/git-commit-history-commands/#modify--move-past-commit-and-messages">git rebase -i</a> 命令，从历史记录中删除先前的提交，但一般不建议这样做，因为这会导致远程存储库与其他成员的本地存储库不同</p><p><img src="https://img2.imgtp.com/2024/04/05/9LmbHSHT.png" alt=""></p><h2 id="推送">推送</h2><p>要与他人共享更改，您必须使用 <a href="https://nulab.com/zh-cn/learn/software-development/git-tutorial/git-commands-settings/remote-git-commands/#create--push-branch-changes-to-remote-repository">git push</a>命令，这将更新远程存储库并将其与本地存储库同步。</p><p><img src="https://img2.imgtp.com/2024/04/05/3aE4gI25.png" alt="Diagram of pushing changes."></p><h2 id="解决合并冲突">解决合并冲突</h2><p>在正确完成合并之前，您可能会遇到需要解决的冲突。例如，如果两个或多个成员在两个不同的分支 (即远程和本地分支) 中对文件的同一部分进行更改，Git 无法自动合并它们。</p><p>发生这种情况时，Git 会在冲突文件中添加<strong>冲突解决标记</strong>。这些标记可帮助您确定文件的哪些部分<strong>需要手动处理</strong>。</p><p><img src="https://img2.imgtp.com/2024/04/05/axyuLgdV.png" alt="Diagram of a merging change.">发生冲突的示例。</p><p>在我们上面的例子中，<code>=====</code>上面的所有内容都是您的本地内容，下面的所有内容都来自远程分支。</p><p>在继续创建合并提交之前，您必须依照下列所示方式解决冲突部分。</p><p><img src="https://img2.imgtp.com/2024/04/05/sTrZf4ry.png" alt="Diagram of a merging change.">修改变更集以解决冲突。</p><h2 id="修正提交">修正提交</h2><p>您可以通过运行 <a href="https://nulab.com/zh-cn/learn/software-development/git-tutorial/git-commands-settings/git-commit-history-commands/#modify-previous-commit-and-messages">git commit --amend 命令</a>修改同一分支中的最新提交。这个命令可以方便地将新的或更新的文件添加到上一次提交中。这也是一种编辑提交消息或将提交消息添加到上一次提交的简便方法。</p><p><img src="https://img2.imgtp.com/2024/04/05/VvZtwaIV.png" alt="Diagram using the git ammend command.">使用 git commit --amend 修改最新的提交</p><h2 id="分支">分支</h2><p>Git分支是一个非常强大的功能，它允许你在不同的开发线路上独立工作，而不会影响主线（通常是master分支）。这样，你可以在一个分支上开发新功能，而在另一个分支上修复bug，然后再将它们合并回主线。分支的用途包括：</p><ul><li><strong>功能开发和并行开发</strong>：你可以在不同的分支上同时开发多个功能。</li><li><strong>Bug修复和紧急修复</strong>：为了不干扰主要开发，可以在单独的分支上进行bug修复。</li><li><strong>版本发布和稳定的主分支</strong>：保持主分支稳定，只有完全测试通过的代码才能合并。</li><li><strong>实验性开发和试验性分支</strong>：尝试新想法而不影响主分支。</li><li><strong>多人协作和团队开发</strong>：团队成员可以在各自的分支上工作，然后合并他们的更改。</li></ul><p>假设你正在开发一个新功能，我们将其称为“feature-x”。你不希望这些更改影响主分支，因此你可以创建一个新分支并在其中工作。以下是步骤：</p><ol><li><p><strong>创建新分支</strong>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch feature-x<br></code></pre></td></tr></table></figure><p>这将创建一个名为<code>feature-x</code>的新分支。</p></li><li><p><strong>切换到新分支</strong>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout feature-x<br></code></pre></td></tr></table></figure><p>现在你在<code>feature-x</code>分支上工作。</p></li><li><p><strong>添加更改</strong>： 在<code>feature-x</code>分支上进行更改后，使用以下命令将它们添加到暂存区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git add .<br></code></pre></td></tr></table></figure></li><li><p><strong>提交更改</strong>： 提交你的更改，并附加一条提交信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;Add new feature x&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>切换回主分支</strong>： 完成开发后，切换回主分支：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout master<br></code></pre></td></tr></table></figure></li><li><p><strong>合并分支</strong>： 将<code>feature-x</code>分支的更改合并到主分支：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git merge feature-x<br></code></pre></td></tr></table></figure></li><li><p><strong>推送更改</strong>： 如果你想将更改推送到远程仓库，使用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git push origin master<br></code></pre></td></tr></table></figure></li></ol><h2 id="gitignore">gitignore</h2><h3 id="名称">名称</h3><p>gitignore - 指定有意不跟踪的文件</p><h3 id="概述">概述</h3><p>$XDG_CONFIG_HOME/git/ignore, $GIT_DIR/info/exclude, .gitignore</p><h3 id="描述">描述</h3><p><code>gitignore</code> 文件指定了 Git 追踪时应忽略的文件。 已被 Git 追踪的文件不受影响，详见下面的注释。</p><p><code>gitignore</code> 文件中的每一行都指定了一个模式。 在决定是否忽略路径时，Git 通常会检查多个来源的 <code>gitignore</code> 模式，优先级从高到低（在一个优先级内，由最后匹配的模式决定结果）：</p><ul><li>从支持这些模式的命令行中读取的模式。</li><li>模式从与路径相同目录下的 <code>.gitignore</code> 文件或任何父目录（直到工作树的顶层）中读取，上层文件中的模式会被下层文件中的模式覆盖，直到包含该文件的目录。这些模式相对于 <code>.gitignore</code> 文件的位置进行匹配。 项目通常会在其资源库中包含此类 <code>.gitignore</code> 文件，其中包含项目构建过程中生成的文件的模式。</li><li>从 <code>$GIT_DIR/info/exclude</code> 中读取的模式。</li><li>从配置变量 <code>core.excludesFile</code> 指定的文件中读取的模式。</li></ul><p>将模式放入哪个文件取决于模式的使用方式。</p><ul><li>应受版本控制并通过克隆分发到其他仓库的模式（即所有开发人员都想忽略的文件）应放入 <code>.gitignore</code> 文件。</li><li>特定于某个仓库但无需与其他相关仓库共享的模式（例如，存在于仓库内部但特定于某个用户工作流程的辅助文件）应放入 <code>$GIT_DIR/info/exclude</code> 文件。</li><li>用户希望 Git 在任何情况下都忽略的模式（例如，由用户选择的编辑器生成的备份或临时文件），一般会放入用户的 <code>~/.gitconfig</code> 中由 <code>core.excludesFile</code> 指定的文件。它的默认值是 $XDG_CONFIG_HOME/git/ignore。如果 $XDG_CONFIG_HOME 未设置或为空，则使用 $HOME/.config/git/ignore 代替。</li></ul><p>底层的 Git 工具，如 <em>git ls-files</em> 和 <em>git read-tree</em>，会读取命令行选项指定的 <em>gitignore</em> 模式，或从命 令行选项指定的文件中读取。 更高层次的 Git 工具，如 <em>git status</em> 和 <em>git add</em>，会使用上述指定来源的模式。</p><h3 id="日期格式">日期格式</h3><ul><li>空行不匹配任何文件，因此可以作为分隔符，以提高可读性。</li><li>以 # 开头的一行为注释。 对于以散列开头的模式，在第一个散列前面加上反斜杠（ “<code>\</code>” ）。</li><li>除非使用反斜线（“<code>\</code>”）引号，否则尾部空格将被忽略。</li><li>一个可选的前缀 “<code>!``&quot;，用于否定模式；任何被先前模式排除的匹配文件都将被重新包含。如果文件的父目录已被排除，则无法重新包含该文件。出于性能考虑，Git 不会列出排除的目录，因此无论在哪里定义，任何包含文件的模式都不会产生影响。 对于以 &quot;</code>!<code>&quot; 开头的模式，在第一个 &quot;</code>!<code>&quot; 前面加反斜杠（&quot;</code>`”），例如 “<code>\!important!.txt</code>”。</li><li>斜线 “<code>/</code>” 用作目录分隔符。分隔符可以出现在 <code>.gitignore</code> 搜索模式的开头、中间或结尾。</li><li>如果在模式的开头或中间（或两者都有）有分隔符，则该模式是相对于特定 <code>.gitignore</code> 文件本身的目录层级而言的。否则，该模式也可能匹配 <code>.gitignore</code> 层级以下的任何层级。</li><li>如果模式末尾有分隔符，则模式只能匹配目录，否则模式既可以匹配文件，也可以匹配目录。</li><li>例如，模式 <code>doc/frotz/</code> 匹配 <code>doc/frotz</code> 目录，但不匹配 <code>a/doc/frotz</code> 目录；而 <code>frotz/</code> 则匹配 <code>frotz</code> 和 <code>a/frotz</code> 这两个目录（所有路径都是从 <code>.gitignore</code> 文件开始的相对路径）。</li><li>星号 “<code>*</code>” 匹配斜线以外的任何字符。 字符 “<code>?</code>” 匹配除 “<code>/</code>” 以外的任何一个字符。 范围符号，如 “<code>[a-zA-Z]</code>”，可用于匹配范围中的一个字符。更详细的说明请参见 fnmatch(3) 和 FNM_PATHNAME 标志。</li></ul><p>在与全路径名匹配的模式中，两个连续的星号（“<code>**</code>”）可能有特殊含义：</p><ul><li>“<code>**</code>“在带斜杠目录之前，表示在所有目录中匹配。例如，”<code>**/foo</code>&quot;匹配任何文件或目录的&quot;<code>foo</code>”，与模式&quot;<code>foo</code>&quot;相同。“<code>**/foo/bar</code>&quot;匹配任何文件或目录中直接位于目录&quot;<code>foo</code>&quot;之下的&quot;<code>bar</code>”。</li><li>路径后跟有 “<code>/**</code>” 表示匹配这个目录里面的所有文件。例如，“<code>abc/**</code>” 匹配相对于 <code>.gitignore</code> 文件的位置中目录 “<code>abc</code>” 内的所有文件，深度无限。</li><li>一个斜杠后面是两个连续的星号再接上一个斜杠，匹配零个或多个目录。例如，“<code>a/**/b</code>” 匹配 “<code>a/b</code>”、“<code>a/x/b</code>”、“<code>a/x/y/b</code>”，等等，依此类推。</li><li>其他连续星号被视为普通星号，将根据前面的规则进行匹配。</li></ul><h3 id="配置">配置</h3><p>可选的配置变量 <code>core.excludesFile</code> 表示包含要排除的文件名模式的文件路径，类似于 <code>$GIT_DIR/info/exclude</code>。 除 <code>$GIT_DIR/info/exclude</code> 中的模式外，还将使用排除文件中的模式。</p><h3 id="注释">注释</h3><p>使用 gitignore 文件的目的是确保某些不被 Git 追踪的文件不被追踪。</p><p>要停止跟踪当前已被跟踪的文件，可使用 <em>git rm --cached</em> 从索引中移除该文件。文件名随后会被添加到 <code>.gitignore</code> 文件中，以防止该文件在以后的提交中被重新引入。</p><p>访问工作树中的 <code>.gitignore</code> 文件时，Git 不会跟踪符号链接。这样，当从索引或工作树访问文件时，与从文件系统访问文件时的行为保持一致。</p><h3 id="实例">实例</h3><ul><li>模式 <code>hello.*</code> 匹配名称以 <code>hello.</code> 开头的任何文件或目录。如果只想将其限制在目录中，而不限制在其子目录中，则可以在模式前加上斜线，即 <code>/hello.*</code>；现在该模式可匹配 <code>hello.txt</code> 和 <code>hello.c</code> 但不匹配 <code>a/hello.java</code>。</li><li>模式 <code>foo/</code> 将匹配目录 <code>foo</code> 及其下的路径，但不会匹配常规文件或符号链接 <code>foo</code>（这与 Git 中 pathspec 的一般工作方式一致）</li><li><code>doc/frotz</code> 和 <code>/doc/frotz</code> 模式在任何 <code>.gitignore</code> 文件中都有同样的效果。换句话说，如果模式中已经有中间斜线，那么前导斜线就无关紧要了。</li><li>模式 <code>foo/*</code> 匹配 <code>foo/test.json</code>（一个正则文件）和 <code>foo/bar</code>（一个目录），但不匹配 <code>foo/bar/hello.c</code>（一个正则文件），因为模式中的星号不匹配 <code>bar/hello.c</code>，因为 <code>bar/hello.c</code> 中含有斜线。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">$ git status<br>[...]<br># 未追踪的文件:<br>[...]<br>#       Documentation/foo.html<br>#       Documentation/gitignore.html<br>#       file.o<br>#       lib.a<br>#       src/internal.o<br>[...]<br>$ cat .git/info/exclude<br># 忽略在目录树中的所有对象和存档文件<br>*.[oa]<br>$ cat Documentation/.gitignore<br># 忽略 html 文件,<br>*.html<br># 但追踪自己写的 foo.html<br>!foo.html<br>$ git status<br>[...]<br># 未追踪的文件:<br>[...]<br>#       Documentation/foo.html<br>[...]<br></code></pre></td></tr></table></figure><p>再举一个例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">$ cat .gitignore<br>vmlinux*<br>$ ls arch/foo/kernel/vm*<br>arch/foo/kernel/vmlinux.lds.S<br>$ echo &#x27;!/vmlinux*&#x27; &gt;arch/foo/kernel/.gitignore<br></code></pre></td></tr></table></figure><p>第二个 .gitignore 阻止 Git 忽略 <code>arch/foo/kernel/vmlinux.lds.S</code>。</p><p>示例排除除特定目录 <code>foo/bar</code> 以外的所有内容（注意 <code>/*</code> - 如果没有斜线，通配符也会排除 <code>foo/bar</code> 中的所有内容）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">$ cat .gitignore<br># 排除 foo/bar 以外的所有内容<br>/*<br>!/foo<br>/foo/*<br>!/foo/bar<br></code></pre></td></tr></table></figure><h2 id="简化使用">简化使用</h2><p>将下面代码保存为py文件，就能直接运行python执行一些常用操作，<strong>注意<code>git glog</code>是我自定义的一个命令</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;---------------------------------------------------------&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;enter ---&gt; 状态&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1     ---&gt; 添加&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2     ---&gt; 提交&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3     ---&gt; 推送&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;4     ---&gt; 拉取&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;5     ---&gt; 添加、提交、推送&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;6     ---&gt; 日志&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;7     ---&gt; 远程仓库&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;else  ---&gt; 退出&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;---------------------------------------------------------&#x27;</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        show()<br>        choice = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;chioce: &#x27;</span>))<br>        <span class="hljs-keyword">if</span> choice == <span class="hljs-literal">None</span>:<br>            os.system(<span class="hljs-string">&#x27;git status&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> choice == <span class="hljs-number">1</span>:<br>            os.system(<span class="hljs-string">&#x27;git add .&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> choice == <span class="hljs-number">2</span>:<br>            message = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Enter your message: &#x27;</span>)<br>            os.system(<span class="hljs-string">f&#x27;git commit -m &quot;<span class="hljs-subst">&#123;message&#125;</span>&quot;&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;message:<span class="hljs-subst">&#123;message&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> choice == <span class="hljs-number">3</span>:<br>            os.system(<span class="hljs-string">&#x27;git push&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> choice == <span class="hljs-number">4</span>:<br>            os.system(<span class="hljs-string">&#x27;git pull&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> choice == <span class="hljs-number">5</span>:<br>            message = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Enter your message: &#x27;</span>)<br>            os.system(<span class="hljs-string">f&#x27;git add .&#x27;</span>)<br>            os.system(<span class="hljs-string">f&#x27;git commit -m &quot;<span class="hljs-subst">&#123;message&#125;</span>&quot;&#x27;</span>)<br>            os.system(<span class="hljs-string">f&#x27;git push&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;message:<span class="hljs-subst">&#123;message&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> choice == <span class="hljs-number">6</span>:<br>            os.system(<span class="hljs-string">&#x27;git glog&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> choice == <span class="hljs-number">7</span>:<br>            os.system(<span class="hljs-string">&#x27;git remote -v&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            exit()<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(e, ValueError):<br>            os.system(<span class="hljs-string">&#x27;git status&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Invalid choice&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows定时关机</title>
      <link href="/2024/03/19/windows%E5%AE%9A%E6%97%B6%E5%85%B3%E6%9C%BA/"/>
      <url>/2024/03/19/windows%E5%AE%9A%E6%97%B6%E5%85%B3%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<ol><li>打开控制面板，搜索<strong>计划</strong>，点击<mark>计划任务</mark></li></ol><p><img src="https://s2.loli.net/2024/03/19/8olEi2dyD5xTKcG.png" alt="image-20240319223355706"></p><ol start="2"><li>右键<strong>任务计划程序库</strong>，创建任务</li></ol><p><img src="https://s2.loli.net/2024/03/19/gpT9YVFaxUEWq3C.png" alt="image-20240319223747111"></p><ol start="3"><li>常规</li></ol><p><img src="https://s2.loli.net/2024/03/19/Mr2XbwVfNPxUD8g.png" alt="image-20240319223931837"></p><ol start="4"><li>触发器</li></ol><p><img src="https://s2.loli.net/2024/03/19/oIUu7gqSaji2O83.png" alt="image-20240319224108154"></p><ol start="5"><li>操作，22:55触发，240秒后启动，也就是22:59关机</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/JB9cJCiy.png" alt="image-20240319224152722"></p><ol start="6"><li>条件</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/1CTTQHty.png" alt="image-20240319224409803"></p><ol start="7"><li>设置<img src="https://img2.imgtp.com/2024/04/04/vZu4bFVM.png" alt="image-20240319224442431"></li></ol><p>最后保存即可，这样就能在断电前一分钟让电脑自动关机了，可以通过查看执行记录看看任务有没有正常执行或者自己写一个脚本添加在关机指令之后的第二条指令</p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apifox测试工具</title>
      <link href="/2024/03/18/apifox%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/03/18/apifox%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1>Apifox</h1><p><a href="https://apifox.com/help/">官方文档</a></p><h2 id="登录自动更新token">登录自动更新token</h2><blockquote><p>问题：使用apifox测试接口时，令牌过期后，需要重新登录，然后复制粘贴替换全局变量的token，有点麻烦，而且不注意可能会复制错误，怎么实现运行登录接口后自动将返回数据中的token值更新，然后其他请求自动携带全新的token呢</p></blockquote><h3 id="1-给登录接口添加后置操作">1.给登录接口添加后置操作</h3><blockquote><p><strong>1.1 打开项目的登录接口，添加该接口的后置操作</strong></p></blockquote><p><img src="https://s2.loli.net/2024/03/31/BVyNZqb1Mfm7UsW.png" alt="1"></p><blockquote><p><strong>1.2 随便设置一个变量名字，然后点击小箭头</strong></p></blockquote><p><img src="https://s2.loli.net/2024/03/31/ZChcWljvr3yNdGx.png" alt="2"></p><blockquote><p><strong>1.3 左边是返回结果的结构，书写jsonpath表达式 ，$代表左边的json对象，然后就像访问对象属性一样写就可以了，最后看看提取结果和左边是不是对上了，最后点击确定保存，我的token是data中的token，所以是 <code>$.data.token</code></strong></p></blockquote><p><img src="https://s2.loli.net/2024/03/31/HAPCavXuh9Ns5lY.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p><strong>1.4 保存接口文档后测试接口</strong></p></blockquote><p><img src="https://s2.loli.net/2024/03/31/2uJr9ocZqThwCQP.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p><strong>1.5 如果上面操作无误，点击右上角按钮可以看到在本地环境多了一个变量值token，并且值就是返回结果的token</strong></p></blockquote><p><img src="https://s2.loli.net/2024/03/31/nW2jkyY3ZHiuz4f.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="2-设置项目所有接口的auth认证">2.设置项目所有接口的auth认证</h3><blockquote><p><strong>2.1 如图依次点击，key的名字根据自己需要设置，value的值从环境变量读取</strong></p></blockquote><p><img src="https://s2.loli.net/2024/03/31/HLtYpbIF3w4eSnk.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p><strong>2.2 读取变量选择之前设置的变量，确定后保存接口的修改</strong></p></blockquote><p><img src="https://s2.loli.net/2024/03/31/6RGFCTetWnHb3Kh.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p><strong>3. 测试执行登录接口是否会自动设置token，可以执行登录接口后直接执行其他接口</strong></p></blockquote><p><img src="https://s2.loli.net/2024/03/31/GWsMZJSzY2Nqw1H.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>每次修改完成后记得保存再运行，这样就能简单完成token的自动更换</p><h2 id="Apifox-IDEA-插件快速上手"><a href="https://apifox.com/help/applications-and-plugins/idea/start">Apifox IDEA 插件快速上手</a></h2><p><code>Apifox Helper</code> 是 Apifox 团队针对 IntelliJ IDEA 环境所推出的插件，可以在 IDEA 环境中识别本地 Java、Kotlin 后端项目的源代码，自动生成 API 文档并一键同步到 Apifox 的项目中。</p><p>对于常见的开发框架，<code>Apifox Helper</code> 插件能够做到开箱即用，实现真正的代码零侵入。如下图所示，仅通过识别最基本的 SpringBoot 代码，即可生成一份详尽的 API 文档：</p><p><img src="https://img2.imgtp.com/2024/04/04/hiEguc1i.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apifox </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud从入门到放弃</title>
      <link href="/2024/03/17/springcloud%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
      <url>/2024/03/17/springcloud%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://sca.aliyun.com/zh-cn/">springcloud</a>从入门到放弃</h1><h2 id="gateway">gateway</h2><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><blockquote><p><strong>网关就像是看门大爷，只有校验身份的请求才能访问到后面的微服务</strong></p></blockquote><p><code>Spring Cloud Gateway</code> 是一个基于 Spring 5、Spring Boot 2 和 Project Reactor 的 <strong>API 网关</strong>，以下是使用 Spring Cloud Gateway 的基本步骤：</p><ol><li><strong>添加依赖</strong>：在 Maven 的 <code>pom.xml</code> 文件中，添加 Spring Cloud Gateway 的依赖。</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>配置路由</strong>：在 <code>application.yml</code> 或 <code>application.properties</code> 文件中，配置路由规则。例如，将所有以 <code>/reader/</code> 开头的请求转发到 <code>reader-service</code> 服务。</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment"># 路由配置</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">reader_route</span> <span class="hljs-comment"># id,自定义但是保证唯一</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://reader-service</span> <span class="hljs-comment"># 可以直接填写服务地址,此处只是指名服务名称,可以实现负载均衡,lb即loadbalance</span><br>        <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 断言,路径必须是 reader 开头</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/reader/**</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>添加JWT拦截器</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> exchange.getRequest().getPath().value();<br>        <span class="hljs-comment">// 不对/login和/register接口校验</span><br>        <span class="hljs-keyword">if</span> (path.endsWith(<span class="hljs-string">&quot;/login&quot;</span>) || path.endsWith(<span class="hljs-string">&quot;/register&quot;</span>)) &#123;<br>            log.debug(<span class="hljs-string">&quot;直接跳过...&quot;</span>);<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br><br>        log.debug(<span class="hljs-string">&quot;开始校验...&quot;</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> exchange.getRequest().getHeaders().getFirst(Common.TOKEN);<br>        <span class="hljs-keyword">if</span> (token == <span class="hljs-literal">null</span> || token.isEmpty()) &#123;<br>            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);<br>            <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">redisToken</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(token);<br>            <span class="hljs-keyword">if</span> (redisToken == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseException</span>(Excep.TOKEN_ALREADY_EXPIRED);<br>            &#125;<br>            <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> JwtUtils.parseJWT(token);<br>            <span class="hljs-comment">// 保存用户信息</span><br>            ThreadLocalUtil.set(claims);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);<br>            <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">100</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p><strong>启动 Gateway</strong>：运行 Spring Boot 应用，启动 Gateway。</p></li><li><p><strong>发送请求</strong>：<strong>发送请求到 Gateway</strong>，Gateway 会根据配置的路由规则，将请求转发到对应的服务。</p></li></ol><p>以上就是使用 Spring Cloud Gateway 的基本步骤。在实际使用中，可能还需要配置其他的功能，例如过滤器、限流、熔断等。</p><p><img src="https://camo.githubusercontent.com/f50234cb9f1be4beead6b35d3f6ec558561a79c263728818838447aa56cb5401/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f73756e3032323553554e2f73756e3032323553554e2f6173736574732f696d616765732f68722e676966" alt=""></p><h2 id="openfeign">openfeign</h2><h3 id="基本使用">基本使用</h3><ol><li><p><strong>引入依赖</strong>： 在 <code>pom.xml</code> 文件中添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>创建 Feign 客户端接口</strong>： 在使用 OpenFeign 时，我们需要创建一个 Feign 客户端接口，用于定义我们想要调用的服务接口。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;user-service&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserServiceClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/users&quot;)</span><br>    User <span class="hljs-title function_">createUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>注入 Feign 客户端</strong>： 在你的控制器中，使用 <code>@Autowired</code> 将 <code>UserServiceClient</code> 注入，并通过该客户端接口调用远程服务。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserServiceClient userServiceClient;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> userServiceClient.getUserById(id);<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/users&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">createUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> userServiceClient.createUser(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>启用 Feign</strong>： 在 Spring Boot 应用程序的启动类上添加 <code>@EnableFeignClients</code> 注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>通过使用 OpenFeign，我们可以更加便捷地编写 HTTP 服务客户端，简化了开发流程。</p><h3 id="配置连接池">配置连接池</h3><ol><li><p><strong>添加依赖</strong>： 首先，在 <code>pom.xml</code> 文件中添加 <code>Apache HttpClient</code> 的依赖，以替换 OpenFeign 默认的底层客户端 HttpURLConnection：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>配置连接池属性</strong>： 在 <code>application.properties</code> 或 <code>application.yml</code> 中配置连接池的相关属性。你可以根据需求设置以下属性：</p><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">feign.httpclient.connection-manager.max-total</span>=<span class="hljs-string">20</span><br></code></pre></td></tr></table></figure></li><li><p><strong>启用 HttpClient</strong>： 在 Spring Boot 应用程序的启动类上添加 <code>@EnableFeignClients</code> 注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(MyApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="待续……">待续……</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
            <tag> gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos从入门到入土</title>
      <link href="/2024/03/16/nacos%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
      <url>/2024/03/16/nacos%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1>快速入土</h1><h2 id="下载">下载</h2><p><a href="https://nacos.io/download/nacos-server/#%E7%A8%B3%E5%AE%9A%E7%89%88%E6%9C%AC">Nacos Server 下载 | Nacos</a></p><h2 id="启动">启动</h2><p>解压缩后在<code>bin</code>目录下有几个脚本，<code>startup</code>就是启动脚本,默认都是集群<code>cluster</code>方式启动,也可以使用单机<code>standalone</code>模式启动</p><ol><li><p>第一种方法，添加启动参数，打开控制台，输入：</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">startup -m standalone<br></code></pre></td></tr></table></figure></li><li><p>第二种方法，复制一份<code>startup.cmd</code>文件，修改启动模式</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> MODE=<span class="hljs-string">&quot;standalone&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>我表示：在<code>terminal</code>中添加一个powershell的配置，设置启动目录为nacos的bin目录，修改startup为nacos</p><p><img src="https://img2.imgtp.com/2024/04/04/rIiefetU.png" alt="image-20240316202535951"></p></li></ol><p>启动后默认端口为<code>8848</code>，可以在<code>conf/application.properties</code>文件中修改<code>server.port</code></p><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8888</span><br></code></pre></td></tr></table></figure><p>浏览器打开<code>http://localhost:8848/nacos</code>即可看到nacos界面</p><p><img src="https://s2.loli.net/2024/03/16/Q3jGhpuLe7iU4Kg.png" alt="image-20240316203105872"></p><h2 id="导入依赖">导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="添加配置">添加配置</h2><p>添加nacos地址与当前项目的应用名称，默认是单机模式</p><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">book-service</span><br></code></pre></td></tr></table></figure><h2 id="注册服务">注册服务</h2><p>启动项目，可以看到当前项目服务已经注册到nacos</p><p><img src="https://s2.loli.net/2024/03/16/uUS8oGh4OliKAVF.png" alt="image-20240316204044294"></p><hr><h1>配置管理</h1><ol><li>新建<code>bootstrap.yml</code>文件，此文件优先级很高，可以在启动时优先读取，将nacos配置放在这个文件中</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yml</span> <span class="hljs-comment"># 文件后缀名</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway-service</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在nacos控制台创建配置文件</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/GU95oOv7.png" alt="image-20240324224923143"></p><p>配置文件的名字为<code>&#123;application.name&#125;-&#123;dev/test&#125;.yml</code></p><p><img src="https://img2.imgtp.com/2024/04/04/stfNxt9H.png" alt="image-20240324225122126"></p><p>配置内容一般为开关之类的配置，填写后点击发布</p><ol start="3"><li>读取配置</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">config:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;cao&quot;</span><br>  <br></code></pre></td></tr></table></figure><p>使用<code>@ConfigurationProperties</code>注解可以实现配置的热更新(配置发布后项目中配置立即更新)</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;config&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigProperties</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
            <tag> nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shields-技术栈标签</title>
      <link href="/2024/03/08/%E4%BD%BF%E7%94%A8shields%E7%BB%99%E4%BB%93%E5%BA%93%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF%E6%A0%88%E6%A0%87%E7%AD%BE/"/>
      <url>/2024/03/08/%E4%BD%BF%E7%94%A8shields%E7%BB%99%E4%BB%93%E5%BA%93%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF%E6%A0%88%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img2.imgtp.com/2024/04/04/yYJX845U.png" alt="image-20240308142105903"></p><blockquote><p>github仓库页面的这种标签是怎么生成的？</p></blockquote><h2 id="1-基本使用">1.基本使用</h2><p><a href="https://shields.io/badges">Static Badge | Shields.io</a> 可以生成各种标签，可以自定义，比如我想生成一个<mark>背景颜色</mark>蓝色标签，名称为<code>mytag</code>就可以使用<code>mytag-blue</code>,前面是名称后面是颜色(可以是16进制颜色)<img src="https://img.shields.io/badge/mytag-blue?style=flat" alt="mytag"></p><p><img src="https://img2.imgtp.com/2024/04/04/BUV0H7vT.png" alt="image-20240308142750757"></p><h2 id="2-版本号">2.版本号</h2><p>也可以指定版本号<code>mytag-v1.2.3-blue</code>，注意版本号在颜色前面<img src="https://img.shields.io/badge/mytag-v1.2.3-blue?style=flat" alt="version"></p><h2 id="3-图标">3.图标</h2><p><a href="https://simpleicons.org/zh-CN/">Simple Icons</a> (这个网站可能有<s>亿</s>点卡)提供了很多产品的logo，比如我想使用redis的logo，直接搜索redis，点击右下角可以复制名字，左下角可以复制配色</p><img src="https://img2.imgtp.com/2024/04/04/o6Z8qcbg.png" alt="image-20240308143650593"  /><p>返回sheilds页面，点击展开显示更多参数</p><p><img src="https://img2.imgtp.com/2024/04/04/CiRV271t.png" alt="image-20240308144647113"></p><p>生成后的效果 <img src="https://img.shields.io/badge/Redis-v7.0.12-%23DC382D?style=flat&amp;logo=redis&amp;logoColor=%23DC382D" alt="Static Badge"></p><h2 id="4-动态生成标签">4.动态生成标签</h2><p>以仓库提交数为例，搜索commit,注意==cacheSeconds==的设置</p><img src="https://img2.imgtp.com/2024/04/04/bqQcvnPU.png" alt="image-20240309173715898" style="zoom:80%;" /><p><img src="https://img.shields.io/github/commit-activity/t/tankingcao/java_design?style=flat&amp;labelColor=red&amp;cacheSeconds=3600" alt="GitHub commit activity"></p><table><thead><tr><th style="text-align:center">标签</th><th style="text-align:center">搜索关键字</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">仓库提交数</td><td style="text-align:center"><code>commit</code></td><td style="text-align:center"><img src="https://img.shields.io/github/commit-activity/t/tankingcao/java_design?style=flat&amp;labelColor=red&amp;cacheSeconds=3600" alt="GitHub commit activity"></td></tr><tr><td style="text-align:center">仓库发行版本</td><td style="text-align:center"><code>github release</code></td><td style="text-align:center"><img src="https://img.shields.io/github/v/release/tankingcao/java_design?include_prereleases&amp;sort=date&amp;display_name=release&amp;style=flat&amp;cacheSeconds=3600" alt="GitHub Release"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shields </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot发送邮件</title>
      <link href="/2024/03/03/springboot%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
      <url>/2024/03/03/springboot%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1>springboot发送邮件</h1><h2 id="导入依赖">导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 邮件依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="添加配置">添加配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mail:</span><br>    <span class="hljs-comment"># qq邮箱的host</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">smtp.qq.com</span><br>    <span class="hljs-comment"># 端口，固定的</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">465</span><br>    <span class="hljs-comment"># 发件人的邮箱</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-number">1265</span><span class="hljs-string">****79@qq.com</span><br>    <span class="hljs-comment"># qq邮箱服务的授权码</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">etj*******afh</span><br>    <span class="hljs-attr">test-connection:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">properties:</span><br>      <span class="hljs-attr">mail:</span><br>        <span class="hljs-attr">smtp:</span><br>          <span class="hljs-attr">ssl:</span><br>            <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="测试发送">测试发送</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MailApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JavaMailSender javaMailSender;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">senderMail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SimpleMailMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleMailMessage</span>();<br>        <span class="hljs-comment">// 发件人 你的邮箱</span><br>        message.setFrom(<span class="hljs-string">&quot;12******9@qq.com&quot;</span>);<br>        <span class="hljs-comment">// 接收人 接收者邮箱</span><br>        message.setTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;tan*****@gmail.com&quot;</span>&#125;);<br>        <span class="hljs-comment">//邮件主题</span><br>        message.setSubject(<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-comment">//邮件内容</span><br>        message.setText(<span class="hljs-string">&quot;test&quot;</span>);<br><br>        javaMailSender.send(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 邮件 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown从入门到上天</title>
      <link href="/2024/03/01/markdown%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%8A%E5%A4%A9/"/>
      <url>/2024/03/01/markdown%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%8A%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1>Markdown</h1><h2 id="简介">简介</h2><blockquote><p><a href="https://markdown.com.cn/">Markdown</a> 是一种轻量级的标记语言，可用于在纯文本文档中添加格式化元素。Markdown 由 John Gruber 于 2004 年创建，如今已成为世界上最受欢迎的标记语言之一</p><ol><li>专注于文字内容；</li><li>纯文本，易读易写，可以方便地纳入版本控制；</li><li>语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版。</li></ol></blockquote><h2 id="基本使用">基本使用</h2><h3 id="字体">字体</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*斜体文本*</span><br><span class="hljs-emphasis">_斜体文本_</span><br><span class="hljs-strong">**粗体文本**</span><br><span class="hljs-strong">__粗体文本__</span><br><span class="hljs-strong">**<span class="hljs-emphasis">*粗斜体文本*</span>**</span><br><span class="hljs-strong">__<span class="hljs-emphasis">_粗斜体文本_</span>__</span><br></code></pre></td></tr></table></figure><p><em>斜体文本</em>，<kbd>Ctrl I</kbd>(此处只针对<code>typora</code>编辑器)<br><em>斜体文本</em><br><strong>粗体文本</strong>，<kbd>Ctrl B</kbd><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em></p><h3 id="分割线">分割线</h3><p><kbd>——- enter</kbd></p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">***</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">* * *</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">**</span><span class="hljs-strong">***</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- - -</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">----------</span><br></code></pre></td></tr></table></figure><hr><hr><hr><hr><hr><h3 id="删除线">删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <strong>~~</strong> 即可，实例如下：<s>clb.pages.dev</s></p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">~~clb.pages.dev~~<br></code></pre></td></tr></table></figure><h3 id="下划线">下划线</h3><p><u>下划线</u>可以通过 HTML 的 <code>&lt;u&gt;</code> 标签来实现：<u>带下划线文本</u></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>带下划线文本<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="脚注">脚注</h3><p>脚注是对文本的<strong>补充说明</strong>,鼠标悬浮后会显示内容,脚注一般放在文章最后</p><p><img src="https://img2.imgtp.com/2024/04/04/K3w12Fo0.gif" alt="recording"></p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">我会使用[^markdown]<br><br>[<span class="hljs-symbol">^markdown</span>]:<span class="hljs-link">Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档</span><br></code></pre></td></tr></table></figure><p>我会使用[^markdown]</p><p>[^markdown]:Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档</p><h3 id="列表">列表</h3><p>Markdown 支持有序列表和无序列表</p><p>无序列表使用星号(<em><strong><strong>)、加号(</strong>+</strong>)或是减号(</em><em>-</em>*)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 第一项<br><span class="hljs-bullet">*</span> 第二项<br><span class="hljs-bullet">*</span> 第三项<br><br><span class="hljs-bullet">+</span> 第一项<br><span class="hljs-bullet">+</span> 第二项<br><span class="hljs-bullet">+</span> 第三项<br><br><span class="hljs-bullet">1.</span> one<br><span class="hljs-bullet">2.</span> two<br><span class="hljs-bullet">3.</span> three<br></code></pre></td></tr></table></figure><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ol><li>one</li><li>two</li><li>three</li></ol><p>嵌套使用</p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 1<br><span class="hljs-bullet">  -</span> 1.1<br><span class="hljs-bullet">    -</span> 1.1.1<br><span class="hljs-bullet">      -</span> 1.1.1.1<br></code></pre></td></tr></table></figure><ul><li>1<ul><li>1.1<ul><li>1.1.1<ul><li>1.1.1.1</li></ul></li></ul></li></ul></li></ul><h3 id="引用">引用</h3><p>Markdown 引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 引用</span><br><span class="hljs-quote">&gt; 123</span><br><span class="hljs-quote">&gt; 456</span><br></code></pre></td></tr></table></figure><blockquote><p>引用<br>123<br>456</p></blockquote><p>可嵌套</p><blockquote><p>123</p><blockquote><p>456</p></blockquote></blockquote><h3 id="代码">代码</h3><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（<strong>`</strong>），例如：<code>print()</code></p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">`print()`</span><br></code></pre></td></tr></table></figure><p>你也可以用 <strong>```</strong> 包裹一段代码，并指定一种语言（也可以不指定）：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">```python</span><br><span class="hljs-code">print(666)</span><br><span class="hljs-code">```</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-number">666</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="链接">链接</h3><p>链接使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[链接名称](链接地址)<br><br>或者<br><br>&lt;链接地址&gt;<br></code></pre></td></tr></table></figure><h4 id="基本使用-2">基本使用</h4><p><a href="https://clb.pages.dev">我的主页</a></p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">我的主页</span>](<span class="hljs-link">https://clb.pages.dev</span>)<br></code></pre></td></tr></table></figure><h4 id="直接使用链接">直接使用链接</h4><p><a href="https://clb.pages.dev">https://clb.pages.dev</a></p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="language-xml">&lt;https://clb.pages.dev&gt;</span><br></code></pre></td></tr></table></figure><h4 id="高级链接">高级链接</h4><blockquote><p>如果我的文档中<strong>很多地方都需要使用一个网址</strong>，可以将这个网址<strong>定义为一个变量</strong>放在文章末尾，其他需要使用这个网址的地方直接<strong>通过变量名访问</strong></p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">这是我的[<span class="hljs-string">主页</span>][<span class="hljs-symbol">home</span>]<br><br>这也是我的[<span class="hljs-string">主页</span>][<span class="hljs-symbol">home</span>]<br><br>这还是我的[<span class="hljs-string">主页</span>][<span class="hljs-symbol">home</span>]<br><br>[<span class="hljs-symbol">home</span>]:<span class="hljs-link">https://clb.pages.dev</span><br></code></pre></td></tr></table></figure><p>这是我的<a href="https://clb.pages.dev" title="我的博客主页">主页</a></p><p>这也是我的<a href="https://clb.pages.dev" title="我的博客主页">主页</a></p><p>这还是我的<a href="https://clb.pages.dev" title="我的博客主页">主页</a></p><h3 id="图片">图片</h3><p>Markdown 图片语法格式如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">alt 属性文本</span>](<span class="hljs-link">图片地址</span>)<br>![<span class="hljs-string">alt 属性文本</span>](<span class="hljs-link">图片地址 &quot;鼠标悬浮时的提示文本&quot;</span>)<br><br>![<span class="hljs-string">boqi</span>](<span class="hljs-link">https://img2.imgtp.com/2024/04/03/EblMf6FV.gif &quot;头要甩掉了...&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字(可以省略)</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘鼠标悬浮时的提示文本’(可以省略)</li><li>图片的链接也可以定义为变量后使用变量名使用</li><li><strong>如果要改变图片大小，只能使用<code>img</code>标签设定相应属性</strong></li></ul><p><img src="https://img2.imgtp.com/2024/04/04/A1kg7et8.gif" alt="boqi" title="头要甩掉了..."></p><h3 id="表格">表格</h3><p>制作表格使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行</p><h4 id="基本使用-3">基本使用</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">|  表头   | 表头  |<br>|  ----  | ----  |<br>| 1  | 2|<br>| 3 | 4|<br></code></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table><h4 id="对齐方式">对齐方式</h4><p><strong>我们可以设置表格的对齐方式：</strong></p><ul><li><strong>-:</strong> 设置内容和标题栏居右对齐。</li><li><strong>:-</strong> 设置内容和标题栏居左对齐。</li><li><strong>:-:</strong> 设置内容和标题栏居中对齐。</li></ul><p>实例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">| 左对齐 | 右对齐 | 居中对齐 |<br>| :-----| ----: | :----: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 |<br></code></pre></td></tr></table></figure><blockquote><p><strong>表格语法比较繁琐，建议使用编辑器插入表格功能</strong></p></blockquote><h2 id="进阶">进阶</h2><h3 id="HTML-元素">HTML 元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写</p><p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等</p><p>在Markdown中，您可以使用多种HTML标签。行内元素，如<code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code>，可以在Markdown的段落、列表或标题中自由使用。此外，您还可以使用<code>&lt;a&gt;</code>和<code>&lt;img&gt;</code>等标签来创建链接和图片。</p><p>对于块级元素，如<code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>和<code>&lt;p&gt;</code>，您需要在它们前后添加空行，并且不要使用制表符或空格进行缩进。请注意，在HTML块级标签内部，Markdown语法将不会被处理。例如，<code>&lt;p&gt;italic and **bold**&lt;/p&gt;</code>将不会显示为斜体和粗体。</p><p><strong>出于安全考虑，并非所有Markdown应用程序都支持在Markdown文档中添加HTML。如果您不确定您的应用程序支持哪些标签，请查看相应的手册或文档</strong></p><p>这里有一个简单的例子，展示了如何在Markdown中混合使用HTML和Markdown语法：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">这是一个普通段落。<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span></span>这段文字将显示为红色。<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><br><span class="hljs-emphasis">*这是Markdown格式的斜体*</span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br>这是一个HTML块级元素。<br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="hljs-strong">**这是Markdown格式的粗体**</span><br></code></pre></td></tr></table></figure><p>以上Markdown代码将产生以下效果：</p><p>这是一个普通段落</p><p><span style="color: red;">这段文字将显示为红色。</span></p><p><em>这是Markdown格式的斜体</em></p><div> 这是一个HTML块级元素。 </div><p><strong>这是Markdown格式的粗体</strong></p><hr><h3 id="任务列表">任务列表</h3><p>任务列表使您可以创建带有<strong>复选框</strong>的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号<code>-</code>和方括号<code>[ ]</code>，并在<code>[ ]</code>前面加上空格。要选择一个复选框，请在方括号<code>[x]</code>之间添加 x</p><figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">- [x] Write the press release<br>- [ ] Update the website<br>- [ ] Contact the media<br></code></pre></td></tr></table></figure><p><img src="https://img2.imgtp.com/2024/04/04/7kFSR5OI.png" alt="image-20240323144532355"></p><ul><li>[x] Write the press release</li><li>[ ] Update the website</li><li>[ ] Contact the media</li></ul><hr><h3 id="Emoji-表情">Emoji 表情</h3><p>有两种方法可以将表情符号添加到Markdown文件中：将表情符号复制并粘贴到Markdown格式的文本中，或者键入<em>emoji shortcodes</em>。</p><h4 id="复制和粘贴表情符号">复制和粘贴表情符号</h4><p>在大多数情况下，您可以简单地从<a href="https://emojipedia.org/">Emojipedia</a> 等来源复制表情符号并将其粘贴到文档中。许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序导出的HTML和PDF文件应显示表情符号</p><p><strong>Tip:</strong> 如果您使用的是静态网站生成器，请确保将HTML页面编码为UTF-8</p><h4 id="使用表情符号简码">使用表情符号简码</h4><p>一些Markdown应用程序允许您通过键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">多一眼看一眼就会:boom:<br>真好笑！ :joy:<br></code></pre></td></tr></table></figure><p><img src="https://img2.imgtp.com/2024/04/04/Z7UFAt5A.png" alt="image-20240323144459538"></p><p><strong>Note:</strong> 注意：您可以使用此<a href="https://gist.github.com/rxaviers/7360908">表情符号简码列表</a>，但请记住，表情符号简码因应用程序而异。有关更多信息，请参阅Markdown应用程序的文档</p><hr><h3 id="LaTex-数学公式">LaTex 数学公式</h3><p><a href="https://mohu.org/info/symbols/symbols.htm">参考文章</a></p><p>行内使用$$包围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>10</mn></msub><mn>100</mn></mrow><annotation encoding="application/x-tex">a = \log_{10}100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span></span></span></span></p><p>行间使用$$$$包围，也可以行内使用</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo>=</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>10</mn></msub><mn>100</mn></mrow><annotation encoding="application/x-tex">a = \log_{10}100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span></span></span></span></span></p><ul><li>分数: \frac {a} {b} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>根号: \sqrt[3]{x^4} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mroot><msup><mi>x</mi><mn>4</mn></msup><mn>3</mn></mroot></mrow><annotation encoding="application/x-tex">\sqrt[3]{x^4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.0849em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-3.0221em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9551em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span><span style="top:-2.9151em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.0849em;"><span></span></span></span></span></span></span></span></span></li><li>点乘: a \cdot b <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⋅</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \cdot b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>​</li><li>叉乘: a \times b <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \times b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></li><li>上标: a^2 b^{1+2} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">a^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mrow><mn>1</mn><mo>+</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">b^{1+2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> <strong>如果上标是表达式,则加{},下同</strong></li><li>下标: a_i <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">a_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>+</mo><mn>3</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{1+3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></li><li>积分: <strong>\int_{a}^{b}</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup></mrow><annotation encoding="application/x-tex">\int_{a}^{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3998em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span></span></span></span></li><li>正弦: \sin{} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\sin{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span></span></span></li><li>余弦: \cos{} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>cos</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\cos{(y+x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></li><li>对数: <strong>\log_{6}</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>6</mn></msub><mn>10</mn></mrow><annotation encoding="application/x-tex">\log_{6}10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span></span></span></span>​</li><li>大于号：(\textgreater) \textgreater</li><li>小于号：(\textless)</li><li>大于等于：(\geq) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span></li><li>小于等于：(\leq) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span>​</li></ul><h3 id="github风格警告框">github风格警告框</h3><img src="https://img2.imgtp.com/2024/04/14/519OjPJs.png" alt="image-20240414094352692" style="zoom:50%;" /><blockquote><p>[!NOTE]</p><p>提醒 <code>&gt; [!note]</code> 该风格警告框适用于github，其他网站不保证兼容性</p></blockquote><blockquote><p>[!TIP]</p><p>建议 <code>&gt; [!tip]</code></p></blockquote><blockquote><p>[!IMPORTANT]</p><p>重要 <code>[!important]</code></p></blockquote><blockquote><p>[!WARNING]</p><p>警告 <code>[!warning]</code></p></blockquote><blockquote><p>[!CAUTION]</p><p>注意 <code>[!caution]</code></p></blockquote><h3 id="IFrame标签">IFrame标签</h3><iframe src="https://baidu.com" width="200" height="500" scrolling="no"/><audio controls style="width: 800px;padding: 10px;margin: 20px auto;">    <source src="https://i-120.wwentua.com:446/04262200175320781bb/2024/04/16/090933971d80726c897bc21383fe7ace.mp3?st=DWYBqzF1MlCePRFfzBIRoQ&e=1714142574&b=VUsMQwhbA0NZXgR_aB7AGswXjC7FR5FT3Cb0Mj1TXU7RVvwmBV3lVPVl8BWA_c&fi=175320781&pid=223-167-164-3&up=2&mp=0&co=0" type="audio/mpeg">    您的浏览器不支持 audio 元素。</audio><h2 id="typora">typora</h2><h3 id="自定义主题"><a href="https://theme.typora.io/doc/zh/Write-Custom-Theme/">自定义主题</a></h3><blockquote><p>在通用设置中打开调试模式</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/jnRNJQXi.png" alt="image-20240323133251040"></p><p>示例：假设我想修改<strong>引用前面竖杠</strong>的颜色</p><p><img src="https://s2.loli.net/2024/03/23/AgUN2Ve7P1dCaXz.gif" alt="recording"></p><p>步骤大概如下：</p><ol><li>右键检查元素</li><li>使用左上角的选择器选择引用框</li><li>在右边样式中找到<code>boder-left</code>样式,修改颜色直到满意为止</li></ol><p><strong>这样修改只是暂时的，如果想要永久生效就要找到对应主题的css文件,找到刚才的属性修改好保存并重启typora(或切换2次主题重新加载当前主题)</strong></p><ul><li>样式中信息说明这个属性在<code>maize.css</code>文件第<code>188</code>行</li></ul><p><img src="https://img2.imgtp.com/2024/04/04/4UwdspQr.png" alt="image-20240323134839413"></p><ul><li><p>先复制修改好的颜色属性，找到<code>maize.css</code>(这是我使用的主题文件,不同主题是不一样的)</p><p><img src="https://img2.imgtp.com/2024/04/04/d2MqWoFJ.png" alt="image-20240323135320144"></p></li><li><p>修改对应属性并保存</p></li><li><p>重启typora</p></li></ul><blockquote><p>你也可以直接将修改好css属性直接粘贴到主题css文件的最后进行覆盖，这样就不用找对应的css在哪了</p><p><span style="color:#ff6b6b;font-weight:bold;">最推荐的办法是在主题文件夹下创建一个文件名为 你使用的主题.user.css文件(例如我使用的是maize,则为maize.user.css)，将要修改的属性直接加入这个文件即可</span></p><p><strong>这种办法适用于typora中大多数样式</strong></p></blockquote><hr><h3 id="图床">图床</h3><blockquote><p>markdown中插入的图片会放到一个文件夹下，如果要将文档发给其他人查看，必须将图片全部一起发过去，并且md文件和图片文件夹要放在一起，路径对不上的话所有图片都会加载不出来，非常的麻烦，一般md中插入图片使用图片的url地址，只要有网就能加载</p></blockquote><p>可以使用一些免费图床(<a href="https://www.imgtp.com/">ImgTP</a>,<a href="https://sm.ms/">SM.MS</a>),或者使用<code>github/gitee</code>搭建免费图床(<strong>不推荐</strong>),最好是使用付费图床(稳定)，可自行上网搜索怎么使用</p><p><img src="https://img2.imgtp.com/2024/04/04/ridGMJBj.png" alt="image-20240323140334497"></p><h3 id="自定义快捷键">自定义快捷键</h3><p>打开高级设置</p><p><img src="https://img2.imgtp.com/2024/04/04/yPFwQOv7.png" alt="image-20240323140954338"></p><p>打开<code>conf.user.json</code>文件，添加快捷键，快捷键名称必须是在菜单栏中存在的，这是我设置的一些快捷键</p><p><img src="https://s2.loli.net/2024/04/01/dkI7sJr6v1nXw3j.png" alt="image-20240323141230241"></p><hr>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pinia-vue存储库</title>
      <link href="/2024/02/20/pinia-vue%E5%AD%98%E5%82%A8%E5%BA%93/"/>
      <url>/2024/02/20/pinia-vue%E5%AD%98%E5%82%A8%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Pinia"><a href="https://pinia.web3doc.top/">Pinia</a></h2><blockquote><p>[!note]</p><p>Pinia是什么？</p><p>Pinia 是 ==Vue 的存储库==，它允许您跨组件/页面共享状态</p><p>vue项目中有很多页面view，这些view之间相互独立，登录页面会拿到后端传回的token，但是其他页面并没有token，可以将token保存在<code>pinia</code>，其他页面都可以访问pinia(相当于全局变量)，另外pinia基于内存存储，刷新浏览器数据就会丢失，使用<code>persist</code>插件可以将数据==持久化==</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/Lg05BHGR.png" alt=""></p><h2 id="1-安装">1.安装</h2><p>用你最喜欢的包管理器安装 <code>pinia</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">yarn add pinia<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者使用 npm</span><br>npm install pinia<br></code></pre></td></tr></table></figure><p>安装pinia持久化插件<code>persist</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">yarn add pinia-persistedstate-plugin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者使用 npm</span><br>npm install pinia-persistedstate-plugin<br></code></pre></td></tr></table></figure><h2 id="2-使用">2.使用</h2><p>2.1 在<code>main.js</code>中导入pinia和persist并使用</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createApp&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-keyword">import</span> &#123;createPinia&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;createPersistedState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia-persistedstate-plugin&quot;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br><span class="hljs-comment">// 使用pinia和persist保存状态并持久化</span><br><span class="hljs-keyword">const</span> pinia = <span class="hljs-title function_">createPinia</span>();<br><span class="hljs-keyword">const</span> persist = <span class="hljs-title function_">createPersistedState</span>();<br>pinia.<span class="hljs-title function_">use</span>(persist);<br><br><span class="hljs-comment">// 使用pinia</span><br>app.<span class="hljs-title function_">use</span>(pinia);<br><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>2.2 以保存token为例，创建<code>token.js</code>文件</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useTokenStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;token&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">//1.定义描述token</span><br>        <span class="hljs-keyword">const</span> token = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-comment">//2.定义修改token的方法</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">setToken</span> = (<span class="hljs-params">newToken</span>) =&gt; &#123;<br>            token.<span class="hljs-property">value</span> = newToken<br>        &#125;<br>        <span class="hljs-comment">//3.定义移除token的方法</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">removeToken</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>            token.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<br>            token, setToken, removeToken<br>        &#125;<br>    &#125;,<br>    &#123;<br>        <span class="hljs-comment">//使用persis插件持久化</span><br>        <span class="hljs-attr">persis</span>: <span class="hljs-literal">true</span><br>    &#125;<br>)<br></code></pre></td></tr></table></figure><p>2.3 在其他页面读取token</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useTokenStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/stores/token&quot;</span>;<br><br><span class="hljs-keyword">const</span> tokenStore = <span class="hljs-title function_">useTokenStore</span>();<br><br><span class="hljs-comment">// 设置token</span><br>tokenStore.<span class="hljs-title function_">setToken</span>(<span class="hljs-string">&#x27;your token&#x27;</span>);<br><span class="hljs-comment">// 获取token</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;tokenStore:&quot;</span> + tokenStore.<span class="hljs-property">token</span>);<br><span class="hljs-comment">// 清除token</span><br>tokenStore.<span class="hljs-title function_">removeToken</span>();<br></code></pre></td></tr></table></figure><h2 id="3-其他示例">3.其他示例</h2><p><code>reader.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保存登录时用户的信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useReaderStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;reader&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> reader = <span class="hljs-title function_">ref</span>(&#123;<br>            <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">nickname</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">tel</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;);<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">setReader</span> = (<span class="hljs-params">data</span>) =&gt; &#123;<br>            reader.<span class="hljs-property">value</span> = data;<br>        &#125;<br>        <span class="hljs-comment">//清除信息</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">clearReader</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>            reader.<span class="hljs-property">value</span>.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>            reader.<span class="hljs-property">value</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>            reader.<span class="hljs-property">value</span>.<span class="hljs-property">nickname</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>            reader.<span class="hljs-property">value</span>.<span class="hljs-property">gender</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>            reader.<span class="hljs-property">value</span>.<span class="hljs-property">age</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>            reader.<span class="hljs-property">value</span>.<span class="hljs-property">tel</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>            reader.<span class="hljs-property">value</span>.<span class="hljs-property">token</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<br>            reader, setReader, clearReader<br>        &#125;<br>    &#125;,<br>    <span class="hljs-comment">// 持久化，pinia保存在内存中，刷新即丢失</span><br>    &#123;<br>        <span class="hljs-attr">persis</span>: <span class="hljs-literal">true</span><br>    &#125;<br>)<br></code></pre></td></tr></table></figure><p><code>admin.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保存登录时的管理员信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useAdminStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> admin = <span class="hljs-title function_">ref</span>(&#123;<br>            <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">nickname</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">token</span>:<span class="hljs-string">&#x27;&#x27;</span><br>        &#125;);<br>        <span class="hljs-comment">// 是否为管理员</span><br>        <span class="hljs-keyword">let</span> isAdmin = <span class="hljs-title function_">ref</span>();<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">setIsAdmin</span> = (<span class="hljs-params">flag</span>)=&gt;&#123;<br>            isAdmin.<span class="hljs-property">value</span> = flag;<br>        &#125;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">setAdmin</span> = (<span class="hljs-params">data</span>) =&gt; &#123;<br>            admin.<span class="hljs-property">value</span> = data;<br>        &#125;<br>        <span class="hljs-comment">//清除信息</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">clearAdmin</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>            admin.<span class="hljs-property">value</span>.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>            admin.<span class="hljs-property">value</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>            admin.<span class="hljs-property">value</span>.<span class="hljs-property">nickname</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>            admin.<span class="hljs-property">value</span>.<span class="hljs-property">token</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> &#123;<br>            admin, setAdmin,isAdmin,setIsAdmin,clearAdmin<br>        &#125;<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">persis</span>: <span class="hljs-literal">true</span><br>    &#125;<br>)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pinia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis二次校验实现jwt主动“失效”</title>
      <link href="/2024/02/19/redis%E4%BA%8C%E6%AC%A1%E6%A0%A1%E9%AA%8C%E5%AE%9E%E7%8E%B0jwt%E2%80%9C%E5%A4%B1%E6%95%88%E2%80%9D/"/>
      <url>/2024/02/19/redis%E4%BA%8C%E6%AC%A1%E6%A0%A1%E9%AA%8C%E5%AE%9E%E7%8E%B0jwt%E2%80%9C%E5%A4%B1%E6%95%88%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>问题：jwt令牌一旦生成，就不能再更改，有时候想让令牌提前失效该怎么办？</p><p>解决方案：使用redis对token进行二次校验，由redis来管理token的过期时间</p></blockquote><h2 id="1-保存token到redis">1.保存token到redis</h2><p>在用户登录方法中，生成token，并保存一份到redis中</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result&lt;ReaderVo&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(LoginDto reader)</span> &#123;<br>    <span class="hljs-type">Reader</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> readerMapper.selectByName(reader.getUsername());<br>    <span class="hljs-comment">//用户不存在</span><br>    <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.error(Excep.USER_NOT_EXIST);<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> r.getPassword();<br>    <span class="hljs-comment">//密码错误</span><br>    <span class="hljs-keyword">if</span> (!pwd.equals(reader.getPassword())) &#123;<br>        <span class="hljs-keyword">return</span> Result.error(Excep.WRONG_PASSWORD);<br>    &#125;<br><br>    <span class="hljs-comment">//生成令牌,在有效载荷中存储用户名和id</span><br>    Map&lt;String, Object&gt; claims = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    claims.put(Common.ID, r.getId());<br>    claims.put(Common.USERNAME, reader.getUsername());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> JwtUtils.generateJwt(claims);<br><br>    <span class="hljs-comment">// 将令牌保存到redis中</span><br>    redisTemplate.opsForValue().set(token, token, Jwt.EXPIRE_TIME);<br><br>    <span class="hljs-comment">// 封装信息并返回</span><br>    <span class="hljs-type">ReaderVo</span> <span class="hljs-variable">readerVo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReaderVo</span>();<br>    readerVo.setToken(token);<br>    BeanUtils.copyProperties(r, readerVo);<br><br>    <span class="hljs-keyword">return</span> Result.success(readerVo);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-二次校验token">2.二次校验token</h2><p>在jwt拦截器中，校验redis中是否存在token，如果不存在，说明token已经过期</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;<br>    <span class="hljs-comment">// 静态资源直接放行</span><br>    <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> HandlerMethod)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//token为空,不放行</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(Common.TOKEN);<br>    log.debug(<span class="hljs-string">&quot;token:&#123;&#125;&quot;</span>, token);<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasLength(token)) &#123;<br>        log.error(Excep.TOKEN_NOT_EXIST);<br>        response.setStatus(Code.NOT_LOGIN_CODE);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 校验redis中的令牌是否过期</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">redisToken</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(token);<br>        <span class="hljs-keyword">if</span> (redisToken == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseException</span>(Excep.TOKEN_ALREADY_EXPIRED);<br>        &#125;<br>        <span class="hljs-comment">//解析</span><br>        <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> JwtUtils.parseJWT(token);<br>        <span class="hljs-comment">// 保存用户信息</span><br>        ThreadLocalUtil.set(claims);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(claims.getExpiration());<br>        log.debug(<span class="hljs-string">&quot;id:&#123;&#125;,username:&#123;&#125;,令牌到期时间:&#123;&#125;&quot;</span>, claims.get(Common.ID), claims.get(Common.USERNAME), format);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">//解析失败不放行</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> e.getMessage();<br>        log.error(<span class="hljs-string">&quot;非法令牌 &quot;</span> + message);<br>        <span class="hljs-keyword">if</span> (message.contains(<span class="hljs-string">&quot;expire&quot;</span>)) &#123;<br>            log.error(<span class="hljs-string">&quot;令牌过期!&quot;</span>);<br>        &#125;<br>        response.setStatus(Code.IDENTITY_EXPIRES);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-创建删除token接口">3.创建删除token接口</h2><p>创建一个logout退出登录接口，前端退出登录时调用此接口，将token从redis中删除</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DeleteMapping(&quot;/logout&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">logout</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(Common.TOKEN)</span> String token)</span> &#123;<br>    log.debug(<span class="hljs-string">&quot;token:&#123;&#125;&quot;</span>, token);<br><br>    redisTemplate.delete(token);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-前端调用">4.前端调用</h2><h3 id="4-1-定义登出接口，调用后端">4.1 定义登出接口，调用后端</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/util/request.js&quot;</span>;<br><span class="hljs-comment">// 用户退出登录</span><br><span class="hljs-keyword">const</span> logoutService = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 调用后端接口清除redis中的令牌</span><br>    <span class="hljs-keyword">return</span> request.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;/logout&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123;logoutService&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-登出功能中调用上面接口">4.2 登出功能中调用上面接口</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">logout</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">logoutService</span>();<br>  <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">&quot;已退出登录!&quot;</span>)<br>  <span class="hljs-comment">// 退出后清除token、reader和admin信息</span><br>  tokenStore.<span class="hljs-title function_">setToken</span>(<span class="hljs-literal">null</span>);<br>  readerStore.<span class="hljs-title function_">clearReader</span>();<br>  adminStore.<span class="hljs-title function_">clearAdmin</span>();<br>  <span class="hljs-keyword">await</span> router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;/login&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-联调测试">5.联调测试</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios不入门直接起飞</title>
      <link href="/2024/02/19/Axios/"/>
      <url>/2024/02/19/Axios/</url>
      
        <content type="html"><![CDATA[<h2 id="Axios"><a href="https://www.axios-http.cn/">Axios</a></h2><blockquote><p>Axios是什么？</p><p>Axios 是一个基于 <em><a href="https://javascript.info/promise-basics">promise</a></em> 网络请求库，作用于<a href="https://nodejs.org/">node.js</a> 和浏览器中。 它是 <em><a href="https://www.lullabot.com/articles/what-is-an-isomorphic-application">isomorphic</a></em> 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js <code>http</code> 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests</p></blockquote><h2 id="1-安装">1.安装</h2><p>使用npm安装：</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install axios<br></code></pre></td></tr></table></figure><p>使用yarn安装：</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn add axios<br></code></pre></td></tr></table></figure><h2 id="2-包装统一请求工具">2.包装统一请求工具</h2><p>因为后端地址是一样的，假设是localhost:8080，只是请求路径不一样，我们可以定义一个baseURL，此处使用<code>/api</code>是为了解决<strong>跨域问题</strong></p><p>1.先包装一个工具<code>request.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><br><span class="hljs-keyword">const</span> baseURL = <span class="hljs-string">&quot;/api&quot;</span>;<br><span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;baseURL&#125;);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> instance;<br></code></pre></td></tr></table></figure><p>2.在<code>vite.config.js</code>文件中添加配置，将<code>/api</code>删除，替换为<code>http://localhost:8080</code>,这样就相当于使用前端服务发送请求而不是浏览器，解决了跨域请求问题</p><p><img src="https://img2.imgtp.com/2024/04/04/bfhkucvh.png" alt="image-20240220005351559"></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-title function_">vue</span>(),<br>        <span class="hljs-title class_">AutoImport</span>(&#123;<br>            <span class="hljs-attr">resolvers</span>: [<span class="hljs-title class_">ElementPlusResolver</span>()],<br>        &#125;),<br>        <span class="hljs-title class_">Components</span>(&#123;<br>            <span class="hljs-attr">resolvers</span>: [<span class="hljs-title class_">ElementPlusResolver</span>()],<br>        &#125;),<br>    ],<br>    <span class="hljs-attr">resolve</span>: &#123;<br>        <span class="hljs-attr">alias</span>: &#123;<br>            <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;./src&#x27;</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>))<br>        &#125;<br>    &#125;,<br>    <span class="hljs-comment">//代理http请求，解决跨域问题</span><br>    <span class="hljs-attr">server</span>: &#123;<br>        <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>        <span class="hljs-attr">port</span>: <span class="hljs-number">5173</span>,<br>        <span class="hljs-attr">proxy</span>: &#123;<br>            <span class="hljs-string">&#x27;/api&#x27;</span>: &#123; <span class="hljs-comment">//匹配请求路径中含有 /api 的请求</span><br>                <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8080&#x27;</span>, <span class="hljs-comment">//后端服务地址</span><br>                <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">//去除路径中的/api，还原请求路径</span><br>            &#125;<br>        &#125;<br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="3-拦截器">3.拦截器</h2><p>这是axios发送请求的一个示例，项目中会有很多这样的请求要发送，我们会发现发送请求和接收响应数据之前，我们都会做一些相同的事情，比如，<strong>发送请求之前我们都会给请求头中带上token</strong>，<strong>接收响应时我们都会先判断状态码</strong>，我们不妨将这些动作用一个统一的函数来实现，这就需要使用拦截器</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, &#123;<br>    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Fred&#x27;</span>,<br>    <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Flintstone&#x27;</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>这是一个响应拦截器的示例，axios会自动适配响应的http<strong>状态码为4xx或5xx的请求为失败回调</strong>，在失败回调中我们可以<strong>对各种状态码的失败回调统一处理</strong>，成功回调中如果自定义的code为0也表示有错误，这种统一处理的方式类似于Spring中的<code>AOP</code></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//响应拦截器，状态码为2xx时执行成功回调，否则执行失败回调</span><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-comment">//成功回调</span><br>    <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 如果状态码为0，后端发生异常</span><br>        <span class="hljs-keyword">if</span> (result.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> = <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(result.<span class="hljs-property">data</span>.<span class="hljs-property">msg</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(result);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.<span class="hljs-property">data</span>;<br>    &#125;,<br>    <span class="hljs-comment">//失败回调</span><br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 状态码为401,419都跳转到登录界面</span><br>        <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>) &#123;<br>            <span class="hljs-keyword">const</span> code = error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>;<br>            <span class="hljs-keyword">if</span> (code = <span class="hljs-number">401</span>) &#123;<br>                <span class="hljs-title class_">ElMessage</span>(&#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请先登录！&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;error&quot;</span>,&#125;);<br>                router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (code = <span class="hljs-number">419</span>) &#123;<br>                <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;身份已过期,请重新登录！&quot;</span>);<br>                router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;服务器异常！&quot;</span> + code);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将异步的状态设置为失败状态</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>    &#125;<br>);<br></code></pre></td></tr></table></figure><p>这是一个请求拦截器的示例，在发送请求之前先判断是否有token，如果有就在请求头上带上token再发送请求，否则跳转到登录页面，当然，<strong>登录和注册请求都不需要token</strong>，可以直接发送请求</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 请求拦截器</span><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//登录请求不需要token</span><br>        <span class="hljs-keyword">if</span> (config.<span class="hljs-property">url</span>.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;/login&#x27;</span>) || config.<span class="hljs-property">url</span>.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;/register&#x27;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> config;<br>        &#125;<br>        <span class="hljs-comment">//如果有token，将token放入请求头中</span><br>        <span class="hljs-keyword">const</span> token = tokenStore.<span class="hljs-property">token</span>;<br>        <span class="hljs-keyword">if</span> (token != <span class="hljs-literal">null</span>) &#123;<br>            config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;token&#x27;</span>] = token;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>            <span class="hljs-title class_">ElMessage</span>(&#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请先登录！&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;error&quot;</span>,&#125;);<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;token不存在！&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> config;<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//请求错误的回调</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err);<br>    &#125;<br>);<br></code></pre></td></tr></table></figure><h2 id="4-完整axios包装工具示例">4.完整axios包装工具示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">ElMessage</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-plus&quot;</span>;<br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/router&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;useTokenStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/stores/token.js&quot;</span>;<br><br><span class="hljs-keyword">const</span> baseURL = <span class="hljs-string">&quot;/api&quot;</span>;<br><span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;baseURL&#125;);<br><span class="hljs-keyword">const</span> tokenStore = <span class="hljs-title function_">useTokenStore</span>();<br><br><br><span class="hljs-comment">//响应拦截器，状态码为2xx时执行成功回调，否则执行失败回调</span><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-comment">//成功回调</span><br>    <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 如果状态码为0，后端发生异常</span><br>        <span class="hljs-keyword">if</span> (result.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> = <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(result.<span class="hljs-property">data</span>.<span class="hljs-property">msg</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(result);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.<span class="hljs-property">data</span>;<br>    &#125;,<br>    <span class="hljs-comment">//失败回调</span><br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 状态码为401,419都跳转到登录界面</span><br>        <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>) &#123;<br>            <span class="hljs-keyword">const</span> code = error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>;<br>            <span class="hljs-keyword">if</span> (code = <span class="hljs-number">401</span>) &#123;<br>                <span class="hljs-title class_">ElMessage</span>(&#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请先登录！&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;error&quot;</span>,&#125;);<br>                router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (code = <span class="hljs-number">419</span>) &#123;<br>                <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;身份已过期,请重新登录！&quot;</span>);<br>                router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;服务器异常！&quot;</span> + code);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将异步的状态设置为失败状态</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>    &#125;<br>);<br><br><span class="hljs-comment">// 请求拦截器</span><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//登录请求不需要token</span><br>        <span class="hljs-keyword">if</span> (config.<span class="hljs-property">url</span>.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;/login&#x27;</span>) || config.<span class="hljs-property">url</span>.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;/register&#x27;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> config;<br>        &#125;<br>        <span class="hljs-comment">//如果有token，将token放入请求头中</span><br>        <span class="hljs-keyword">const</span> token = tokenStore.<span class="hljs-property">token</span>;<br>        <span class="hljs-keyword">if</span> (token != <span class="hljs-literal">null</span>) &#123;<br>            config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;token&#x27;</span>] = token;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>            <span class="hljs-title class_">ElMessage</span>(&#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请先登录！&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;error&quot;</span>,&#125;);<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;token不存在！&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> config;<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//请求错误的回调</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err);<br>    &#125;<br>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> instance;<br></code></pre></td></tr></table></figure><p>在其他接口文件中导入使用，因为使用的是<code>export default instance</code>默认导出的，所以导入时可以自定义名字，这个文件中定义为<code>request</code>,其实就是<code>instance</code>实例</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/util/request.js&quot;</span>;<br><span class="hljs-comment">// 用户退出登录</span><br><span class="hljs-keyword">const</span> logoutService = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 调用后端接口清除redis中的令牌</span><br>    <span class="hljs-keyword">return</span> request.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;/logout&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123;logoutService&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>everything极速搜索</title>
      <link href="/2024/02/18/Everything%E6%90%9C%E7%B4%A2%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2024/02/18/Everything%E6%90%9C%E7%B4%A2%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1>everything</h1><h2 id="1-指定文件后缀">1.指定文件后缀</h2><p>搜索文件名，并且==要求后缀==，假设要搜索 名称包含<code>main</code>的所有<code>java</code>文件,可以搜索</p><blockquote><p>[!note]</p><p><code>main ext:java </code></p><p>ext:java 就是指定后缀名，这个条件和main条件顺序随意，==注意中间要有一个空格==</p></blockquote><h2 id="2-指定文件路径">2.指定文件路径</h2><p>搜索文件，并且要求==该文件包含指定路径==，假设要搜索<code>base.css</code>文件，并且该文件路径中包含<code>typora</code></p><blockquote><p>[!note]</p><p><code>base.css path:typora</code></p><p>使用<code>path</code>指定文件包含的路径</p></blockquote><h2 id="3-指定文件夹">3.指定文件夹</h2><p>在<strong>指定文件夹</strong>下搜索文件，假设要在文件夹下<code>&quot;D:\QQ\&quot;</code>文件夹下搜索文件<code>qq.exe</code></p><blockquote><p><code>&quot;D:\QQ\&quot; qq.exe</code></p><p>前面写文件夹路径，后面接文件名，中间有空格</p></blockquote><h2 id="4-文本内容">4.文本内容</h2><p>假如搜索到的文件有很多个，我只想要文件中<strong>内容包含123</strong>的怎么查询?</p><blockquote><p>使用<code>content</code>指定文件中包含的内容</p><p><code>1.txt content:123</code></p></blockquote><p>更多用法见<a href="https://www.voidtools.com/zh-cn/">voidtools</a></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> everything </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot相关配置</title>
      <link href="/2024/01/07/springboot%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/01/07/springboot%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1>springboot相关配置</h1><h2 id="1-自定义项目LOGO">1.<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.banner">自定义项目LOGO</a></h2><p>在<code>resources</code>文件夹下新建一个<code>banner.txt</code>文件，加入相关内容即可，<a href="https://www.bootschool.net/ascii-art">艺术字生成网站</a></p><figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">---------------+---------------<br>          ___ /^^[___              _<br>         /|^+----+   |#___________//<br>       ( -+ |____|    ______-----+/<br>        ==_________--&#x27;            \<br>          ~_|___|__<br></code></pre></td></tr></table></figure><h2 id="2-跨域请求">2. 跨域请求</h2><p>添加此配置到<code>WebMvc</code>配置类中(推荐)，也可以在每个<code>Controller</code>类上添加注解<code>@CrossOrigin</code></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-comment">//允许所有跨域请求</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .allowedOriginPatterns(<span class="hljs-string">&quot;*&quot;</span>)<br>                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)<br>                .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>)<br>                .allowCredentials(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-application配置文件">3. application配置文件</h2><p><code>application.yml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">main:</span><br>    <span class="hljs-attr">allow-circular-references:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">devtools:</span><br>    <span class="hljs-attr">restart:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># 设置重启的目录</span><br>      <span class="hljs-attr">additional-paths:</span> <span class="hljs-string">src/main/java</span><br><br><span class="hljs-comment"># mybatis-plus配置</span><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment">#开启下划线自动转驼峰命名</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.clb.pojo</span>  <span class="hljs-comment">#别名扫描</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/*.xml</span>  <span class="hljs-comment">#注册mapper</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">banner:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span><br><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.clb:</span> <span class="hljs-string">debug</span><br>  <span class="hljs-attr">pattern:</span><br>    <span class="hljs-attr">dateformat:</span> <span class="hljs-string">MM-dd</span> <span class="hljs-string">HH:mm:ss.SSS</span><br></code></pre></td></tr></table></figure><p><code>application-dev.yml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">activate:</span><br>      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?rewriteBatchedStatements=true</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>  <span class="hljs-attr">data:</span><br>    <span class="hljs-attr">redis:</span><br>      <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.88</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>      <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1>计算机网络</h1><p><a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.demolab.com?font=Cascadia+Code&weight=900&size=60&duration=2000&pause=1000&center=true&vCenter=true&random=false&width=1000&height=100&lines=Computer+Network+" alt="Typing SVG" /></a></p><h2 id="1-计算机网络概述">1. 计算机网络概述</h2><h3 id="1-1-计网的组成">1.1 计网的组成</h3><h4 id="概念">概念</h4><p>简单定义：<strong>硬件</strong>(独立和连接)+<strong>软件</strong>(协议)+<strong>目的</strong>(共享和通信)</p><blockquote><p><strong>计算机网络就是以传输信息为基本目的,用通信线路和通信设备将多个计算机连接起来的计算机系统的集合</strong></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/06/8bp2LLjc.png" alt="CopyQ.XjcbYs"></p><h4 id="分类">分类</h4><blockquote><p>按网络<strong>覆盖范围</strong>进行分类</p></blockquote><ol><li><strong>局域网</strong>(Local Area Network,<code>LAN</code>,一个实验室、一幢楼、一个校园)</li><li><strong>城域网</strong>(Metropolitan Area Network,<code>MAN</code>,几个街区甚至整个城市,5-50 km)</li><li><strong>广域网</strong>(Wide Area Network,<code>WAN</code>,覆盖一个国家或地区甚至几个洲,也称为<strong>远程网</strong>)</li><li><strong>个人区域网</strong>(Personal Area Network,<code>PAN</code>,10 m以内)</li></ol><blockquote><p>按网络的<strong>使用者</strong>进行分类</p></blockquote><ol><li><strong>公用网</strong>(所有愿意缴纳费用的人都能使用)</li><li><strong>专用网</strong>(专门为本单位的特殊业务工作建造的,例如,军队、铁路、电力等系统)</li></ol><img src="https://img2.imgtp.com/2024/04/04/Nqa5DJOR.png" alt="计算机网络分类" title='计算机网络的分类' /><h4 id="组成">组成</h4><h5 id="组成部分">组成部分</h5><blockquote><p>计算机网络主要由<strong>硬件</strong>、<strong>软件</strong>、<strong>协议</strong>组成</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/06/2ynHlxA5.png" alt="image-20240406104102808"></p><h5 id="工作方式">工作方式</h5><p>从<strong>工作方式</strong>上看,计算机网络可分为：</p><ol><li><strong>边缘部分</strong>：用户直接使用的</li><li><strong>核心部分</strong>：为边缘部分提供服务的</li></ol><img src="https://img2.imgtp.com/2024/04/04/zI8FwGzp.png" title="woc,O" style="zoom: 67%;" /><h5 id="逻辑功能">逻辑功能</h5><p>从逻辑功能上看,计算机网络由通信子网和资源子网组成</p><ul><li><strong>通信子网</strong>：由各种<strong>传输介质</strong>、<strong>通信设备</strong>和相应的<strong>网络协议</strong>组成</li><li><strong>资源子网</strong>：实现资源共享功能的<strong>设备</strong>及其<strong>软件</strong>的集合</li></ul><p><img src="https://img2.imgtp.com/2024/04/04/sT1JdhEz.png" alt="image-20240404154608008"></p><h3 id="1-2-功能">1.2 功能</h3><p><img src="https://img2.imgtp.com/2024/04/06/fIl3XYce.png" alt="image-20240406104955734"></p><h3 id="1-3-互联网">1.3 互联网</h3><h4 id="网络的网络">网络的网络</h4><ol><li>网络</li></ol><blockquote><p><strong>网络</strong>由若干<strong>节点</strong>(Node)和连接这些节点的<strong>链路</strong>(Link)组成</p><p>节点：可以是计算机、集线器、交换机、路由器</p></blockquote><img src="https://img2.imgtp.com/2024/04/04/84kZGy2h.png" title="网络" style="zoom:80%;" /><ol start="2"><li><strong>互连网络</strong>(<code>internet</code>,通用名词,<span style="color:#ff6b6b;font-weight:bold;font-size:20px">注意和 互联网Internet 区分</span>)</li></ol><blockquote><p>将网络用路由器连接起来就成了互连网络,因此互连网络是<strong>网络的网络</strong></p></blockquote><img src="https://img2.imgtp.com/2024/04/04/QuZM13pW.png" title="互连网络就是网络的网络" style="zoom:80%;" /><blockquote><p>总结：<strong>网络把许多计算机连接在一起,而互连网络则把许多网络连接在一起</strong></p></blockquote><ol start="3"><li><strong>互联网</strong>(Internet,也称 因特网)</li></ol><blockquote><p>当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络,<strong>采用TCP/IP协议作为通信规则</strong>,前身是美国的阿帕网<code>ARPANet</code></p></blockquote><h4 id="互联网结构发展">互联网结构发展</h4><ol><li><p>第一阶段：从单个网络<code>ARPANET</code>向互连网络发展</p></li><li><p>第二阶段：逐步建成三级结构的互联网</p></li><li><p>第三阶段：逐渐形成多层次的[^ISP]结构的互联网</p></li></ol><img src="https://img2.imgtp.com/2024/04/04/2jKLXwuK.png" title="ISP结构的互联网" style="zoom: 67%;"/><h3 id="1-4-电路、报文、分组交换">1.4 <a href="https://www.bilibili.com/video/BV19E411D78Q?t=0.0&amp;p=4">电路、报文、分组交换</a></h3><h4 id="电路交换">电路交换</h4><blockquote><p>电路交换是指在通信开始之前,建立一条专用的<strong>物理连接</strong>,然后在通信过程中<strong>一直占用这条连接</strong>,直到通信结束。在这个过程中,数据被分成固定大小的数据包,每个数据包都被分配一个专用的物理通路,<strong>适用于低频次、大量地传输数据</strong></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/6OxFTe0R.png" alt="电路交换"></p><blockquote><p>这种必须经过 1.<strong>建立连接</strong>(分配通信资源) 2.<strong>通信</strong>(一直占用通信资源) 3.<strong>释放连接</strong>(归还通信资源)三个步骤的交换方式称为电路交换</p><p>优点：通信<strong>时延小</strong>、<strong>有序传输</strong>、<strong>没有冲突</strong>、传输<strong>速度快</strong>、<strong>控制简单</strong>等</p><p>缺点：</p><ul><li><strong>建立/释放连接</strong>都需要<strong>额外的时间开销</strong></li><li><strong>线路</strong>被通信双方<span style="color:#ff6b6b;font-weight:bold">独占</span>,<strong>利用率低</strong></li><li><strong>线路分配</strong>的<strong>灵活性差</strong>(某段线路出现错误时只能重新建立连接)</li><li>交换节点<strong>不支持“差错控制”</strong>(无法发现传输过程中的发生的数据错误)</li></ul><p><span style="color:#ff6b6b;font-weight:bold;font-size:18px">总结</span>:计算机之间数据往往是“<strong>突发式</strong>”传输,即往往会<strong>高频次、少量</strong>地传输数据,所以电路交换并不适用于计算机网络</p></blockquote><h4 id="报文交换">报文交换</h4><blockquote><p>我们通常把要发送的整块数据称为一个<strong>报文(Message)</strong>,<strong>用户数据</strong>加上<strong>源地址</strong>和<strong>目的地址</strong>等信息后封装成报文,报文交换采用<strong>存储转发</strong>技术,整个报文传送到相邻结点,全部存储下来后查找<strong>转发表</strong>,转发到下一个结点,直到到达目的地</p></blockquote><img src="https://img2.imgtp.com/2024/04/04/RQWjb8wd.png" alt="image-20240404145149676" style="zoom:80%;" /><blockquote><p>优点：</p><ul><li>通信前<strong>无需建立连接</strong></li><li>数据以“<strong>报文</strong>”为单位被交换节点间“<strong>存储转发</strong>”,通信<strong>线路可以灵活分配</strong></li><li>在通信时间内,两个用户无需独占一整条物理线路。相比于电路交换,<strong>线路利用率高</strong></li><li>交换节点支持“<strong>差错控制</strong>”(通过校验技术)</li></ul><p>缺点：</p><ul><li>报文不定长,<span style="color:#ff6b6b;font-weight:bold;">不方便存储转发管理</span></li><li>长报文的<span style="color:#ff6b6b;font-weight:bold;">存储转发时间开销大、缓存开销大</span></li><li><span style="color:#ff6b6b;font-weight:bold;">长报文容易出错,重传代价高</span>(报文出错且校验技术无法修复时需要重传,报文越长越明显)</li></ul></blockquote><h4 id="分组交换"><strong>分组交换</strong></h4><blockquote><p>分组交换：发送报文之前,<strong>先将报文划分为一个个更小的等长的数据段</strong>,在数据段前面加上<strong>首部</strong>(又称为包头)就构成了<strong>分组</strong>(又称为包),每个分组都带有<strong>目标地址</strong>和<strong>源地址</strong>等信息,然后通过网络传输。在传输过程中,每个数据包都独立传输,<strong>可以通过不同的路径</strong>到达目的地</p></blockquote><img src="https://img2.imgtp.com/2024/04/04/8SrtXoUf.png" alt="分组交换" style="zoom: 80%;" /><blockquote><p>分组交换的优点：</p><ul><li>通信前<strong>无需建立连接</strong></li><li>数据以“<strong>分组</strong>”为单位被交换节点间“<strong>存储转发</strong>”,通信线路可以<strong>灵活分配</strong></li><li>在通信时间内,两个用户<strong>无需独占</strong>一整条物理线路。相比于电路交换,<strong>线路利用率高</strong></li><li>交换节点<strong>支持“差错控制”</strong>(通过校验技术)</li></ul><p>相比于报文交换,分组交换改进了如下问题：</p><ul><li><strong>分组定长,方便存储转发管理</strong></li><li>分组的<strong>存储转发时间开销小、缓存开销小</strong></li><li>分组<strong>不易出错,重传代价低</strong></li></ul><p>分组交换的缺点：</p><ul><li>相比于报文交换,<strong>控制信息占比增加</strong></li><li>相比于电路交换,<strong>依然存在存储转发时延</strong></li><li>报文被拆分为多个分组,传输过程中可能出现<strong>失序、丢失</strong>等问题,<strong>增加处理的复杂度</strong></li></ul></blockquote><p><strong>3种交换方式的对比</strong></p><p><img src="https://img2.imgtp.com/2024/04/04/7G4LaEvx.png" alt="交换方式对比"></p><div style="text-align: center;">    <span style="color:#ff6b6b;font-weight:bold;font-size:25px;">总结：现代计算机网络采用分组交换技术</span></div>### 1.5 计网的主要性能指标<h4 id="1-速率">1. 速率</h4><blockquote><ol><li><p>数据的传输速率,也称为数据率、比特率 1字节(byte)=8比特(bit)</p></li><li><p>单位是 <code>bit/s 或 bps</code> ,比特是数据量的单位,是一个二进制数字(0或1)</p></li><li><p>一般来说,表示<strong>速率</strong>时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">K = 10^{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>,表示<strong>存储容量或文件大小</strong>时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">k = 2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span></p></li></ol></blockquote><img src='https://img2.imgtp.com/2024/04/04/0oBrmEnl.png' alt='速率'><h4 id="2-带宽">2. 带宽</h4><ol><li><p>带宽本来是指某个信号具有的频带宽度,表示通信线路允许通过的信号频带范围,单位为赫兹</p></li><li><p>计算机网络中,带宽表示网络某通道传输能力,即最高数据率,单位为比特每秒(bit/s)</p><img src="https://img2.imgtp.com/2024/04/04/HNs5KlGu.png" alt='带宽'/></li></ol><h4 id="3-吞吐量">3. 吞吐量</h4><blockquote><p>也称为吞吐率,表示单位时间内通过某个网络(或信道、接口)的数据量</p></blockquote><h4 id="4-时延">4. 时延</h4><blockquote><p>时延是指数据从网络的一端传送到另外一端所需要的时间,也称为延迟或迟延</p><p>网络中的时延通常由以下几个不同的部分组成：</p><ol><li><p>发送时延：主机或路由器将整个分组的所有比特发送到通信线路上所需要的时间</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>发送时延</mtext><mo>=</mo><mfrac><mtext>分组长度</mtext><mtext>发送速率</mtext></mfrac></mrow><annotation encoding="application/x-tex">\text{发送时延} = \frac{\text{分组长度}}{\text{发送速率}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">发送时延</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">发送速率</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">分组长度</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li><li><p>传播时延：是电磁波在信道中传播一定距离所花费的时间</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>传播时延</mtext><mo>=</mo><mfrac><mtext>信道长度</mtext><mtext>电磁波在信道上的传播速度</mtext></mfrac></mrow><annotation encoding="application/x-tex">\text{传播时延} = \frac{\text{信道长度}}{\text{电磁波在信道上的传播速度}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">传播时延</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">电磁波在信道上的传播速度</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">信道长度</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li><li><p>处理时延：主机或路由器在收到分组时处理分组花费的时间(一般不方便计算)</p></li></ol></blockquote><img src="https://img2.imgtp.com/2024/04/04/3MPbeO6Z.png" alt='时延'/><p><img src="https://img2.imgtp.com/2024/04/04/ZdVAQDaU.png" alt="时延"></p><h4 id="5-时延带宽积-往返时间-利用率-丢包率">5. 时延带宽积 往返时间 利用率 丢包率</h4><img src="https://img2.imgtp.com/2024/04/04/gJwUU2lk.png" alt="" style="zoom:;" /><h3 id="1-6-计算机网络体系结构">1.6 <strong>计算机网络体系结构</strong></h3><h4 id="1-6-1-网络协议">1.6.1 网络协议</h4><p>网络协议主要由以下三要素组成：</p><ol><li><strong>语法</strong>：数据与控制信息的结构或格式(例如,地址字段多长以及它在分组的什么位置)</li><li><strong>语义</strong>：各个控制信息的具体含义(需要发出何种控制信息、完成何种动作及做出何种响应)</li><li><strong>同步(时序)</strong>：事件实现的顺序和时间的详细说明(数据何时发出以及以什么速率发出)</li></ol><h4 id="1-6-2-分层体系结构">1.6.2 分层体系结构</h4><p><img src="https://img2.imgtp.com/2024/04/04/k6fK6Fth.png" alt="常见的计算机网络分层体系结构"></p><h4 id="1-6-3-原理体系结构">1.6.3 原理体系结构</h4><blockquote><p>我们学习的是具有五层协议的原理体系结构</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/aWnMqDAo.png" alt="原理体系结构"></p><h4 id="1-6-4-实体、协议和服务">1.6.4 实体、协议和服务</h4><blockquote><p><strong>协议是水平的,服务是垂直的</strong></p><ol><li>==实体==：任何可发送或接收信息的硬件或软件进程</li><li>==协议==：<strong>控制两个或多个对等实体之间通信的规则的集合</strong></li><li><strong>下层通过层级接口向上层提供服务,下面的协议对上面的实体是”透明“的</strong></li><li>透明：某个实际存在的事物看起来好像不存在一样</li></ol></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/QxFzryw5.png" alt="实体、协议和服务"></p><p><img src="https://img2.imgtp.com/2024/04/04/ZEjjP9Xe.png" alt="1"></p><h3 id="1-7-相关习题">1.7 相关习题</h3><p><img src="https://img2.imgtp.com/2024/04/04/YMD1YO49.png" alt=""></p><p><img src="https://img2.imgtp.com/2024/04/04/apY4UiGK.png" alt=""></p><h3 id="1-8-思维导图和习题">1.8 思维导图和习题</h3><ol><li><a href="https://www.kdocs.cn/view/l/cqzI95zH7t6v">第1章 概述(思维导图)</a></li><li><a href="https://www.kdocs.cn/view/l/cmCC5Updax17">第1章 概述 习题 (kdocs.cn)</a></li></ol><hr><h2 id="2-物理层">2. 物理层</h2><blockquote><p><strong>任务：怎样在连接各种计算机的传输媒体上传输数据比特流</strong>(使数据链路层感觉不到各种传输媒体之间的差异,只需要使用物理层服务就能传输比特流,不必关心具体怎么实现)</p></blockquote><h3 id="2-1-基本概念">2.1 基本概念</h3><p><img src="https://img2.imgtp.com/2024/04/04/DwZwhVmK.png" alt="物理层的基本概念"></p><h3 id="2-2-数据通信的基础知识">2.2 数据通信的基础知识</h3><h4 id="通信系统模型">通信系统模型</h4><p><img src="https://img2.imgtp.com/2024/04/04/RxOxpZHA.png" alt=""></p><h4 id="编码与调制">编码与调制</h4><ol><li><p>定义</p><ul><li><p>模拟信号：消息的参数的取值是连续的</p></li><li><p>数字信号：消息的参数的取值是离散的</p></li><li><p>编码：将<strong>数字数据转换成数字信号</strong>的过程</p></li><li><p>调制：将<strong>数字数据转换成模拟信号</strong>的过程</p></li></ul></li></ol><p><img src="https://img2.imgtp.com/2024/04/04/ACtS6JxY.png" alt="编码与调制"></p><ol start="2"><li><strong>常用编码方式</strong></li></ol><p><img src="https://img2.imgtp.com/2024/04/04/9MM2Ky5h.png" alt="常用编码方式"></p><ol start="3"><li>基本的调制方法</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/vAkWNODU.png" alt="基本的调制方法"></p><ol start="4"><li><strong>相位调制</strong></li></ol><blockquote><p><strong>8相位调制</strong>表示8种状态,只需要<strong>3个比特</strong>(二进制,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">2^3=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span>)即可,所以<strong>1个码元可以承载3个比特</strong>,<strong>数据传输率 = 3*波特率</strong>,以此类推</p></blockquote><h4 id="信道的极限容量">信道的极限容量</h4><p><img src="https://img2.imgtp.com/2024/04/04/FXFhMUmi.png" alt="信号失真"></p><h5 id="奈式准则"><strong>奈式准则</strong></h5><blockquote><p>也称[<strong>奈奎斯特定理</strong>|<strong>采样定理</strong>],理想低通信道的最高码元传输速率 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">2*W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span> 波特 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><mi>W</mi><mo>∗</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>V</mi></mrow><annotation encoding="application/x-tex">2*W*\log_2{V}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>​</p><p>V：一个码元可以表示的离散电平数目</p><p>W：频率带宽,最低和最高频率之差</p><p>理想低通信道：不考虑噪声</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/lU9RuLRg.png" alt="奈式准则"></p><h5 id="香农公式">香农公式</h5><blockquote><p><strong>香农公式</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mo>=</mo><mi>W</mi><mo>⋅</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mfrac><mi>S</mi><mi>N</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c = W \cdot \log_{2}(1 + \frac{S}{N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p><p>知道信噪比(dB)求S/N,假设信噪比为30dB</p><ol><li><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>30</mn><mo>=</mo><mn>10</mn><mo>⋅</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>10</mn></msub><mo stretchy="false">(</mo><mfrac><mi>S</mi><mi>N</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">30 = 10 \cdot \log_{10}(\frac{S}{N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">30</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p></li><li><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>3</mn><mo>=</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>10</mn></msub><mo stretchy="false">(</mo><mfrac><mi>S</mi><mi>N</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">3 = \log_{10}(\frac{S}{N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p></li><li><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>S</mi><mi>N</mi></mfrac><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">\frac{S}{N} = 10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></p></li></ol></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/x9dHMH8w.png" alt="香农公式"></p><blockquote><ol><li>在信道带宽一定的情况下,根据奈氏准则和香农公式,要想提高信息的传输速率就必须采用多元制(更好的调制方法)和努力提高信道中的信噪比</li><li>自从香农公式发表后,各种新的信号处理和调制方法就不断出现,其目的都是为了尽可能地接近香农公式给出的传输速率极限</li><li>影响信号传输速率的因素：<ul><li><strong>信道带宽</strong></li><li><strong>信噪比</strong></li><li><strong>码元速率(调制速率)</strong></li></ul></li></ol></blockquote><h4 id="传输方式">传输方式</h4><ol><li>并行传输和串行传输</li></ol><blockquote><ul><li>并行传输速度是串行传输的n倍,但是<span style="color:#ff6b6b;font-weight:bold">成本高</span>所以<strong>长距离传输使用串行传输</strong></li><li>远距离传输使用串行传输,<strong>计算机内部使用并行传输</strong></li></ul></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/ObkVayAR.png" alt="并行传输和串行传输"></p><ol start="2"><li>异步传输和同步传输</li></ol><blockquote><p>异步传输字节之间异步,但是要添加开始码和停止码作为引导</p></blockquote><img src="https://img2.imgtp.com/2024/04/04/60wDHc1z.png" alt="异步传输和同步传输"  /><ol start="3"><li>单工、半双工和全双工通信</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/SnlGXRdp.png" alt="单工、半双工和全双工通信"></p><h3 id="2-3-物理层传输介质">2.3 物理层传输介质</h3><h4 id="导引型介质">导引型介质</h4><ol><li><strong>同轴电缆</strong></li></ol><p><img src="https://img2.imgtp.com/2024/04/04/UAaTjOr4.png" alt="同轴电缆"></p><ol start="2"><li><strong>双绞线</strong></li></ol><p><img src="https://img2.imgtp.com/2024/04/04/CGI4fSr6.png" alt="双绞线"></p><ol start="3"><li><strong>光纤</strong></li></ol><ul><li>多模光纤：利用光的<strong>全反射特性</strong>,光源使用<strong>发光二极管</strong>,适合<strong>近距离传输</strong></li><li>单模光纤：光纤直径减小到只有光的一个波长,可使光线<strong>直线传播</strong>,光源使用<strong>半导体激光器</strong>,适合<strong>远距离传输</strong>,但是<span style="color:#ff6b6b;font-weight:bold">成本较高</span></li></ul><p><img src="https://img2.imgtp.com/2024/04/04/VE3yDe2c.png" alt="光纤"></p><h4 id="非导引型介质">非导引型介质</h4><ol><li><strong>微波</strong>:有很强的<strong>方向性</strong></li></ol><p><img src="https://img2.imgtp.com/2024/04/04/CkEx8Sjz.png" alt="微波"></p><ol start="2"><li><strong>无线电波</strong>:有较强的穿透能力,可以传输很长距离,<strong>信号向所有方向传播</strong>,广泛用于通信领域(<code>WLAN</code>)</li><li>红外线和可见光</li></ol><h4 id="物理层接口的特性"><strong>物理层接口的特性</strong></h4><ol><li>机械特性：指名接口所用接线器的<strong>形状</strong>和<strong>尺寸</strong>、<strong>引脚数目</strong>和<strong>排列</strong>、<strong>固定</strong>和<strong>锁定装置</strong>等</li><li>电气特性：指名在接口电缆的各条线上的<strong>电压范围</strong>、<strong>传输速率</strong>和<strong>距离限制</strong>等</li><li>功能特性：指名某条线上出现某一电平的<strong>电压的意义</strong>,以及<strong>每条线的功能</strong></li><li>过程特性：也称规程特性,指名对不同功能的各种可能事件的<strong>出现顺序</strong></li></ol><hr><h3 id="2-5-物理层设备">2.5 物理层设备</h3><h4 id="中继器"><strong>中继器</strong></h4><ul><li><p><strong>功能</strong>:对信号进行<strong>再生和还原</strong>,<strong>对衰减的信号进行放大</strong>,保持与原数据相同(<strong>不能检测出信号是否错误</strong>),以增加信号传输的距离,延长网络的长度</p></li><li><p>中继器有<strong>2个端口</strong>,两端是网段而非子网,适用于**完全相同的两类网络(速率、协议等)**的互联</p></li><li><p><code>5-4-3</code>规则：网络标准中都对信号的延迟范围作了具体的规定,因而中继器只能在规定的范围内进行,否则会网络故障,下图中5段链路使用4个中继器连接,最多允许3台主机</p><p><img src="https://img2.imgtp.com/2024/04/04/9JCU8e1K.png" alt="image-20240404212316193"></p></li></ul><h4 id="集线器"><strong>集线器</strong></h4><blockquote><p><strong>集线器相当于多端口中继器</strong></p></blockquote><ul><li><strong>功能</strong>:对信号<strong>再生放大转发</strong></li><li>有<strong>1个输入</strong>端口和<strong>多个输出</strong>端口,<strong>不具备定向转发</strong>信号功能,是一个共享性设备,<strong>不能分割冲突域</strong></li><li>有多台设备共享时,带宽均分给各个设备</li></ul><p><img src="https://img2.imgtp.com/2024/04/04/Ac4qbmev.png" alt="image-20240404213049374"></p><h3 id="2-6-相关习题和资料">2.6 相关习题和资料</h3><ol><li><a href="https://www.kdocs.cn/view/l/cfixYkxNJ7Ep">第2章 物理层 习题</a></li><li><a href="https://www.kdocs.cn/view/l/ckmnMjp5UQvK">第2章 物理层(思维导图)</a></li></ol><hr><h2 id="3-数据链路层">3. 数据链路层</h2><p><img src="https://img2.imgtp.com/2024/04/09/ecaBaiM8.png" alt="image-20240409202339726"></p><blockquote><p><strong>任务：解决数据包在一个网络或一段链路上传输的问题</strong></p><p><strong>功能</strong>：</p><ul><li>为网络层提供服务:1.无确认无连接服务2.有确认无连接服务3.有确认面向连接服务 (面向连接一定有确认!)</li><li>链路管理,即连接的建立、维持、释放(用于面向连接的服务)</li><li><strong>封装成帧</strong></li><li><strong>流量控制</strong>(限制发送方)</li><li><strong>差错控制</strong>(帧错/位错)</li></ul></blockquote><h3 id="3-1-相关概念">3.1 相关概念</h3><blockquote><ul><li>**链路(Link)**网络中两个节点之间的<span style="color:#ff6b6b;font-weight:bold;">物理线路</span>,而中间没有任何其他的交换节点</li><li><strong>数据链路(Data Link)<strong>网络中两个节点之间的<span style="color:#ff6b6b;font-weight:bold;">逻辑线路</span>,把实现</strong>控制数据传输协议的硬件和软件</strong>加到链路上就构成数据链路</li><li>**网络适配器(俗称网卡)**和其相应的软件驱动程序就实现了这些协议,一般的网络适配器都包含了物理层和数据链路层这两层的功能</li><li><strong>帧(Frame)<strong>是</strong>数据链路层的协议数据单元</strong>,封装网络层数据报</li></ul></blockquote><h3 id="3-2-封装成帧和透明传输">3.2 封装成帧和透明传输</h3><h4 id="1-封装成帧">1.封装成帧</h4><blockquote><ol><li><p><strong>封装成帧</strong>(组帧)就是在一段数据的前后部分<strong>添加首部和尾部</strong>,这样就构成了一个<strong>帧</strong>。</p></li><li><p>首部和尾部包含许多的控制信息,他们的一个重要作用：<strong>帧定界</strong>(确定帧的界限)。</p></li><li><p><strong>帧同步</strong>：接收方应当能从接收到的二进制比特流中<strong>区分出帧的起始和终止</strong></p></li><li><p><strong>组帧</strong>的四种方法：</p><ul><li>字符计数法</li><li><strong>字符(节)填充法</strong></li><li><strong>零比特填充法</strong></li><li><strong>违规编码法</strong></li></ul></li></ol></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/xbX4Jkku.png" alt="封装成帧"></p><h4 id="span-style-color-ff6b6b-2-透明传输问题-span"><span style = 'color:#ff6b6b'>2.透明传输问题</span></h4><blockquote><p><strong>透明传输</strong>：<span style="color:#ff6b6b;font-weight:bold;">数据链路层对上层交付的PDU的内容没有任何限制,就好像数据链路层不存在一样</span></p><p><strong>透明传输问题</strong>：上层应用交付的数据单元中可能含有<strong>和帧定界符相同的数据</strong>而被接收端<strong>误认为帧定界符</strong>从而导致错误</p></blockquote><img src="https://img2.imgtp.com/2024/04/04/7EkRy4M8.png" alt="透明传输问题"  /><h4 id="3-组帧">3.组帧</h4><blockquote><p>如果不解决透明传输问题,则数据链路层就会<strong>对上层交付的PDU的内容有所限制</strong>,即<span style="color:#ff6b6b;font-weight:bold;">PDU中不能包含帧定界符</span>。显然,这样的数据链路层没有什么应用价值</p></blockquote><ol><li>字符计数法</li></ol><blockquote><p>原理：在帧的首部用一个<strong>计数字段</strong>来记录<strong>当前帧的所含的字节数</strong>(包含自身的1个字节),接收方读取到帧的首部中的计数字段就能<strong>确定该帧的长度并定界</strong></p><p>问题：如果<span style="color:#ff6b6b;font-weight:bold;">计数字段错误</span>,会导致<span style="color:#ff6b6b;font-weight:bold;">当前帧的定界错误</span>,从而<span style="color:#ff6b6b;font-weight:bold;">导致下一个帧的定界也出错</span>,接受双方将<span style="color:#ff6b6b;font-weight:bold;">失去同步</span>,造成<span style="color:#ff6b6b;font-weight:bold;font-size:20px;">灾难性后果!</span></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/10/T1nEmnkf.png" alt="字符计数法"></p><ol start="2"><li><strong>字符(节)填充法</strong></li></ol><blockquote><p>原理:发送方在发送数据前,如果待发送数据中<strong>含有和帧定界符相同的数据</strong>,在该数据<strong>前加一个转义字符ESC</strong>,如果数据中出现其他特殊字符(ESC字符)处理方式相同; 接收方在接收数据时如果<strong>读取到了ESC字符</strong>,则认为后面紧跟着的<strong>是数据</strong>而<strong>不是特殊字符</strong></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/1iuGNypX.png" alt="字符填充"></p><p>对于字符填充,举个不恰当的例子,如果我们要输出的字符串中带有<code>“</code>,就必须使用<code>\</code>进行转义,否则会出现语法错误</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; \&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>零比特填充</strong></li></ol><blockquote><p>发送方：扫描要发送的信息,<span style="color:#ff6b6b;font-weight:bold;">如果有连续的5个1,立即插入1个0</span>,接收端逆操作即可(<code>01111110</code>为帧定界符)</p><p>接收方：在接收端收到一个帧时,先找到标志字段确定边界,再用硬件对比特流进行扫描,<strong>发现连续5个1时,就把后面的0删除</strong></p><p>总结：<strong>保证了透明传输,在传送的比特流中可以传送任意比特组合,而不会引起对帧边界的判断错误</strong></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/Wc2JZvjx.png" alt="零比特填充"></p><ol start="4"><li><strong>违规编码法</strong></li></ol><blockquote><p>以曼彻斯特编码为例,曼彻斯特编码<strong>中间时刻必定跳变</strong>(电平对为[高-低]或[低-高]),所以可以<strong>使用不跳变表示帧的界,使用[高-高]表示帧的开始,使用[低-低]表示帧的结束</strong></p><p>违规编码法<strong>不采用任何填充技术</strong>便能实现数据的透明传输,但只适用于采用<strong>冗余编码</strong>的特殊编码环境</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/09/H8LbiLki.png" alt="image-20240409222701713"></p><blockquote><p><span style="color:#ff6b6b;font-weight:bold;font-size:18px">总结</span>:由于字节计数法中count字段的<strong>脆弱性</strong>(其值若有差错将导致灾难性后果)及字符填充实现上的复杂性和不兼容性(非<code>ASCII</code>字符不太适用),<strong>目前较普遍使用的帧同步法是比特填充法和违规编码法</strong></p></blockquote><h3 id="3-3-差错控制">3.3 差错控制</h3><blockquote><p><strong>全局性</strong>：由于线路本身电气特性所产生的<strong>随机噪声</strong>(热噪声),是信道固有的,随机存在的。解决办法：提高信噪比来减少或避免干扰。(对传感器下手)</p><p><strong>局部性</strong>：外界特定的短暂原因所造成的<strong>冲击噪声</strong>,是产生差错的主要原因。解决办法：通常利用编码技术来解决。</p><p>差错：</p><ol><li><strong>位错</strong>：比特位出错,1变成0,0变成1</li><li><strong>帧错</strong>：丢失、重复、失序</li></ol></blockquote><h4 id="检错编码">检错编码</h4><h5 id="奇偶校验码">奇偶校验码</h5><blockquote><p>奇偶校验码：是奇校验和偶校验的统称,在待发送<strong>数据后加一位校验码(0/1)</strong>,使整个数据中<code>1</code>的个数为奇数个(奇校验)或者偶数个(偶校验)</p><p>特点：<strong>只能检查出奇数个比特错误</strong>,但不知道哪些位错了,检错能力为50%</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/10/K7xxxKVB.png" alt="image-20240410090104759"></p><h5 id="循环冗余码"><strong>循环冗余码</strong></h5><blockquote><p>CRC检验广泛使用于数据链路层,<strong>CRC是具有纠错功能的</strong>,只是数据链路层仅仅使用了它的检错功能</p><p>收发双方需要约定一个<strong>生成多项式</strong>(最高位和最低位必须为1)</p><p>计算出的冗余码(<strong>帧检验序列FCS</strong>)加到数据最后一起传输</p><p>FCS生成和CRC检验都是<strong>由硬件完成</strong>,处理非常迅速</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/LqnKVXNU.png" alt="CRC"></p><p><strong>发送方</strong></p><blockquote><p>下图生成多项式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^3+x^2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> =&gt;  <span style="color:#ff6b6b;font-weight:bold;">1</span>$ \cdot x^3+<span style="color:#ff6b6b;font-weight:bold;">1</span> \cdot x^2+<span style="color:#ff6b6b;font-weight:bold;">0</span> \cdot x+<span style="color:#ff6b6b;font-weight:bold;">1</span> \cdot x^0$​ =&gt; 除数为<code>1101</code></p><p><strong>除法</strong>：此处指<strong>异或</strong>运算</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/yzlERye7.png" alt="CRC"></p><p><strong>接收方</strong></p><p><img src="https://img2.imgtp.com/2024/04/04/iEc5Y2da.png" alt=""></p><p><span style="color:#ff6b6b;font-weight:bold;font-size:20px">检错码总结</span></p><p><img src="https://img2.imgtp.com/2024/04/04/kspkPie2.png" alt=""></p><h4 id="纠错编码">纠错编码</h4><h5 id="汉明码">汉明码</h5><blockquote><p><strong>汉明码</strong>(<code>Hamming Code</code>):又称为海明码,最常见的纠错编码</p></blockquote><ol><li><strong>确定校验位数</strong></li></ol><blockquote><p>n为信息位数,r为校验位数,取使得等式成立的最小的r,<strong>海明不等式</strong>:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mn>2</mn><mi>r</mi></msup><mo>≥</mo><mi>n</mi><mo>+</mo><mi>r</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^r \geq n+r+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8504em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>海明码的位数</mtext><mo>=</mo><mtext>信息位数</mtext><mo>+</mo><mtext>校验位数</mtext></mrow><annotation encoding="application/x-tex">\text{海明码的位数} = \text{信息位数} + \text{校验位数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">海明码的位数</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord cjk_fallback">信息位数</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">校验位数</span></span></span></span></span></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/12/au4gBf7Q.png" alt="image-20240412151532196"></p><ol start="2"><li><strong>确定校验码和数据的位置</strong></li></ol><blockquote><p>校验码放在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 的位置上(第1、2、4、8……个)</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/12/vlACsIY3.png" alt="image-20240412151644361"></p><ol start="3"><li><strong>求出校验码的值</strong></li></ol><blockquote><p><strong>分组</strong>:第1个校验码中包括<strong>序号二进制末尾为1</strong>的数,第二个检验码中包括序号二进制为1的数,以此类推,同一个数可以分到多个组中,几个校验码就分几组</p><p><strong>求值</strong>:默认采用<strong>偶校验</strong>,保证每个组中1的个数为偶数个(如果1为奇数个,那么校验码为1,否则为0),也可以使用<strong>异或运算</strong>解决,校验码的值就是对应校验组所有数据异或运算的结果</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/12/aYNBsfJM.png" alt="image-20240412180239878"></p><ol start="4"><li><strong>检错并纠正</strong></li></ol><blockquote><p>检错：接收方接收到数据后将对应校验码和校验组所有数据进行异或运算,结果<strong>应全部为0(偶校验)</strong>,出现1说明出现了错误</p><p>纠错：各个组的异或结果应为000……,如果不全是0,<strong>假设是101,那么出错的为就是异或结果的二进制位,即5</strong></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/27/QmxDzrEi.png" alt="image-20240412181429972"></p><hr><h3 id="3-4-流量控制">3.4 流量控制</h3><h4 id="可靠传输">可靠传输</h4><p><img src="https://img2.imgtp.com/2024/04/04/bl3iFcsr.png" alt=""></p><p><img src="https://img2.imgtp.com/2024/04/04/9kptbtUg.png" alt=""></p><h4 id="停止-等待协议-SW">停止-等待协议(SW)</h4><ol><li>基本原理</li></ol><blockquote><p>停止-等待协议(<code>S</code>top-and-<code>W</code>ait)</p><ul><li><p>发送一个数据分组<code>DATA0</code>然后<strong>等待</strong>接收方发来确认信息<code>ACK0</code>后再传输下一个数据分组<code>DATA1</code> (发送、接收窗口大小都为1)</p></li><li><p>如果<strong>超时</strong>未接收到接收方发送的确认信息<code>ACK0</code>或者<strong>接收到否认</strong>信息<code>NAK</code>就重传上一个分组数据分组(发送方发送一个分组后不会立即删除该分组,因为可能需要重传,接收到[^ACK]后才将分组从缓存删除)</p></li><li><p>数据分组和确认信息的<strong>编号</strong>都是用来<strong>区分</strong>和上一个分组或信息是否相同(SW协议编号只需要1个比特)</p></li></ul></blockquote><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?t=48.2&p=25"><img alt="bili" src="https://img.shields.io/badge/SW-white?logo=bilibili&labelColor=white&color=%23fb7299"></a></p><p><img src="https://img2.imgtp.com/2024/04/04/kDCsZAbL.png" alt="SW"></p><ol start="2"><li><strong>停止等待协议的信道利用率</strong></li></ol><blockquote><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>信道利用率</mtext><mo>=</mo><mfrac><mtext>数据发送时延</mtext><mrow><mtext>数据发送时延</mtext><mo>+</mo><mtext>2个传播时延</mtext><mo>+</mo><mtext>确认信息发送时延</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{信道利用率}= \frac{\text{数据发送时延}}{\text{数据发送时延}+\text{2个传播时延}+\text{确认信息发送时延}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">信道利用率</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">数据发送时延</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord text"><span class="mord">2</span><span class="mord cjk_fallback">个传播时延</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord text"><span class="mord cjk_fallback">确认信息发送时延</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">数据发送时延</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><strong>确认信息的发送时延一般忽略不计</strong></p><p><strong>总结：当往返时间远大于数据帧的发送时延时,<span style="color:#ff6b6b;font-weight:bold;">信道利用率很低</span>,如果出现超时重传,信道利用率更低</strong>(卫星链路)</p></blockquote><h4 id="回退N帧协议-GBN">回退N帧协议(GBN)</h4><blockquote><p>回退N帧协议(<code>G</code>o-<code>B</code>ack-<code>N</code>)</p><p>发送方可以在<strong>未收到确认帧</strong>的情况下将<strong>发送窗口内的多个数据帧</strong>全部发送出去</p><p>回退N帧的含义：发送方发送了N个帧,如果这<strong>N个帧的前一个帧</strong>在超时的时候仍未接收到确认分组,则认为该帧<strong>出错或丢失</strong>,此时,发送方需要<strong>重传该出错帧及随后的N个帧</strong>,因为该协议中<span style="color:#ff6b6b;font-weight:bold;">接收方只能顺序接受帧</span></p><p>GBN采用<strong>累计确认</strong>,假设发送方发送了10个数据(0-9),随后收到接收方发来的确认分组编号为6,这表示0-6号数据全部接收了,而不是仅仅对6号数据的确认</p></blockquote><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?t=81.1&p=26"><img alt="bili" src="https://img.shields.io/badge/GBN-white?logo=bilibili&labelColor=white&color=%23fb7299"></a></p><p><img src="https://img2.imgtp.com/2024/04/04/hB250oge.png" alt=""></p><p><img src="https://img2.imgtp.com/2024/04/04/Ub9UUjBl.png" alt=""></p><blockquote><p><span style="color:#ff6b6b;font-weight:bold;">GBN重点</span>：</p><ul><li><p><strong>发送窗口</strong>：如果采用了n个比特进行编号,那么发送窗口<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">W_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><msub><mi>W</mi><mi>T</mi></msub><mo>&lt;</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1&lt;W_T&lt;2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>​,太大会造成接收方无法分辨新旧数据帧</p></li><li><p><strong>接收窗口</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>R</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">W_R = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>​,可保证按序接收数据帧(<strong>只能按序接收</strong>)</p></li><li><p>接收方<strong>只按顺序接收帧</strong>,不按序无情丢弃</p></li><li><p><strong>累积确认</strong>(偶尔梢带确认),确认序列号最大的、按序到达的帧</p></li></ul></blockquote><h4 id="选择重传协议-SR">选择重传协议(SR)</h4><blockquote><p>选择重传协议(<code>S</code>elective <code>R</code>epeat):在GBN协议中,只要一个帧出错,该帧及其随后的所有帧都需要重传,这是对通信资源的极大浪费,为进一步提高信道利用率,可以<strong>只重传出错或计时器超时的帧</strong>,此时必须<strong>加大接收窗口以便收下失序但正确到达的帧</strong></p><p><span style="color:#ff6b6b;font-weight:bold;">重点</span>：</p><ul><li>SR接收方将确认一个正确接收的帧而不管其是否按序到达(失序的帧将被缓存)</li><li><strong>不能使用累计确认,对每个帧都进行确认</strong></li><li>接收方有缓存</li><li><strong>发送窗口<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><msub><mi>W</mi><mi>T</mi></msub><mo>&lt;</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">1&lt;W_T&lt;2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>,接收窗口<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><msub><mi>W</mi><mi>R</mi></msub><mo>&lt;</mo><msub><mi>W</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">1&lt;W_R&lt;W_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong></li></ul></blockquote><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?t=9.1&p=27"><img alt="bili" src="https://img.shields.io/badge/SR-white?logo=bilibili&labelColor=white&color=%23fb7299"></a></p><p><img src="https://img2.imgtp.com/2024/04/04/lTKxaOpK.png" alt=""></p><hr><blockquote><p>总结：ARQ(自动重传请求)协议包括三种：停止-等待(SW)协议、后退N帧(GBN)协议、选择重传(SR)协议。<strong>GBN、SR为连续ARQ协议</strong>,可以连续发送多个帧。</p><p><strong>连续ARQ的信道利用率</strong>,假设发送窗口为<code>n</code>,即发送方可以连续发送的帧的数量</p><p>信道利用率U为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>U</mi><mo>=</mo><mfrac><mrow><mi>n</mi><msub><mi>T</mi><mi>D</mi></msub></mrow><mrow><msub><mi>T</mi><mi>D</mi></msub><mo>+</mo><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><msub><mi>T</mi><mi>A</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">U = \frac{nT_D}{T_D+RTT+T_A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1963em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>信道实际数据传输速率 = 信道利用率 × 信道带宽</p></blockquote><hr><h3 id="3-5-介质访问控制">3.5 介质访问控制</h3><h4 id="1-通信方式">1.通信方式</h4><p>数据链路层的通信方式</p><p><img src="https://img2.imgtp.com/2024/04/13/qREqa6zW.png" alt="image-20240413114302558"></p><h4 id="2-介质访问控制">2.介质访问控制</h4><p><img src="https://img2.imgtp.com/2024/04/20/YJFtawLv.png" alt="image-20240420110848013"></p><h4 id="3-信道划分">3.信道划分</h4><blockquote><p>复用：当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时,可利用复用技术<strong>在一条物理线路上建立多条通信信道来共享传输媒体的带宽</strong></p></blockquote><img src="https://img2.imgtp.com/2024/04/04/ClYKHJq5.png" alt="信道复用" style="zoom:80%;" /><h5 id="1-频分复用">1. 频分复用</h5><blockquote><p><strong>频分复用</strong>(Frequency-division multiplexing,<code>FDM</code>):将多路基带信号调制到不同频率载波上,再进行叠加形成一个复合信号,接收端的分用器通过滤波将各路信号滤出,将合成的复合信号恢复成原始的多路信号,<strong>信道利用率高</strong></p><p>实际应用中,为了防止信道之间相互干扰,相邻信道间还要加入“隔离频带”</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/13/9tcFG4HL.png" alt="image-20240413115640153"></p><h5 id="2-时分复用">2. 时分复用</h5><blockquote><p>时分复用(Time Division Multiplexing,<code>TDM</code>)：将传输线路的带宽资源<strong>按时间轮流分配给不同的用户</strong>,用户只能在分配的时间里使用线路传输数据(类似于时间片轮转),<strong>同一时刻只有一个用户在使用</strong>,相当于多个用户并发使用</p><p>存在的<strong>不足</strong>：使用时分复用系统传送计算机数据时,由于计算机数据的突发性质,用户对分配到的<strong>子信道的利用率一般不高</strong>(如果B暂时不使用信道,其他用户正常使用,时分复用还是会给B分配时间,而且这段时间内其他用户也不能使用)</p><p><strong>图中第2个周期第2段时间中<span style="color:#e6e600;font-weight:bold;">黄色线</span>并没有使用信道,但还是会分配信道给他,而且该时间段内其他用户不能使用</strong></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/13/GqvfdyNg.png" alt="image-20240413124732334"></p><blockquote><p><strong>统计时分复用</strong>(statistical time division multiplexing,<code>STDM</code>):动态地按需分配共用信道的时隙,<strong>只将需要传送数据的终端接入共用信道</strong>,可以提高信道的利用率</p><p>帧与帧之间留有<strong>空隙</strong>用来存储用户的地址信息,因为<strong>不是固定的分配给某个用户</strong></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/13/3tBMGXBQ.png" alt="image-20240413131118032"></p><h5 id="3-波分复用">3. 波分复用</h5><blockquote><p>波分复用(Wavelength Division Multiplexing,<code>WDM</code>)就是<strong>光的频分复用</strong>(专指<strong>光纤</strong>),使用一根光纤来同时传输多个光载波信号,现在已能做到在一根光纤上复用几十路或更多路数的光载波信号</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/wmz4xQ8u.png" alt="波分复用"></p><h5 id="4-码分复用">4. 码分复用</h5><blockquote><ul><li><strong>码分多路复用</strong>(Code Division Multiplexing,<code>CDM</code>)：又叫<strong>码分多址</strong><code>CDMA</code>(Code Division Multiple Access),采用不同的编码(地址码)来区分各路原始信号的一种复用方式</li><li>它<strong>既共享信道的频率,又共享时间</strong>,是真正意义的动态复用技术</li><li>最初用于军事,因为这种系统发送的信号<strong>有很强的抗干扰能力</strong>,其频谱类似于白噪声,不易被敌人发现</li></ul></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/jr9xumaq.png" alt="码分复用"></p><blockquote><ol><li><p><strong>码片序列转为码片向量</strong>(0-&gt;-1,1-&gt;+1),例：码片序列为(1101) -&gt; 码片向量为(+1,+1,-1,+1)</p></li><li><p><strong>如果有多个站同时发送信号,将它们的码片向量线性相加</strong></p></li><li><p>接收方收到总信号,如果想知道A站发送的信息就可以<strong>用A站的码片向量与总信号规格化内积</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>规格化内积</mtext><mo>=</mo><mfrac><mtext>向量相乘</mtext><mtext>向量个数</mtext></mfrac></mrow><annotation encoding="application/x-tex">\text{规格化内积} = \frac{\text{向量相乘}}{\text{向量个数}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">规格化内积</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">向量个数</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">向量相乘</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><ul><li><p><strong>内积为1  -&gt; A站发送信号1</strong> 发送的是自己的<strong>码片序列</strong></p></li><li><p><strong>内积为0  -&gt; A站未发送信号</strong> 未发送数据</p></li><li><p><strong>内积为-1 -&gt; A站发送信号0</strong> 发送的是自己的<strong>码片序列的二进制反码</strong></p></li></ul></li></ol></blockquote><hr><h4 id="4-随机访问">4.随机访问</h4><h5 id="概述">概述</h5><blockquote><p>在随机访问协议中,所有用户可以根据自己意愿发送信息,那么在总线型网络中,当有多个用户同时发送数据时,就会产生<strong>帧冲突</strong>(碰撞),导致所有冲突的用户的发送都以失败告终,<strong>随机访问介质访问控制协议</strong>(争用性协议)的核心思想是：<strong>胜利者通过争用获得信道</strong>,进而获得发送权</p></blockquote><h5 id="1-ALOHA-协议">1. ALOHA 协议</h5><blockquote><p><strong>纯 [^ALOHA] 协议</strong>：<span style="color:#ff6b6b;font-weight:bold;">想发就发</span>,发生冲突等待<strong>随机时间</strong>后重传,容易出现冲突,<strong>效率较低</strong></p><p><strong>时隙 ALOHA 协议</strong>：将时间分成相同大小的<strong>时间片</strong>,只有在<span style="color:#ff6b6b;font-weight:bold;">时间片开始的时候</span>才能发送,<strong>发送一帧的时间不能超过一个时隙</strong>,一定程度上限制了发送方发送数据的随意性,降低了冲突的概率(依然很大),产生冲突后等待<strong>随机个时隙</strong>时间后重传</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/17/RtFprUL8.png" alt="image-20240417220719723"></p><h5 id="2-CSMA-协议">2. CSMA 协议</h5><blockquote><p><strong>CSMA(Carrier Sense Multiple Access)载波监听 多路访问</strong></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/20/gCZW2TEK.png" alt="image-20240420091922904"></p><p><span style="color:#ff6b6b;font-weight:bold;">总结</span></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">1-坚持CSMA</th><th style="text-align:center">非坚持CSMA</th><th style="text-align:center">P-坚持CSMA</th></tr></thead><tbody><tr><td style="text-align:center">空闲</td><td style="text-align:center">立即发送</td><td style="text-align:center">立即发送</td><td style="text-align:center"><strong>p概率发送,1-p概率推迟到下一个时隙</strong></td></tr><tr><td style="text-align:center">忙</td><td style="text-align:center">持续监听</td><td style="text-align:center"><span style="color:#ff6b6b;font-weight:bold;">放弃监听</span>,等待随机时间继续监听</td><td style="text-align:center"><strong>持续监听(等到下一个时隙再监听)</strong></td></tr></tbody></table><blockquote><p>p-坚持CSMA只适用于<strong>时分信道</strong>,检测到<strong>信道空闲时以概率p发送数据</strong>,以概率1-p<strong>推迟到下一个时隙继续监听</strong></p><p>1-坚持CSMA监听到信道忙时会<strong>持续监听信道,出现冲突时才会等待随机时间后再监听</strong></p></blockquote><h5 id="3-CSMA-CD-协议">3. <strong>CSMA/CD 协议</strong></h5><blockquote><p><strong>CSMA/CD(Carrier Sense Multiple Access/collision detection)载波监听 多路访问/碰撞检测</strong></p><p>在CSMA中<span style="color:#ff6b6b;font-weight:bold;">尽管发生冲突,数据还是会继续传输完毕</span>,这是不必要的(发生冲突后传输的数据已经无效)</p><p>CSMA/CD 的工作流程可以概括为“先听后发,<strong>边听边发,冲突停发</strong>,随机重发”,<strong>在发送数据时一边监听信道,如果发生冲突立即停止发送</strong>(主要区别)</p></blockquote><h6 id="工作流程">工作流程</h6><p><img src="https://img2.imgtp.com/2024/04/04/ED5B2K8l.png" alt=""></p><h6 id="争用期"><strong>争用期</strong></h6><blockquote><p><strong>2τ</strong> ,即<strong>端到端传播时延的2倍</strong>,10BaseT以太网中规定争用期为51.2μs</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/pcp1O29f.png" alt=""></p><h6 id="最小帧长"><strong>最小帧长</strong></h6><blockquote><p><strong>最小帧长 = 争用期 x 数据传输速率</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>l</mi><mo>=</mo><mn>2</mn><mi>τ</mi><mo>∗</mo><mtext>数据传输速率</mtext><mo>=</mo><mn>2</mn><mo>∗</mo><mfrac><mtext>距离</mtext><mtext>传播速率</mtext></mfrac><mo>∗</mo><mtext>数据传输速率</mtext></mrow><annotation encoding="application/x-tex">l = 2τ * \text{数据传输速率} = 2*\frac{\text{距离}}{\text{传播速率}}*\text{数据传输速率}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">数据传输速率</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">传播速率</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">距离</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">数据传输速率</span></span></span></span></span></span></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/TctW8FkX.png" alt=""></p><h6 id="二进制指数退避算法"><strong>二进制指数退避算法</strong></h6><blockquote><p>发生碰撞后进行重传,随着重传次数增加,退避时间也会逐渐增加,减小了碰撞的概率</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/vzrGh2uB.png" alt="image-20231103163318636"></p><h5 id="4-CSMA-CA">4. <strong>CSMA/CA</strong></h5><blockquote><p><strong>CSMA/CA(Carrier Sense Multiple Access with Collision Avoid)载波监听、多路访问/碰撞避免</strong></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/CT1N67Ir.png" alt=""></p><blockquote><p>碰撞避免实现中涉及的的三种机制：</p><p>1.预约信道：通知其它站点，自己需要的时间长度</p><p>2.ACK帧：接收站点发回确认；发送端超时未接收ACK则重发</p><p>3.<code>RTS</code>(Request To Send) 帧与<code>CTS</code>(Clear To Send)帧(可选)：发送端发RTS，接收端响应CTS，发送端收到CTS则认为可以发送数据，<strong>CTS帧的目的：1.给源站明确的发送许可 2.指示其他站在预约期间不要发送</strong></p><p><strong>帧间间隔</strong>(InterFrame Space IFS):所有站发送一帧后必须等待一段很短的时间(帧间间隔)才能继续监听并发送数据，IFS的类型：</p><ul><li><code>SIFS</code>(短) 最短的IFS，用于分隔一次对话的各帧(ACK、CTS等)</li><li><code>PIFS</code>(点协调) 中等长度的IFS，在PCF操作中使用</li><li><code>DIFS</code>(分布式协调) 最长的IFS，用于异步帧竞争访问的时延</li></ul></blockquote><h4 id="5-轮询访问">5.轮询访问</h4><blockquote><p>用户不能随机发送数据，而是通过一个集中控制的监控站，以循环方式轮询访问每个结点，再决定信道的分配，典型的轮询访问控制协议是令牌传递协议</p></blockquote><h5 id="令牌传递协议">令牌传递协议</h5><p><img src="https://img2.imgtp.com/2024/04/20/meVU77Xe.png" alt="image-20240420110009790"></p><blockquote><p>注意点：</p><ul><li>网络空闲时，只有<strong>令牌帧在循环传递</strong>(游荡)</li><li>源站点传输完数据后，<strong>重新生成一个令牌</strong>并传递给下一个站点</li><li>令牌传递协议适合<strong>负载较重、通信量较大</strong>的广播信道</li><li><span style="color:#ff6b6b;font-weight:bold;">单点故障会导致整个网络无法工作</span>(逻辑上环形)</li></ul></blockquote><h3 id="3-6-局域网">3.6 局域网</h3><h4 id="概述-2">概述</h4><p><img src="https://img2.imgtp.com/2024/04/20/ZLZC4JJA.png" alt="image-20240420113134042"></p><h4 id="拓扑结构">拓扑结构</h4><p><img src="https://img2.imgtp.com/2024/04/20/reb0noqv.png" alt=""></p><h4 id="分类-2">分类</h4><blockquote><ol><li><p>以太网以太网是应用最为广泛的局域网，包括标准以太网（10Mbps）、快速以太网（100Mbps）千兆以太网（1000Mbps）和10G以太网，它们都符合IEEE802.3系列标准规范。<strong>逻辑拓扑总线型，物理拓扑是星型</strong>或拓展星型,使用CSMA/CD</p></li><li><p>令牌环网<strong>物理上采用了星形拓扑结构，逻辑上是环形拓扑结构</strong>。已是“明日黄花”</p></li><li><p>FDDl网 （Fiber Distriouted Data Interiace)<strong>物理上采用了双环拓扑结构，逻辑上是环形拓扑结构</strong></p></li><li><p>ATM网 (Asynchronous Transier Mode)较新型的单元交换技术，使用53字节固定长度的单元进行交换</p></li><li><p>无线局城网（WIrelessLocalAreaNetworkWLAN）采用IEEE802.11标准</p></li></ol></blockquote><p><img src="https://img2.imgtp.com/2024/04/27/KUOQpahI.png" alt="局域网的分类"></p><blockquote><p>以太网支持全双工和半双工通信，<strong>全双工不使用CSMA/CD协议(无冲突)</strong>，半双工通信方式可能发生冲突，使用CSMA/CD协议 [<strong>10吉比特以太网只能全双工</strong>]</p></blockquote><p>100BaseT以太网</p><p><img src="https://img2.imgtp.com/2024/04/20/51qnZW5A.png" alt="image-20240420125317777"></p><p>MAC子层</p><p><img src="https://img2.imgtp.com/2024/04/20/gJBMwlkd.png" alt="image-20240420141212069"></p><h4 id="MAC地址">MAC地址</h4><ol><li><strong>MAC地址</strong>是对网络上<strong>各接口的唯一标识</strong>,而不是对网络上各设备的唯一标识(<strong>路由器有多个接口,所以有多个MAC地址</strong>)</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/68avB7T3.png" alt=""></p><ol start="2"><li>MAC地址格式</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/BNjnFpPt.png" alt=""></p><ol start="3"><li>MAC帧有三种：单播、广播、多播</li></ol><blockquote><p>单播帧：一对一</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/D6d0SVGo.png" alt=""></p><blockquote><p>广播帧：一对全体</p><p>广播地址：<strong>FF-FF-FF-FF-FF-FF</strong></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/TfVVC54V.png" alt=""></p><blockquote><p>多播帧：一对多</p><p>多播地址：<strong>第二个数是奇数</strong>代表是多播地址</p></blockquote><h4 id="VLAN">VLAN</h4><blockquote><p>虚拟局域网(<code>Virtual Local Area Network</code>,VLAN)是一种将局域网内的站点划分成与物理位置无关的逻辑组的技术,一个逻辑组就是一个VLAN,VLAN中的各站点具有某些共同的应用需求</p><p><strong>广播风暴</strong>：<span style="color:#ff6b6b;font-weight:bold;">广播风暴会浪费网络资源和各主机的CPU资源</span></p><ul><li>可以<strong>使用路由器切割广播域</strong>,防止广播风暴,但是成本较高</li><li>使用<strong>vlan技术划分广播域</strong></li></ul><p>注意点：</p><ul><li><p><code>A</code>发送广播帧,<code>Access</code>接口接收并<strong>打标签</strong>,<code>PVID</code>和<code>VID</code>相同的Access端口可以接收该帧,进行去标签转发</p></li><li><p><code>Trunk</code>端口的<code>PVID</code>如果等于该帧的<code>VID</code>,也会先去标签转发,然后再打标签,否则直接转发</p></li><li><p><strong>Trunk端口是连接两个交换机的</strong></p></li><li><p>插入VLAN标签的帧称为802.1Q帧，首部添加4字节，最大帧长增加为1522字节</p></li></ul></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/XkiEONEm.png" alt=""></p><hr><h3 id="3-7-广域网">3.7 广域网</h3><h4 id="概述-3">概述</h4><p><img src="https://img2.imgtp.com/2024/04/20/V6rN5owV.png" alt="image-20240420131312782"></p><h4 id="PPP-协议"><strong>PPP 协议</strong></h4><ol><li>概述</li></ol><blockquote><p>点对点协议(<code>Point-to-Point Protocol</code>,PPP)是目前使用最广泛的<strong>点对点数据链路层协议</strong>,</p><p>PPP协议的3个组成部分：</p><ol><li>一个将IP数据报封装到串行链路的方法</li><li>网络控制协议NCP:PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接</li><li>链路控制协议LCP：建立并维护数据链路连接(身份验证)</li></ol></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/oEvbpogl.png" alt="PPP"></p><ol start="2"><li>PPP的帧格式</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/rpgHWbjQ.png" alt=""></p><ol start="3"><li>PPP的透明传输</li></ol><blockquote><p>异步传输：字符填充</p><p>同步传输：0比特填充</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/1bplHCdz.png" alt=""></p><ol start="3"><li>PPP的状态图</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/gvFkscEH.png" alt=""></p><blockquote><p>PPP协议特点：</p><ol><li>不使用序号和确认机制，只保证无差错接收，因此是<span style="color:#ff6b6b;font-weight:bold;">不可靠服务</span></li><li>PPP<span style="color:#ff6b6b;font-weight:bold;">只支持全双工点对点链路，不支持多点线路</span></li><li>PPP的<strong>两端可以运行不同的网络层协议</strong>，但仍可使用同一个PPP进行通信</li><li>PPP是<strong>面向字节</strong>的，所有PPP帧的长度都是整数个字节</li></ol></blockquote><h3 id="3-8-链路层设备">3.8 链路层设备</h3><h4 id="网桥">网桥</h4><p><img src="https://img2.imgtp.com/2024/04/20/55lQDblM.png" alt="image-20240420155806561"></p><blockquote><p>网桥可以<strong>连接两个不同的网络而不增大碰撞域</strong></p></blockquote><h4 id="交换机">交换机</h4><p><img src="https://img2.imgtp.com/2024/04/20/IHx13ZvA.png" alt="image-20240420160645782"></p><h4 id="集线器vs交换机">集线器vs交换机</h4><p><img src="https://img2.imgtp.com/2024/04/04/SAdkZQI5.png" alt=""></p><p><img src="https://img2.imgtp.com/2024/04/04/cH6i5koT.png" alt=""></p><p><span style="color:#ff6b6b;font-weight:bold;">总结</span></p><blockquote><p>使用集线器的共享式以太网(10Mb/s)，如果有N个用户，每个用户的平均带宽为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>10</mn><mi>N</mi></mfrac><mi>M</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\frac{10}{N}Mb/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span>,如果使用以太网交换机（全双工）连接，每个用户平均带宽为10Mb/s，所以有N个接口的交换机总容量为10N Mb/s(半双工则减小一半),这是交换机的最大优点</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/20/2SaXyedY.png" alt="image-20240420160932053"></p><h3 id="3-9-STP">3.9 STP</h3><blockquote><p>透明网桥的生成树协议：</p><p>为了提高以太网的可靠性,有时需要在两个以太网之间使用多个透明网桥来提供冗余链路，为了避免广播帧在环路中永久兜圈,透明网桥使用生成树协议<code>Spanning Tree Protocol</code>,可以在增加冗余链路提高网络可靠性的同时,又避免环路带来的问题</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/F5cxDeoo.png" alt=""></p><h3 id="4-思维导图和习题">4. 思维导图和习题</h3><p><a href="https://www.kdocs.cn/view/l/cgV0rfS0qZEA">第3章 数据链路层(思维导图)-1 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/ciOEeLV6ffuJ">第3章 数据链路层(思维导图)-2 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cnRBS8NFgTll">第3章 数据链路层(思维导图)-3 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cl60fYfO1qZe">第3章 数据链路层 习题(第1部分)</a></p><p><a href="https://www.kdocs.cn/view/l/cenjHDfYLe95">第3章 数据链路层 习题(第2部分)</a></p><hr><h2 id="4-网络层">4. 网络层</h2><h3 id="4-1-概述">4.1 概述</h3><blockquote><p>网络层的主要任务：将分组从源主机经过多个网络和多段链路传输到目的主机,可以将该任务划分为分组转发和路由选择两种重要的功能</p></blockquote><h3 id="4-2-网络层提供的两种服务">4.2 网络层提供的两种服务</h3><h4 id="1-虚电路服务">1.虚电路服务</h4><blockquote><p>虚电路服务特点：</p><ol><li><p>虚电路提供的是<span style="color:#ff6b6b;font-weight:bold;">面向连接</span>的，<span style="color:#ff6b6b;font-weight:bold;">可靠的</span>服务</p></li><li><p><strong>虚</strong>表示这是一条<strong>逻辑上的连接，不是专用的</strong>,分组沿着这条逻辑连接按照<strong>存储转发方式传送</strong>,而不是真正建立了一条物理连接</p></li><li><p>建立连接和拆除都需要时间开销，<strong>不适用于突发式通信，但对长时间、频繁的数据交换效率较高</strong></p></li><li><p><span style="color:#ff6b6b;font-weight:bold;">致命弱点：虚电路上如果某个结点或链路出现故障(相当于电线被剪断了)，所有经过这个结点或链路的虚电路都会遭到破坏(需要重新建立连接)</span></p></li><li><p>分组的首部仅在连接建立阶段使用完整的目的主机地址,之后每个分组的首部只需要携带一条虚电路编号即可</p></li></ol></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/yW2dRsAm.png" alt=""></p><h4 id="2-数据报服务">2.数据报服务</h4><blockquote><p>数据报服务特点：</p><ol><li><p>TCP/IP使用的就是这种<strong>简单灵活</strong>的、<span style="color:#ff6b6b;font-weight:bold;">无连接</span>的、<span style="color:#ff6b6b;font-weight:bold;">不可靠</span>的数据报服务</p></li><li><p>核心思想：<strong>可靠通信应由用户主机来保证</strong></p></li><li><p>由于网络自身不提供端到端的可靠传输服务,这就使得网络中的<strong>路由器可以做得比较简单,大大降低了网络造价</strong></p></li><li><p>这种设计思想的运行方式灵活、能够适应多种应用。因特网能够发展到今日的规模,充分证明了当初采取这种设计思想的正确性</p></li></ol></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/LojBc6xi.png" alt=""></p><h3 id="4-3-SDN">4.3 SDN</h3><h4 id="结构">结构</h4><p><img src="https://img2.imgtp.com/2024/04/27/Su0B0dOx.png" alt="image-20240427114506132"></p><h4 id="区别">区别</h4><blockquote><p>网络层可抽象划分为<strong>数据平面(转发)<strong>和</strong>控制平面(路由选择)</strong></p><p>传统：路由选择算法运行在每台路由器中，并且在<strong>每台路由器中都包含转发和路由选择两种功能</strong></p><p>(Software Defined Network，SDN)：控制平面从路由器物理上分离，<strong>路由器仅实现转发，远程控制器计算和分发转发表以供每台路由器所使用</strong></p></blockquote><h4 id="路由选择处理器">路由选择处理器</h4><img src="https://img2.imgtp.com/2024/04/27/qnHfAOU6.png" alt="image-20240427114357548" style="zoom:50%;" /><h3 id="4-4-IPv4">4.4 IPv4</h3><h4 id="概述-4">概述</h4><blockquote><p>网际协议(<code>Internet Protocol</code>,<code>IP</code>)是<code>TCP/IP</code>体系结构网际层中的<strong>核心协议</strong></p><p><code>IPv4</code>地址就是给因特网(Internet)上的每一台主机(或路由器)的每一个接口分配一个在全世界范围内是唯一的32比特的标识符</p></blockquote><h4 id="首部格式">首部格式</h4><p><img src="https://img2.imgtp.com/2024/04/04/KOyDkDzX.png" alt=""></p><p><span style="color:#ff6b6b;font-weight:bold;">各个字段及描述</span></p><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">版本</td><td style="text-align:left">长度为4个比特,用来表示IP协议的版本,<strong>通信双方使用的IP协议的版本必须一致</strong>,目前广泛使用的IP协议的版本号为4(即IPv4)</td></tr><tr><td style="text-align:center"><strong>首部长度</strong></td><td style="text-align:left">长度为4个比特,该字段的取值以<span style="color:#ff6b6b;font-weight:bold;">4B为单位</span>,用来表示IPV4数据报的首部长度(<strong>20+(0~40)</strong>)<br/>最小取值为二进制的0101,即十进制的5,再乘以4字节单位,表示IPv4数据报首部只有20字节固定部分<br />最大取值为二进制的1111,即十进制的15,再乘以4字节单位,表示IPV4数据报首部包含20字节固定部分和最大40字节可变部分</td></tr><tr><td style="text-align:center"><strong>总长度</strong></td><td style="text-align:left">长度为16个比特,该字段的取值以<span style="color:#ff6b6b;font-weight:bold;">字节为单位</span>,用来表示IPv4数据报的长度(首部长度+数据载荷长度)<br />最大取值为二进制的16个比特1,即十进制的65535(很少传输这么长的IPv4数据报)</td></tr><tr><td style="text-align:center"><strong>标识</strong></td><td style="text-align:left">长度为16个比特,属于<strong>同一个IPv4数据报的各分片数据报应该具有相同的标识</strong></td></tr><tr><td style="text-align:center"><strong>标志</strong></td><td style="text-align:left">最低位(<code>More Fragment,MF</code>)<br/>    MF=1表示本分片后面还有分片<br/>    MF=0表示本分片后面没有分片<br/>中间位(<code>Don't Fragment,DF</code>)<br/>    DF=1表示不允许分片<br/>    DF=0表示允许分片<br/>最高位为保留位,必须设置为0</td></tr><tr><td style="text-align:center"><strong>片偏移</strong></td><td style="text-align:left">长度为16个比特,该字段的取值,以<span style="color:#ff6b6b;font-weight:bold;">8B为单位</span>,用来指出<strong>分片IPv4数据报的数据载荷偏移其在原IPv4数据报的位置有多远</strong>,只能为整数,否则必须调整前一个分片长度</td></tr><tr><td style="text-align:center"><strong>生存时间</strong></td><td style="text-align:left">长度为8个比特,最大取值为二进制的11111111,即十进制的255。该字段的取值最初以秒为单位。因此,IPv4数据报的最大生存时间最初为255秒。路由器转发IPv4数据报时,将其首部中该字段的值减去该数据报在路由器上所耗费的时间,若结果不为0就转发,否则就丢弃<br />生存时间字段后来改为<span style="color:#ff6b6b;font-weight:bold;">以“跳数”为单位</span>,路由器收到待转发的IPv4数据报时,将其首部中的该字段的值减1,若结果不为0就转发,否则就丢弃</td></tr><tr><td style="text-align:center"><strong>协议</strong></td><td style="text-align:left">长度为8个比特,用来指明IPv4数据报的数据载荷是何种协议数据单元PDU<br /><img src="https://img2.imgtp.com/2024/04/04/xAa9ANsy.png" alt=""></td></tr><tr><td style="text-align:center"><strong>首部检验和</strong></td><td style="text-align:left">长度为16个比特,用于<strong>检测IPv4数据报在传输过程中其首部是否出现了差错</strong><br />IPv4数据报每经过一个路由器,其首部中的某些字段的值(例如生存时间TTL、标志以及片偏移等)都可能发生变化,因此路由器都要重新计算一下首部检验和</td></tr><tr><td style="text-align:center"><strong>源IP地址和目的IP地址</strong></td><td style="text-align:left">长度都为32个比特,用来填写发送(接收)IPv4数据报的源(目的)主机的IPv4地址</td></tr></tbody></table><h4 id="MTU">MTU</h4><blockquote><p><code>MTU</code>：最大传送单元,超过最大传送单元的长度的IP数据报必须分片</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/L8hoyynm.png" alt=""></p><p><img src="https://img2.imgtp.com/2024/04/04/al00y50P.png" alt=""></p><h3 id="4-5-IP编址方式">4.5 IP编址方式</h3><h4 id="1-分类编址的IP">1.分类编址的IP</h4><p><img src="https://img2.imgtp.com/2024/04/04/qnNZ6ucM.png" alt=""></p><h4 id="2-划分子网的IP">2.划分子网的IP</h4><blockquote><p><strong>分类编址方法不够灵活且容易造成大量地址浪费,划分子网编址方法对其进行改进(“打补丁”)</strong></p></blockquote><img src="https://img2.imgtp.com/2024/04/04/q2ONHMZl.png" style="zoom:80%;" /><blockquote><p><strong>划分子网案例</strong></p></blockquote><img src="https://img2.imgtp.com/2024/04/04/kwonYEUW.png" style="zoom:67%;" /><h4 id="3-CIDR">3.CIDR</h4><img src="https://img2.imgtp.com/2024/04/04/IFbL2L2v.png" style="zoom:67%;" /><blockquote><p><strong>无分类</strong>域间路由选择(<code>C</code>lassless <code>I</code>nter-<code>D</code>omain <code>R</code>outing,<code>CIDR</code> )</p></blockquote><img src="https://img2.imgtp.com/2024/04/04/2tRrZdhS.png" style="zoom:67%;" /><blockquote><p><strong>练习</strong></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/2qpJoDAK.png" alt=""></p><h4 id="4-路由聚合">4.路由聚合</h4><blockquote><p><strong>找出共同前缀,其余位取0</strong></p></blockquote><img src="https://img2.imgtp.com/2024/04/04/A51cUVpL.png" style="zoom:67%;" /><h3 id="4-6-IP数据报的发送和转发过程">4.6 IP数据报的发送和转发过程</h3><blockquote><p><strong>IP数据报的发送和转发过程</strong></p><ul><li><p><strong>主机发送IP数据报</strong></p><ul><li>判断目的主机是否与自己在同一个网络：<ul><li>若在同一个网络,则属于直接交付,直接发送给目的主机</li><li>若不在同一个网络,则属于间接交付,传输给主机所在网络的默认网关(路由器),由默认网关帮忙转发)</li></ul></li></ul></li><li><p><strong>路由器转发IP数据报</strong></p><ul><li>检查IP数据报首部是否出错：<ul><li>若出错,则直接丢弃该IP数据报并通告源主机</li><li>若没有出错,则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul><li>若找到匹配的条目,则转发给条目中指示的下一跳；</li><li>若找不到,则丢弃该IP数据报并通告源主机；</li></ul></li></ul></li></ul></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/Bn4bmj1L.png" alt=""></p><blockquote><p>路由器不转发广播IP数据报,即<strong>路由器隔离广播域</strong>,如果因特网中数量巨大的路由器收到广播IP数据报后都进行转发,则会造成巨大的广播风暴,严重浪费因特网资源</p><ul><li>中继器和集线器工作在物理层,<strong>既不隔离冲突域也不隔离广播域</strong></li><li>网桥和交换机(多端口网桥)工作在数据链路层,<strong>可以隔离冲突域,不能隔离广播域</strong></li><li>路由器工作在网络层,<strong>既隔离冲突域,也隔离广播域</strong></li></ul></blockquote><h3 id="4-7-ARP">4.7 ARP</h3><blockquote><p>ARP（Address Resolution Protocol），是<strong>根据IP地址获取MAC地址</strong>的一个TCP/IP协议</p><p>主机中保存了一个高速缓存表，<mark>记录了IP和MAC的对应关系</mark></p></blockquote><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109221234731.png" style="zoom: 67%;" /><blockquote><p>ARP协议动态获取MAC地址</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109221003126.png" alt=""></p><blockquote><p><strong>总结：<code>ARP</code>协议只能逐链路（相邻）使用，不能跨网络使用</strong>**</p></blockquote><h3 id="4-8-静态路由配置">4.8 静态路由配置</h3><h4 id="1-静态路由的配置">1. 静态路由的配置</h4><img src="https://img2.imgtp.com/2024/04/04/CtaIyZQk.png" style="zoom:67%;" /><h4 id="2-默认路由">2. 默认路由</h4><ol><li><p>默认路由：默认路由条目中的目的网络<code>0.0.0.0/0</code>,其中<code>0.0.0.0</code>表示任意网络,而网络前缀“/0”(相应的地址掩码为<code>0.0.0.0</code>)是最短的网络前缀</p></li><li><p>特定主机路由：特定主机路由条目中的目的网络<code>192.168.2.1/32</code>,其中<code>192.168.2.1</code>是特定主机的IP地址,而网络前缀“/32”(相应地址掩码为<code>255.255.255.255</code>)是最长的网络前缀</p></li><li><p>路由器在查找转发表转发IP数据报时,遵循“最长前缀匹配”的原则,因此默认路由匹配优先级最低,特定主机路由条目的匹配优先级最高</p></li></ol><img src="https://img2.imgtp.com/2024/04/04/ZV9GFitH.png" style="zoom:67%;" /><h4 id="3-路由环路">3. 路由环路</h4><ul><li>错误配置静态路由有可能导致路由环路问题</li><li>为了防止IP数据报在环路中永久兜圈,在IP数据报首部设有生存时间TTL,TTL为0时会被丢弃</li></ul><p><strong>路由环路问题产生原因：</strong></p><ol><li><strong>路由配置错误</strong></li></ol><img src="https://img2.imgtp.com/2024/04/04/ae9r7c4U.png" style="zoom:67%;" /><ol start="2"><li><strong>聚合了不存在的IP地址</strong></li></ol><blockquote><p>需要给不存在的IP地址配置黑洞路由,防止IP数据报转发到其他路由器</p></blockquote><img src="https://img2.imgtp.com/2024/04/04/agvaYwYw.png" style="zoom:67%;" /><ol start="3"><li><strong>网络故障</strong></li></ol><blockquote><p>可以在网络发生故障时添加一条针对该IP的黑洞路由,待网络正常后又将其设置为失效状态</p></blockquote><img src="https://img2.imgtp.com/2024/04/04/4SIsCein.png" style="zoom: 67%;" /><h3 id="4-9-DHCP">4.9 DHCP</h3><h4 id="1-概述">1. 概述</h4><blockquote><p>动态主机配置协议(<code>D</code>ynamic <code>h</code>ost <code>c</code>onfiguration <code>p</code>rotocol)</p><p>作用：</p><ul><li><code>DHCP</code>可为计算机自动配置网络参数,包括：<ul><li>IP地址</li><li>子网掩码</li><li>默认网关</li><li>DNS服务器</li></ul></li></ul></blockquote><h4 id="2-工作过程">2. 工作过程</h4><p><img src="https://img2.imgtp.com/2024/04/04/ICGzRKfp.png" alt=""></p><h4 id="3-DHCP中继代理">3. DHCP中继代理</h4><p><img src="https://img2.imgtp.com/2024/04/04/Q6Dzgeuh.png" alt=""></p><hr><h3 id="4-10-路由选择协议">4.10 路由选择协议</h3><ol><li>路由选择分为两类</li></ol><table><thead><tr><th style="text-align:left">静态路由选择</th><th style="text-align:left">动态路由选择</th></tr></thead><tbody><tr><td style="text-align:left">采用<strong>人工配置</strong>的方式给路由器添加网络路由、默认路由和特定主机路由等路由条目</td><td style="text-align:left">路由器通过路由选择协议<strong>自动获取</strong>路由信息</td></tr><tr><td style="text-align:left">静态路由选择<strong>简单、开销小</strong>,但不能及时适应网络状态(流量、拓扑等)的变化</td><td style="text-align:left">动态路由选择比较<strong>复杂、开销比较大</strong>,但能较好地适<strong>应网络状态</strong>的变化</td></tr><tr><td style="text-align:left">静态路由选择一般只在<strong>小规模网络</strong>中采用</td><td style="text-align:left">动态路由选择适用于<strong>大规模网络</strong></td></tr></tbody></table><ol start="2"><li>因特网采用分层次的路由选择协议</li></ol><p>因特网是全球最大的互联网,它所采取的路由选择协议具有以下三个主要特点：</p><ul><li>自适应：因特网采用动态路由选择,能较好地适应网络状态的变化。</li><li>分布式：因特网中的各路由器通过相互间的信息交互,共同完成路由信息的获取和更新。</li><li>分层次：将整个因特网划分为许多较小的自治系统(<code>Autonomous System,AS</code>),在自治系统内部和外部采用不同类别的路由选择协议,分别进行路由选择</li></ul><img src="https://img2.imgtp.com/2024/04/04/abaIPV0E.png" style="zoom:67%;" /><h3 id="4-11-RIP">4.11 RIP</h3><p>路由信息协议(<code>Routing Information Protocol,RIP</code>)是内部网关协议中最先得到广泛使用的协议之一</p><h4 id="概述-5">概述</h4><ul><li><p>RIP使用跳数(<code>Hop Count</code>)作为度量(<code>Metric</code>)来衡量到达目的网络的距离(<strong>距离向量</strong>)</p><ul><li><p>RIP将路由器到直连网络的距离定义为1</p></li><li><p>RIP将路由器到非直连网络的距离定义为所经过的路由器数加1</p></li><li><p>RIP允许一条路径最多只能包含15个路由器,<span style="color:#ff6b6b;font-weight:bold;">距离等于16时相当于不可达</span>,因此RIP只适用于小型互<br>联网</p></li></ul></li></ul><img src="https://img2.imgtp.com/2024/04/04/SdAYuRNl.png" style="zoom: 50%;" /><ol start="2"><li><p>RIP认为<strong>好的路由就是“距离短”的路由</strong>,也就是所通过路由器数量最少的路由,和传输速率和物理距离等无关</p></li><li><p>RIP的3个重要特点</p></li></ol><img src="https://img2.imgtp.com/2024/04/04/5Eskdf9i.png" style="zoom: 67%;" /><h4 id="工作原理">工作原理</h4><ol><li><strong>基本流程</strong></li></ol><img src="https://img2.imgtp.com/2024/04/04/bH69GgoT.png" style="zoom:67%;" /><ol start="2"><li><strong>更新规则</strong></li></ol><img src="https://img2.imgtp.com/2024/04/04/Fp83R5QM.png" style="zoom:80%;" /><ol start="3"><li><p><strong>坏消息传播的慢</strong></p><p><img src="https://img2.imgtp.com/2024/04/04/X8Q0gotf.png" alt=""></p></li><li><p><strong>优缺点</strong></p></li></ol><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>实现简单,路由器开销小</td><td>RIP限制了最大RIP距离为<code>15</code>这就限制了使用RIP的自治系统AS的规模</td></tr><tr><td>如果一个路由器发现了RIP距离更短的路由,那么这种更新信息就传播得很快,即“好消息传播得快”</td><td>相邻路由器之间交换的路由信息是路由器中的完整路由表,因而随着网络规模的扩大,开销也随之增大</td></tr><tr><td></td><td>“<strong>坏消息传播得慢</strong>”,使更新过程的收敛时间过长。因此,对于规模较大的自治系统AS,应当使用<code>OSPF</code>协议</td></tr></tbody></table><h3 id="4-12-OSPF">4.12 <code>OSPF</code></h3><h4 id="1-基本概念">1. 基本概念</h4><blockquote><p>开放最短路径优先(<code>Open Shortest Path First,OSPF</code>)协议是为了克服路由信息协议RIP的缺点在1989年开发出来的</p><ul><li>“开放”表明<code>OSPF</code>协议不是受某一厂商控制,而是公开发表的</li><li>“最短路径优先”是因为使用了Dijkstra提出的最短路径算法(<code>Shortest Path First,SPF</code>)</li></ul></blockquote><h4 id="2-特点">2. 特点</h4><blockquote><ul><li><code>OSPF</code>是基于<strong>链路状态</strong>的,而不像<code>RIP</code>是基于距离向量的</li><li><code>OSPF</code>基于链路状态并采用最短路径算法计算路由,从算法上保证了不会产生路由环路</li><li><code>OSPF</code>不限制网络规模,更新效率高,收敛速度快</li></ul></blockquote><h4 id="3-相关概念">3. 相关概念</h4><ol><li><p>链路状态(<code>Link State,LS</code>)是指本路由器都和哪些路由器相邻,以及相应链路的“代价(cost)”,类似RIP中的距离</p><blockquote><p>“代价”用来表示费用、距离、时延和带宽等,这些都由网络管理人员来决定</p></blockquote></li></ol><img src="https://img2.imgtp.com/2024/04/04/RT6StboJ.png" style="zoom:80%;" alt='举例-思科路由器的代价计算标准' /><ol start="2"><li><strong><code>OSPF</code>路由器邻居关系的建立和维护</strong><ul><li><strong>如果在死亡倒计时为0时还未收到邻居的问候分组,则认为该邻居不可达,</strong></li><li><strong>在接受到邻居的问候分组后,刷新死亡倒计时为40s</strong></li><li><strong>路由器每10s会向邻居发送问候分组</strong></li></ul></li></ol><img src="https://img2.imgtp.com/2024/04/04/8vMlgEEu.png" style="zoom:67%;" /><ol start="3"><li><strong>链路状态数据库</strong>(<code>Link State Database,LSDB</code>)</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/EeKgSYgV.png" alt=""></p><blockquote><p>使用<code>OSPF</code>的各路由器,基于链路状态数据库LSDB进行最短路径优先计算,构建出各自到达其他各路由器的最短路径,即构建各自的路由表(根据链路状态数据库得出全局带权有向图,使用Dijkstra算法得出个路由器的最短路径)</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/5UrNfzxP.png" alt=""></p><ol start="4"><li><strong><code>OSPF</code>的五种分组类型</strong><ul><li>类型1,问候(<code>Hello</code>)分组：用来发现和维护邻居路由器的可达性。</li><li>类型2,数据库描述(<code>Database Description</code>)分组：向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li><li>类型3,链路状态请求(<code>Link State Request</code>)分组：向邻居路由器请求发送某些链路状态项目的详细信息。</li><li>类型4,链路状态更新(<code>Link State Update</code>)分组：路由器使用这种分组将其链路状态进行洪泛发送,即用洪泛法对全网更新链路状态</li><li>类型5,链路状态确认(<code>Link State Acknowledgment</code>)分组：这是对链路状态更新分组的确认分组。</li></ul></li></ol><h4 id="4-基本工作原理">4. 基本工作原理</h4><img src="https://img2.imgtp.com/2024/04/04/BIoaiRjA.png" style="zoom:67%;" /><blockquote><p>采用划分区域的方法,虽然使交换信息的种类增多了,同时也使OSPF协议更加复杂了,但这样做能使每一个区域内部交换路由信息的通信量大大减小,因而使OSPF协议能够用于规模更大的自治系统AS</p></blockquote><img src="https://img2.imgtp.com/2024/04/04/taHfWwBu.png" style="zoom:67%;" /><h3 id="4-13-BGP">4.13  <code>BGP</code></h3><h4 id="1-基本概念-2">1. 基本概念</h4><blockquote><ul><li><strong>边界网关协议</strong>(<code>Border Gateway Protocol,BGP</code>)属于外部网关协议<code>EGP</code>这个类别,用于自治系统<code>AS</code>之间的路由选择协议</li><li>由于在不同AS内度量路由的“代价”(距离、带宽、费用等)可能不同,因此对于AS之间的路由选择,使用统一的“代价”作为度量来寻找最佳路由是不行的</li><li>AS之间的路由选择还必须考虑相关策略(政治、经济、安全等)</li></ul><p><strong>总结：<code>BGP</code>只能是力求寻找一条能够到达目的网络且比较好的路由(即不能兜圈子),而并非要寻找一条最佳路由</strong></p></blockquote><img src="https://img2.imgtp.com/2024/04/04/kc7UmfJ1.png" style="zoom: 80%;" /><blockquote><ul><li><p>在配置BGP时,每个AS的管理员要选择至少一个路由器作为该AS的“BGP发言人”</p></li><li><p>一般来说,两个BGP发言人都是通过一个共享网络连接在一起的,而BGP发言人往往就是BGP边界路由器</p></li><li><p>使用<code>TCP</code>连接交换路由信息的两个BGP发言人,彼此称为对方的邻站(neighbor)或对等站(peer)</p></li><li><p>BGP发言人除了运行BGP协议外,还必须运行自己所在AS所使用的内部网关协议IGP,例如RIP或OSPF</p></li><li><p>BGP发言人交换网络可达性的信息,也就是要到达某个网络所要经过的一系列自治系统</p></li><li><p>当BGP发言人相互交换了网络可达性的信息后,各BGP发言人就根据所采用的策略,从收到的路由信息中找出到达各自治系统的较好的路由,也就是构造出树形结构且不存在环路的自治系统连通图</p></li></ul></blockquote><h4 id="2-四种报文">2. 四种报文</h4><img src="https://img2.imgtp.com/2024/04/04/JlA83rKF.png"  /><img src="https://img2.imgtp.com/2024/04/04/1hHeU3jo.png"  /><h3 id="4-14-ICMP">4.14 <code>ICMP</code></h3><h4 id="1-基本概念-3">1. 基本概念</h4><blockquote><ul><li>为了更有效地转发IP数据报以及提高IP数据报交付成功的机会,TCP/IP体系结构的网际层使用了网际控制报文协议(<code>Internet Control Message Protocol,ICMP</code>)</li><li>主机或路由器使用ICMP来发送差错报告报文和询问报文</li><li>ICMP报文被封装在IP数据报中作为数据载荷发送</li></ul></blockquote><h4 id="2-ICMP报文数据类型">2. ICMP报文数据类型</h4><ul><li><p><strong>差错报告报文</strong>：用来向主机或路由器报告差错情况</p><ul><li><p><strong>终点不可达</strong>：当路由器或主机不能交付IP数据报时,就向源点发送终点不可达报文,具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等13种</p><p><img src="https://img2.imgtp.com/2024/04/04/xmyVOhJp.png" alt=""></p></li><li><p><strong>源点抑制</strong>：当路由器或主机由于拥塞而丢弃IP数据报时,就向发送该IP数据报的源点发送源点抑制报文,使源点知道应当把IP数据报的发送速率放慢</p><img src="https://img2.imgtp.com/2024/04/04/ImvUYf3I.png"  /></li><li><p><strong>超时</strong>：</p><ul><li>当路由器收到一个目的IP地址不是自己的IP数据报时,会将其首部中生存时间TTL字段的值减1。若结果不为0,则路由器将该数据报转发出去；若结果为0,路由器不但要丢弃该数据报,还要向发送该IP数据报的源点发送时间超过(超时)报文</li><li>另外,当终点在预先规定的时间内未能收到一个数据报的全部数据报分片时,就把已收到的数据报片都丢弃,也会向源点发送时间超过(超时)报文</li></ul><img src="https://img2.imgtp.com/2024/04/04/7q3jrjnI.png"  /></li><li><p><strong>参数问题</strong>：当路由器或目的主机收到IP数据报后,根据其首部中的检验和字段的值发现首部在传送过程中出现了误码,就丢弃该数据报,并向发送该数据报的源点发送参数问题报文</p><p><img src="https://img2.imgtp.com/2024/04/04/OJVARiNr.png" alt=""></p></li><li><p><strong>改变路由(重定向)</strong>：路由器把改变路由报文发送给主机,让主机知道下次应将IP数据报发送给另外的路由器,这样可以通过更好的路由到达目的主机</p><p><img src="https://img2.imgtp.com/2024/04/04/iebrHMN6.png" alt=""></p></li></ul></li><li><p><strong>以下情况不应发送ICMP差错报告报文</strong>：</p><ul><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>对第一个分片的IP数据报片的所有后续数据报片都不发送ICMP差错报告报文</li><li>对具有多播地址的IP数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址(例如<code>127.0.0.0</code>或<code>0.0.0.0</code>)的IP数据报不发送ICMP差错报告报文。</li></ul></li><li><p><strong>询问报文</strong>：用来向主机或路由器询问情况</p><ul><li><p><strong>回送请求和回答</strong>：</p><p>由主机或路由器向一个特定的目的主机或路由器发出。收到此报文的主机或路由器必须给发送该报文的源主机或路由器发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态</p></li><li><p><strong>时间戳请求和回答</strong>：</p><p>用来请求某个主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32比特的字段,其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。这种询问报文用来进行时钟同步和测量时间</p></li></ul></li></ul><h4 id="3-ICMP的典型应用">3. ICMP的典型应用</h4><h5 id="1-PING">1. <code>PING</code></h5><blockquote><p>分组网间探测(Packet InterNet Groper,<code>PING</code>)</p><p>在命令行中使用ping命令用来测试主机或路由器之间的连通性</p><ul><li>PING是TCP/IP体系结构的应用层直接使用网际层ICMP的一个例子,它并不使用运输层的TCP或UDP</li><li>PING应用所使用的ICMP报文类型为回送请求和回答</li></ul></blockquote><h5 id="2-traceroute">2. <code>traceroute</code></h5><blockquote><p>跟踪路由应用traceroute,用于探测IP数据报从源主机到达目的主机要经过哪些路由器</p><p>在不同操作系统中,traceroute应用的命令和实现机制有所不同：</p><ul><li>在UNIX版本中,具体命令为<code>traceroute</code>,其在运输层使用UDP协议,在网络层使用ICMP报文类型只有差错报告报文</li><li>在Windows版本中,具体命令为<code>tracert</code>,其应用层直接使用网际层的ICMP协议,所使用的ICMP报文类型有回送请求和回答报文以及差错报告报文</li></ul><p><strong>原理</strong>：设置IP数据报TTL为1,经过第一个路由器时,TTL减为0,IP数据报被丢弃,路由器向源主机发送超时差错报告报文,这样就知道了经过的第一个路由器的IP地址,以此类推依次设置TTL为2,3,4,……,直到接收到目的主机的回送请求回答报文</p></blockquote><h3 id="4-15-VPN">4.15 <code>VPN</code></h3><blockquote><p>虚拟专用网(<code>Virtual Private Network,VPN</code>)：<strong>利用公用的因特网作为本机构各专用网之间的通信载体,这样形成的网络又称为虚拟专用网</strong></p></blockquote><p><strong>专用地址</strong>：</p><ul><li><code>10.0.0.0-10.255.255.255</code>(CIDR地址块10/8)</li><li><code>172.16.0.0-172.31.255.255</code>(ClDR地址块172.16/12)</li><li><code>192.168.0.0-192.168.255.255</code>(CIDR地址块192.168/16)</li></ul><blockquote><p>很显然,全世界可能有很多不同机构的专用网具有相同的专用IP地址,但这并不会引起麻烦,因为这些专用地址仅在机构内部使用</p><p><strong>注意</strong>：在因特网中的所有路由器,对目的地址是专用地址的IP数据报一律不进行转发,这需要由因特网服务提供者ISP对其拥有的因特网路由器进行设置来实现(需要自己对路由器额外配置)</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/x4VahylJ.png" alt=""></p><h3 id="4-16-NAT">4.16 <code>NAT</code></h3><h4 id="1-概述-2">1. 概述</h4><blockquote><ul><li><p><strong>背景</strong>：尽管因特网采用了无分类编址方法来减缓IPv4地址空间耗尽的速度,但由于因特网用户数量的急剧增长,特别是大量小型办公室和家庭网络接入因特网的需求不断增加,IPv4地址空间即将耗尽的危险然仍没有解除(实际上,因特网号码分配管理局IANN于2011年2月3日宣布,IPv4地址已经分配完毕)</p></li><li><p><strong>网络地址转换</strong>(<code>Network Address Translation,NAT</code>)技术于1994年被提出,用来缓解IPv4地址空间即将耗尽的问题</p><ul><li>NAT能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源</li><li>这种方法需要在专用网络连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器称为NAT路由器,它至少要有一个有效的外部全球地址IPG。这样,所有使用内部专用地址的主机在和外部因特网通信时,都要在NAT路由器上将其内部专用地址转换成IPG</li></ul></li></ul></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/jGM9Vzo8.png" alt=""></p><h4 id="2-NAPT">2. <code>NAPT</code></h4><blockquote><p><strong>网络地址与端口号转换方法</strong>:将NAT和运输层端口号结合使用,称为网络地址与端口号转换(<code>Network Address and Port Translation,NAPT</code>)</p><ul><li>由于目前绝大多数基于TCP/IP协议栈的网络应用,都使用运输层的传输控制协议TCP或用户数据报协议UDP,为了更加有效地利用NAT路由器中的全球IP地址,现在常将NAT转换和运输层端口号结合使用<ul><li>这样就可以使内部专用网中使用专用地址的大量主机,共用NAT路由器上的1个全球IP地址,因而可以同时与因特网中的不同主机进行通信</li><li>现在很多家用路由器将家中各种智能设备(手机、平板、笔记本电脑、台式电脑、物联网设备等)接入因特网,这种路由器实际上就是一个NAPT路由器,但往往并不运行路由选择协议</li></ul></li></ul></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/pXcz3mVQ.png" alt=""></p><blockquote><p>由于NAT对外网屏蔽了内网主机的网络地址,能为内网的主机提供一定的安全保护</p></blockquote><h3 id="5-思维导图和习题">5. 思维导图和习题</h3><p><a href="https://www.kdocs.cn/view/l/ceLxGZ0br8Gy">第4章 网络层(思维导图)-1 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cu2tek1gzIPq">第4章 网络层(思维导图)-2 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cjXVALCjxr0X">第4章 网络层(思维导图)-3 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cbSlBNdR8CSr">第4章 网络层(思维导图)-4 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/ccu9ATsOpoZf">第4章 网络层 习题(第1部分)</a></p><p><a href="https://www.kdocs.cn/view/l/cqBldcygudFg">第4章 网络层 习题(第2部分)</a></p><hr><h2 id="5-运输层">5. 运输层</h2><h3 id="1-概述-3">1. 概述</h3><ul><li>第2~4章依次介绍了计算机网络体系结构中的物理层、数据链路层和网络层,它们共同解决了将主机通过异构网络互联起来所面临的问题,实现了主机到主机的通信</li><li>然而在计算机网络中实际进行通信的真正实体,是位于通信两端主机中的进程</li><li>如何<strong>为运行在不同主机上的应用进程提供直接的逻辑通信服务</strong>,就是运输层的主要任务,运输层协议又称为端到端协议</li></ul><p><img src="https://img2.imgtp.com/2024/04/04/D2rQouVM.png" alt=""></p><h3 id="2-端口号-复用和分用">2. 端口号,复用和分用</h3><h4 id="1-运输层端口号">1. 运输层端口号</h4><ul><li>运行在计算机上的进程是使用进程标识符(<code>P</code>rocess <code>ld</code>entification,<code>PID</code>)来标识的。<ul><li>然而,因特网上的计算机并不是使用统一的操作系统,而不同操作系统(Windows、Linux、.MacOS)<br>又使用不同格式的进程标识符</li><li>为了使运行不同操作系统的计算机的应用进程之间能够基于网络进行通信,就必须使用统一的方法<br>对TCPP体系的应用进程进行标识</li></ul></li><li><code>TCP/IP</code>体系结构的运输层使用端口号来标识和区分应用层的不同应用进程。端口号的长度为6比特,取<br>值范围是0~65535</li></ul><img src="https://img2.imgtp.com/2024/04/04/LEoAKn42.png" style="zoom:100%;" /><blockquote><p><strong>端口号只具有本地意义,即端口号只是为了标识本计算机网络协议栈应用层中的各应用进程。在因特网中,不同计算机中的相同端口号是没有关系的,即相互独立。另外,<code>TCP</code>和<code>UDP</code>端口号之间也是没有关系的</strong></p></blockquote><h4 id="2-发送方的复用和接收方的分用">2. 发送方的复用和接收方的分用</h4><ol><li><strong>复用(Multiplexing)：</strong><ul><li><strong>定义：</strong> 复用是指将多个应用程序的数据流合并到一个共享的通信通道上</li><li><strong>TCP中的复用：</strong> 在TCP中,复用通过源端口号来实现。TCP连接的两端使用IP地址和端口号来唯一标识。源端口号表示发送端的应用程序,目的端口号表示接收端的应用程序。这样,在单个TCP连接中,多个应用程序的数据可以共享同一个物理通信通道</li><li><strong>UDP中的复用：</strong> 在UDP中,复用同样通过源端口号来实现。UDP报文的源端口号用于标识发送端的应用程序,目的端口号用于标识接收端的应用程序</li></ul></li><li><strong>分用(Demultiplexing)：</strong><ul><li><strong>定义：</strong> 分用是指根据数据流中的标识信息将合并的数据流分发给正确的应用程序</li><li><strong>TCP中的分用：</strong> 在TCP中,分用通过目的端口号来实现。接收端根据目的端口号将接收到的数据分发给相应的应用程序。这样,TCP层能够将数据正确地传递给目标应用程序</li><li><strong>UDP中的分用：</strong> 在UDP中,同样通过目的端口号来实现分用。接收端通过目的端口号确定应该将数据交付给哪个应用程序</li></ul></li></ol><p><img src="https://img2.imgtp.com/2024/04/04/HKhQUmCb.png" alt=""></p><blockquote><p>常见协议的分类</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/ioR9SdPa.png" alt=""></p><p><strong><a href='https://www.bilibili.com/video/BV1c4411d7jb?t=353.6&p=58'>运输层端口号应用举例</a></strong></p><h3 id="3-TCP和UDP的对比">3.  <code>TCP</code>和<code>UDP</code>的对比</h3><p><img src="https://img2.imgtp.com/2024/04/04/8ufoDA1F.png" alt=""></p><p><strong>注意</strong>：</p><ul><li>TCP面向连接是逻辑连接,并非真实物理连接</li><li>TCP面向字节流,UDP面向应用报文(只是给数据报添加一个UDP首部)</li><li>TCP只支持单播,UDP支持单播、多播和广播</li><li>TCP提供可靠服务,UDP提供不可靠服务</li></ul><h3 id="4-TCP的流量控制">4. TCP的<strong>流量控制</strong></h3><h4 id="1-概述-4">1. 概述</h4><blockquote><p>TCP为应用程序提供了流量控制(<code>Flow Control</code>)机制,以解决因发送方发送数据太快而导致接收方来不及接收,造成接收方的接收缓存溢出的问题</p><p>**流量控制的基本方法：**接收方根据自己的接收能力(接收缓存的可用空间大小)控制发送方的发送速率</p></blockquote><h4 id="2-a-href-https-www-bilibili-com-video-BV1c4411d7jb-t-44-1-p-60-流量控制方法-a">2. <a href='https://www.bilibili.com/video/BV1c4411d7jb?t=44.1&p=60'>流量控制方法</a></h4><ol><li><strong>流程</strong></li></ol><p><img src="https://img2.imgtp.com/2024/04/04/W4mjWAtQ.png" alt=""></p><p><img src="https://img2.imgtp.com/2024/04/04/3DCPrqks.png" alt=""></p><ol start="2"><li><p>例题</p><p><img src="https://img2.imgtp.com/2024/04/04/eYiMYvRR.png" alt=""></p></li></ol><h3 id="5-TCP的拥塞-se-控制">5. TCP的<strong>拥塞(se)控制</strong></h3><h4 id="1-基本概念-4">1. 基本概念</h4><img src="https://img2.imgtp.com/2024/04/04/xL1bNfCp.png" /><h4 id="2-4种拥塞控制方法">2. 4种拥塞控制方法</h4><p><img src="https://img2.imgtp.com/2024/04/04/v0EQTjNj.png" alt=""></p><h5 id="1-慢开始、拥塞避免">1. 慢开始、拥塞避免</h5><p><img src="https://img2.imgtp.com/2024/04/04/1mqfBCfM.png" alt=""></p><h5 id="2-快重传、快恢复">2. 快重传、快恢复</h5><blockquote><p><font>快重传算法</font>和快恢复算法(改进TCP性能,1990年Reno版本)</p></blockquote><ol><li>问题</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/MiKI7G2d.png" alt=""></p><ol start="2"><li><p><strong>快重传</strong></p><ul><li><strong>采用快重传算法可以让发送方尽早知道发生了个别TCP报文段的丢失</strong></li><li>“快重传”是指<strong>使发送方尽快(尽早)进行重传,而不是等重传计时器超时再重传</strong><ul><li>这就要求接收方不要等待自己发送数据时才进行捎带确认,而是要立即发送确认,即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认</li><li>发送方一旦收到3个连续的重复确认,就将相应的报文段立即重传,而不是等该报文段的重传计时器超时再重传</li></ul></li></ul><p><img src="https://img2.imgtp.com/2024/04/04/xkVEdIRO.png" alt=""></p></li><li><p><strong>快恢复</strong></p></li></ol><blockquote><p>与快重传算法配合使用的是<strong>快恢复算法</strong>,发送方一旦收到3个重复确认,就知道现在只是丢失了个别的报文段,于是不启动慢开始算法,<strong>而是执行快恢复算法</strong></p><ul><li><strong>快恢复算法：<strong>发送方将慢开始门限ssthresh的值和拥塞窗口cwnd的值</strong>都调整为当前cwnd值的一半</strong>,并开始执行拥塞避免算法</li><li>也有的快恢复实现是把快恢复开始时的cwnd值再增大一些,即cwnd=新ssthresh+3</li></ul></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/qO3uhLLl.png" alt=""></p><h3 id="6-TCP超时重传时间的选择">6. TCP超时重传时间的选择</h3><blockquote><p><strong>TCP超时重传时间RTO的选择是TCP最复杂的问题之一</strong></p><p>问题：</p><ul><li>超时重传时间设置过小,在确认报文段发送给接收方的过程中,发送方重传数据报文,增大了网络负荷</li><li>超时重传时间设置过大,需要重传数据报文时,推迟时间太长,网络空闲时间大,降低了传输效率</li><li>超时重传时间<code>RTO</code>应略大于往返时间<code>RTT</code></li></ul></blockquote><h4 id="RTO的选择"><strong>RTO的选择</strong></h4><h5 id="1-RTTs的计算">1. RTTs的计算</h5><p><img src="https://img2.imgtp.com/2024/04/04/UDFqDvXR.png" alt=""></p><h5 id="2-RRTd和RTO的计算">2. RRTd和RTO的计算</h5><p><img src="https://img2.imgtp.com/2024/04/04/HY1BAdru.png" alt=""></p><h4 id="发生超时重传时无法测准RTT">发生超时重传时无法测准RTT</h4><p><img src="https://img2.imgtp.com/2024/04/04/yNzUzb2Y.png" alt=""></p><blockquote><p><strong>通过上述两个例子可以看出：当发送方出现超时重传后,收到确认报文段时是无法判断出该确认到底是对原数据报文段的确认还是对重传数据报文段的确认,也就是无法准确测量出RTT,进而无法正确计算RTO</strong></p></blockquote><h5 id="Karn算法及修正">Karn算法及修正</h5><p><img src="https://img2.imgtp.com/2024/04/04/AwbzanjU.png" alt=""></p><h5 id="总结">总结</h5><p><img src="https://img2.imgtp.com/2024/04/04/xrIJQlOc.png" alt=""></p><h3 id="7-TCP可靠传输的实现">7.TCP可靠传输的实现</h3><ul><li><strong>TCP的窗口以字节为单位</strong></li></ul><p><img src="https://img2.imgtp.com/2024/04/04/YjEPy8k0.png" alt=""></p><ul><li>发送方<ul><li>发送窗口内的已发送数据如果迟迟未收到确认,会发生超时重传</li><li>只有处于发送窗口内的数据才能发送</li></ul></li></ul><p><img src="https://img2.imgtp.com/2024/04/04/fR0t7TXv.png" alt=""></p><ul><li>接收方<ul><li>接收方<strong>只能对按序收到的数据中的最高序号给出累计确认</strong>,3次重复确认会导致发送方<strong>快重传</strong></li><li><strong>序号落入接收窗口内的数据是允许接收的数据</strong></li></ul></li></ul><p><img src="https://img2.imgtp.com/2024/04/04/i29w36GO.png" alt=""></p><ul><li><strong>总结</strong></li></ul><p><img src="https://img2.imgtp.com/2024/04/04/or468nHg.png" alt=""></p><h3 id="8-TCP的运输连接管理">8. TCP的运输连接管理</h3><h4 id="1-TCP连接的建立">1. TCP连接的建立</h4><p><img src="https://img2.imgtp.com/2024/04/04/J2XMeS5i.png" alt=""></p><blockquote><p>TCP双方连接的建立要解决的三个问题</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/unn0sUEo.png" alt=""></p><h4 id="2-三报文握手">2. 三报文握手</h4><p><img src="https://img2.imgtp.com/2024/04/04/LViPPUEp.png" alt=""></p><blockquote><p><strong>思考：第三次确认是否多余,能不能两报文握手？</strong></p><p>答案：不能,如下图所示</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/ubh3gJLp.png" alt=""></p><h4 id="3-四报文挥手">3. 四报文挥手</h4><p><img src="https://img2.imgtp.com/2024/04/04/80yAaiIl.png" alt=""></p><blockquote><p><strong>思考：为什么客户端发送完最后一个确认报文段后不立刻关闭而是等待2个MSL时间后才关闭？</strong></p><p>答案：如图所示</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/G3BFV47H.png" alt=""></p><blockquote><p>TCP保活计时器的作用</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/xivu7oAV.png" alt=""></p><h3 id="9-TCP报文段首部格式">9. TCP报文段首部格式</h3><blockquote><p>参阅思维导图 1</p></blockquote><h3 id="10-思维导图和习题">10. 思维导图和习题</h3><p><a href="https://www.kdocs.cn/view/l/cgoja6Lpohhj">第5章 运输层(思维导图)-1 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/chkSS9vn9Zgd">第5章 运输层(思维导图)-2 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cpaRQtp0G6Ou">第5章 运输层 习题 (kdocs.cn)</a></p><hr><h2 id="6-应用层">6. 应用层</h2><h3 id="1-概述-5">1. 概述</h3><ul><li>应用层是计算机网络体系结构的<strong>最顶层</strong>,是<strong>设计和建立计算机网络的最终目的</strong>,也是计算机网络中发展最快的部分<ul><li>早期基于文本的应用(电子邮件、远程登录、文件传输、新闻组)</li><li>20世纪90年代将因特网带入千家万户的万维网WWW</li><li>当今流行的即时通信、P2P文件共享及各种音视频应用</li><li>计算设备的小型化和“无处不在”,宽带住宅接入和无线接入的日益普及和迅速发展,为未来更多的新型应用提供了广阔的舞台</li></ul></li></ul><h3 id="2-客户服务器和对等方式">2. 客户服务器和对等方式</h3><h4 id="1-C-S方式">1. <code>C/S</code>方式</h4><p><img src="https://img2.imgtp.com/2024/04/04/N4aLVqmQ.png" alt=""></p><p><img src="https://img2.imgtp.com/2024/04/04/lXMm63X5.png" alt=""></p><h4 id="2-P2P方式">2. <code>P2P</code>方式</h4><p><img src="https://img2.imgtp.com/2024/04/04/Vj0hHf1g.png" alt=""></p><p><img src="https://img2.imgtp.com/2024/04/04/yAx2AVuq.png" alt=""></p><h3 id="4-DNS">4. <code>DNS</code></h3><blockquote><p><strong>域名系统</strong>(<code>D</code>omain <code>N</code>ame <code>S</code>ystem,<code>DNS</code>)</p></blockquote><h4 id="1-域名系统的作用">1. 域名系统的作用</h4><p><img src="https://img2.imgtp.com/2024/04/04/gBFxses1.png" alt=""></p><p><img src="https://img2.imgtp.com/2024/04/04/x1tUx2vm.png" alt=""></p><h4 id="2-因特网的域名结构">2. 因特网的域名结构</h4><blockquote><p>因特网采用<strong>层次树状结构的域名结构</strong></p></blockquote><h5 id="1-域名规范">1. 域名规范</h5><p><img src="https://img2.imgtp.com/2024/04/04/AoFgDCmt.png" alt=""></p><h5 id="2-不同国家的域名">2. 不同国家的域名</h5><p><img src="https://img2.imgtp.com/2024/04/04/6WUpB9Oh.png" alt=""></p><h5 id="3-因特网的域名空间">3. 因特网的域名空间</h5><p><img src="https://img2.imgtp.com/2024/04/04/rBS3t5ef.png" alt=""></p><h4 id="3-域名服务器">3. 域名服务器</h4><p><img src="https://img2.imgtp.com/2024/04/04/zLHYxWek.png" alt=""></p><h4 id="4-域名解析">4. 域名解析</h4><h5 id="1-递归查询">1. 递归查询</h5><p><img src="https://img2.imgtp.com/2024/04/04/FpBrwNqb.png" alt=""></p><h5 id="2-迭代查询">2. 迭代查询</h5><p><img src="https://img2.imgtp.com/2024/04/04/nQ6sAl2O.png" alt=""></p><h5 id="3-高速缓存">3. 高速缓存</h5><p><img src="https://img2.imgtp.com/2024/04/04/pcwXhKnx.png" alt=""></p><p><img src="https://img2.imgtp.com/2024/04/04/8BLUzbFZ.png" alt=""></p><h3 id="5-FTP">5. <code>FTP</code></h3><blockquote><p><strong>文件传送协议</strong>(<code>F</code>ile <code>T</code>ransfer <code>P</code>rotocol,<code>FTP</code>)</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/83gndWFQ.png" alt=""></p><blockquote><p><strong>基本工作原理</strong></p></blockquote><ol><li>主动模式</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/zIeZrtFX.png" alt=""></p><ol start="2"><li>被动模式</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/Gm7FBUWz.png" alt=""></p><h3 id="6-电子邮件">6. 电子邮件</h3><h4 id="1-E-mail">1. <code>E-mail</code></h4><p><img src="https://img2.imgtp.com/2024/04/04/dRoMrTBk.png" alt=""></p><h4 id="2-电子邮件系统的组成">2. 电子邮件系统的组成</h4><p><img src="https://img2.imgtp.com/2024/04/04/bK0zdDmM.png" alt=""></p><h4 id="3-邮件发送和接收过程">3. 邮件发送和接收过程</h4><p><img src="https://img2.imgtp.com/2024/04/04/D9l7k3yg.png" alt=""></p><h4 id="4-SMTP">4. <code>SMTP</code></h4><blockquote><p>简单邮件传送协议(Simple Mail Transfer Protocol,<code>SMTP</code>)的基本工作过程</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/DMl68A1m.png" alt=""></p><h4 id="5-电子邮件的信息格式">5. 电子邮件的信息格式</h4><p><img src="https://img2.imgtp.com/2024/04/04/mMKxiFqt.png" alt=""></p><h4 id="6-MIME">6. <code>MIME</code></h4><blockquote><p><strong>多用途因特网邮件扩展</strong> (Multipurpose Internet Mail Extensions,<code>MIME</code>)</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/l34rdKif.png" alt=""></p><blockquote><p><strong><code>MIME</code>对邮件内容中的非ASCII字符转换成ASCII字符</strong></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/GwUXUJEh.png" alt=""></p><h4 id="7-常用邮件读取协议">7. 常用邮件读取协议</h4><blockquote><p><strong>邮局协议</strong>(Post Office Protocol,<code>POP</code>)</p><p><strong>因特网邮件访问协议</strong>(Internet Message Access Protocol,<code>IMAP</code>)</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/2e8zsrXX.png" alt=""></p><h4 id="8-基于万维网的电子邮件">8. 基于万维网的电子邮件</h4><p><img src="https://img2.imgtp.com/2024/04/04/qYWywPpx.png" alt=""></p><h3 id="7-万维网">7. 万维网</h3><h4 id="1-概述-6">1. 概述</h4><blockquote><ul><li><strong>万维网</strong>(World Wide Web,<code>WWW</code>)并非某种特殊的计算机网络。它是一个大规模的、联机式的信息储藏所,是运行在因特网上的一个分布式应用</li><li>万维网利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网</li><li>万维网是欧洲粒子物理实验室的Tim Berners-Lee最初于1989年3月提出的</li></ul></blockquote><h4 id="2-URL">2. <code>URL</code></h4><blockquote><p>统一资源定位符(<code>U</code>niform <code>R</code>esource <code>L</code>ocator)</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/pQNu9Io6.png" alt="image-20231205094301978"></p><h4 id="3-万维网文档">3. 万维网文档</h4><p><img src="https://img2.imgtp.com/2024/04/04/MEItS0Eb.png" alt=""></p><h4 id="4-HTTP">4. <code>HTTP</code></h4><h5 id="1-概述-7">1. 概述</h5><blockquote><p><strong>超文本传输协议</strong><code>HTTP</code>(HyperText Transfer Protocol)</p><p>HTTP定义了<strong>浏览器(即万维网客户进程)怎样向万维网服务器请求万维网文档,以及万维网服务器怎样把万维网文档传送给浏览器</strong></p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/MilI8kKE.png" alt=""></p><h5 id="2-报文格式">2. 报文格式</h5><ul><li>请求报文格式</li></ul><p><img src="https://img2.imgtp.com/2024/04/04/lj3eU4LR.png" alt=""></p><ul><li>响应报文格式</li></ul><p><img src="https://img2.imgtp.com/2024/04/04/8CMJ8OdG.png" alt=""></p><h4 id="5-Cookie">5. <code>Cookie</code></h4><ul><li>早期的万维网应用非常简单,仅仅是用户查看存放在不同服务器上的各种静态的文档。因此HTTP被设计为一种无状态的协议。这样可以简化服务器的设计</li><li>现在,用户可以通过万维网进行各种复杂的应用,如网上购物、电子商务等。这些应用往往需要万维网服务器能够识别用户</li><li>Cookie提供了一种机制使得万维网服务器能够“记住”用户,而无需用户主动提供用户标识信息。也就是说,Cookie是一种对无状态的HTTP进行状态化的技术</li></ul><p><img src="https://img2.imgtp.com/2024/04/04/jdF402Xf.png" alt=""></p><h4 id="6-万维网缓存与代理服务器">6. 万维网缓存与代理服务器</h4><p><img src="https://img2.imgtp.com/2024/04/04/TH8yLUXM.png" alt=""></p><h4 id="7-思维导图和相关习题">7. 思维导图和相关习题</h4><p><a href="https://www.kdocs.cn/view/l/cle5dxMBHZIH">第6章 应用层(思维导图)-1 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cabHsokbKiNO">第6章 应用层(思维导图)-2 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cv9vfzDopPvi">第6章 应用层 习题 (kdocs.cn)</a></p><hr><h2 id="计算机网络相关术语"><em>计算机网络相关术语</em></h2><p><strong>ACK</strong> (Acknowledgement) 确认</p><p><strong>ADSL</strong> (Asymmetric Digital Subscriber Line) 非对称数字用户线</p><p><strong>AP</strong> (Access Point) 接入点</p><p><strong>AP</strong> (Application) 应用程序</p><p><strong>API</strong> (Application Programming Interface) 应用编程接口</p><p><strong>APNIC</strong> (Asia Pacific Network Information Centre) 亚太网络信息中心</p><p><strong>ARIN</strong> (American Registry for Internet Numbers) 美国因特网号码注册机构</p><p><strong>ARP (Address Resolution Protocol) 地址解析协议</strong></p><p><strong>ARPA</strong> (Advanced Research Projects Agency) 美国国防部远景研究规划局 (高级研究计划署)</p><p><strong>ARQ</strong> (Automatic Repeat-request) 自动重传请求</p><p><strong>AS</strong> (autonomous system) 自制系统</p><p><strong>BGP</strong> (Border Gateway Protocol ) 边界网关协议</p><p><strong>BOOTP</strong> (Bootstrap Protocol) 引导程序协议</p><p><strong>BSA</strong> (Basic Service Area) 基本服务区</p><p><strong>BT</strong> (Bit Torrent) 一种P2P程序</p><p><strong>CA</strong> (Certificate Authority) 认证中心</p><p><strong>CA</strong> (Collision Avoidance) 碰撞避免</p><p><strong>CATV</strong> ( Community Antenna Television) 有线电视</p><p><strong>CDM</strong> (Code Division Multiplexing) 码分复用</p><p><strong>CDMA</strong> (Code Division Multiple Access) 码分多址</p><p><strong>CGI</strong>  (Common Gateway Interface) 通用网关接口</p><p><strong>CIDR</strong> (Classless Inter-Domain Routing) 无分类域间路由选择</p><p><strong>CRC</strong> (Cyclic Redundancy Check) 循环冗余校验</p><p><strong>CSMA/CD</strong> (Carrier Sense Multiple Access/Collision Detect) 载波监听 多址接入/碰撞检测</p><p><strong>CSMA/CA</strong> (Carrier Sense Multiple Access with Collision Avoidance)  载波监听多点接入/冲突避免</p><p><strong>CTS</strong> (Clear To Send) 允许发送</p><p><strong>DACS</strong> (Digital Access and Cross-connect System) 数字交接系统</p><p><strong>DHCP (Dynamic Host Configuration Protocol) 动态主机配置协议</strong></p><p><strong>DiffServ (Differentiated Services) 区分服务</strong></p><p><strong>DLCI</strong> (Data Link Connection Identifier) 数据链路连接标识符</p><p><strong>DMT</strong> (Discrete Multi-Tone) 离散多音 (调制)</p><p><strong>DNS</strong> (Domain Name System) 域名系统</p><p><strong>DoS</strong> (Denial of Service) 拒绝服务</p><p><strong>DS</strong> (Distribution System) 分配系统</p><p><strong>DSL</strong> (Digital Subscriber Line) 数字用户线</p><p><strong>DSLAM</strong> ( DSL Access Multiplexer) 数字用户线接入复用器</p><p><strong>DSSS</strong> (Direct Sequence Spread Spectrum) 直接序列扩频</p><p><strong>EFM</strong> (Ethernet in the First Mile ) 第一英里的以太网</p><p><strong>EFPHB</strong> (Expedited Forwarding Per-Hop Behavior) 迅速转发每跳行为</p><p><strong>EGP</strong> (Exterior Gateway Protocol) 外部网关协议</p><p><strong>EIA</strong> (Electronic Industries Association) 美国电子工业协会</p><p><strong>FCS</strong> (Frame Check Sequence) 帧检验序列</p><p><strong>FDDI</strong> (fiber-distributed data interface) 光纤分布式数据接口</p><p><strong>FDM</strong> (Frequency-division multiplexing) 频分复用</p><p><strong>FEC</strong> (Forwarding Equivalence Class) 转发等价类</p><p><strong>FFD</strong> (Full-Function Device) 全功能设备</p><p><strong>FHSS</strong> (Frequency-Hopping Spread Spectrum) 跳频扩频</p><p><strong>FIFO</strong> (First In First Out) 先进先出</p><p><strong>FQ</strong> (Fair Queuing) 公平排队</p><p><strong>FTP (File Transfer Protocol) 文件传输协议</strong></p><p><strong>GIF</strong> (Graphics System for Mobile) 全球移动通信系统,GSM体制</p><p><strong>HDLC</strong> ( High-Level Data Link Control) 高级数据链路控制</p><p><strong>HDSL</strong> (High-speed DSL) 高速数字用户线</p><p><strong>HSSG</strong> (High Speed Study Group) 高速研究组</p><p><strong>HTML</strong> (Hyper Text Markup Language) 超文本标记语言</p><p><strong>HTTP (Hyper Text Transfer Protocol) 超文本传送协议</strong></p><p><strong>IAB</strong> (Internet Architecture Board) 因特网体系结构委员</p><p><strong>IANA</strong> (Internet Assigned Numbers Authority) 因特网赋号管理局</p><p><strong>ICMP (Internet Control Message Protocol) 网际控制报文协议</strong></p><p><strong>IEEE</strong> (Institute of Electrical and Electronic Engineering) (美国) 电气和电子工程师学会</p><p><strong>IFS</strong> (Inter Frame Space) 帧间间隔</p><p><strong>IGMP</strong> (Internet Group Management Protocol) 网际组管理协议</p><p><strong>IGP</strong> (Interior Gateway Protocol) 内部网关协议</p><p><strong>IM</strong> (Instant Messaging) 及时传信</p><p><strong>IMAP ( Internet Message Access Protocol) 因特网报文存取协议</strong></p><p><strong>IntServ</strong> (Integrated Services) 综合服务</p><p><strong>IP (Internet Protocol) 网际协议</strong></p><p><strong>IPCP</strong> (IP Control Protocol) IP控制协议</p><p><strong>IPng</strong> (IP Next Protocol) 下一代IP</p><p><strong>IPsec</strong> (IP security) IP安全协议</p><p><strong>ISDN</strong> (Internet Services Digital Network) 综合业务数字网</p><p><strong>ISO</strong> (International Organization for Standardization ) 国际标准化组织</p><p><strong>ISOC</strong> (Internet Society) 因特网协会</p><p><strong>ISP</strong> (Internet Service Provider) 因特网服务提供者</p><p><strong>LAN</strong> (Local Area Network) 局域网</p><p><strong>LCP</strong> (Link Control Protocol) 链路控制协议</p><p><strong>LDP</strong> (Label Distribution Protocol) 标记分配协议</p><p><strong>LLC</strong>(Logical Link Control) 逻辑链路控制</p><p><strong>LSR</strong>(Label Switched Router) 标记交换路由器</p><p><strong>MAC</strong>(Medium Access Control) 媒体接入控制</p><p><strong>MACA</strong>(Multiple Access with Collision Avoidance)具有碰撞避免的多点接入</p><p><strong>MAN</strong>(Metropolitan Area Network) 城域网</p><p><strong>MBONE</strong>(Multicast Backbone On the InterNet) 多播主干网</p><p><strong>MCU</strong>(Multipoint Control Unit) 多点控制单元</p><p><strong>MD</strong>(Message Digest) 报文摘要</p><p><strong>MF</strong>(More Fragment) 还有分片</p><p><strong>MRU</strong>(Maximum Receive Unit) 最大接收单元</p><p><strong>MSS</strong>(Maximum Segment Size) 最长报文段</p><p><strong>MTU</strong>(Maximum Transfer Unit) 最大传送单元</p><p><strong>NAP</strong>(Network Access Point)　网络接入点</p><p><strong>NAT</strong>(Network Address Translation) 网络地址转换</p><p><strong>NAV</strong>(Network Allocation Vector) 网络分配向量</p><p><strong>NCP</strong>(Network Control Protocol) 网络控制协议</p><p><strong>NFS</strong>(Network File System) 网络文件系统</p><p><strong>NOC</strong>(Network Operations Center) 网络运行中心</p><p><strong>NSAP</strong>(Network Service Access Point) 网络层服务访问点</p><p><strong>NSF</strong>(National Service Foundation) (美国)国家科学基金会</p><p><strong>OFDM</strong>(Orthogonal Frequency Division Multiplexing) 正交频分复用</p><p><strong>OSI/RM</strong> (Open Systems Interconnection Reference Model) 开发系统互连基本参考模型</p><p><strong>OSPF(Open Shortest Path First) 开放最短通路优先</strong></p><p><strong>P2P</strong>(Peer-to-Peer) 对等方式</p><p><strong>PAN</strong>(Personal Area Network) 个人区域网</p><p><strong>PAP</strong>(Password Authentication Protocol) 口令鉴别协议</p><p><strong>PCA</strong>(Policy Certification Authority) 政策认证中心</p><p><strong>PCF</strong>(Point Coordination Function) 点协调功能</p><p><strong>PCM</strong>(Pulse Code Modulation) 脉码调制</p><p><strong>PEM</strong>(Privacy Enhanced Mail) 因特网的正式邮件加密标准</p><p><strong>PGP</strong>(Pretty Good Privacy) 一种电子邮件的机密标准</p><p><strong>PHB</strong>(Per-Hop Behavior) 每跳行为</p><p><strong>PIFS</strong>(Point Coordination Function IFS) 点协调功能帧间间隔</p><p><strong>PK</strong>(public key) 公钥,公开密钥</p><p><strong>PoP</strong>(Point of Presence) 汇接点</p><p><strong>POP</strong>(Post Office Protocol) 邮局协议</p><p><strong>PPP(Point-to-Point Protocol) 点对点协议</strong></p><p><strong>PPPoE</strong>(Point-to-Point Protocol over Ethernet) 以太网上的点对点协议</p><p><strong>QAM</strong>(Quadrature Amplitude Modulation) 正交幅度调制</p><p><strong>QoS</strong>(Quality of Service)　服务质量</p><p><strong>QPSK</strong>(Quarternary Phase Shift Keying)正交相移键控</p><p><strong>RARP</strong>(Reverse Address Resolution Protocol)逆地址解析协议</p><p><strong>RFD</strong>(Reduced-Function Device)精简功能设备</p><p><strong>RG</strong>(Research Group)研究组</p><p><strong>RIP(Routing Information Protocol)路由信息协议</strong></p><p><strong>RIPE</strong>(法文表示的European IP Network)欧洲的IP 网络</p><p><strong>RTP</strong>(Real-Time Transfer Protocol)实时传送协议</p><p><strong>RTSP</strong>(Real-Time Streaming Protocol)实时流式协议</p><p><strong>RTT</strong>(Round-Trip Time)往返时间</p><p><strong>SA</strong>(Security Association)安全关联</p><p><strong>SACK</strong>(Selective ACK)选择确认</p><p><strong>SAP</strong>(Service Access Point)服务访问点</p><p><strong>SCTP</strong>(Stream Control Transmission Protocol)流控制传输协议</p><p><strong>SDH</strong>(Synchronous Digital Hierarchy)同步数字系列</p><p><strong>SMI</strong>(Structure of Management Information)管理信息结构</p><p><strong>SMTP(Simple Mail Transfer Protocol)简单邮件传送协议</strong></p><p><strong>SNA</strong>(System Network Architecture)系统网络体系结构</p><p><strong>SNMP</strong>(Simple Network Management Protocol)简单网络管理协议</p><p><strong>SOH</strong>(Start Of Header)首部开始</p><p><strong>SONET</strong>(Synchronous Optical Network)同步光纤网</p><p><strong>STDM</strong>(Statistic TDM)统计时分复用</p><p><strong>STM</strong>(Synchronous Transfer Module)同步传递模块</p><p><strong>STS</strong>(Synchronous Transport Signal)同步传送信号</p><p><strong>TAG</strong>(TAG Switching)标记交换</p><p><strong>TCB</strong>(Transmission Control Block)传输控制程序块</p><p><strong>TCP(Transmission Control Protocol)传输控制协议</strong></p><p><strong>TDM</strong>(Time Division Multiplexing)时分复用</p><p><strong>TELNET</strong>(TELetype NETwork)电传机网络,一种因特网的应用程序</p><p><strong>TFTP</strong>(Trivial File Transfer Protocol)简单文件传送协议</p><p><strong>TIA</strong>(Telecommunications Industries Association)电信行业协会</p><p><strong>TLD</strong>(Top Level Domain)顶级域名</p><p><strong>TLI</strong>(Transport Layer Interface)运输层接口</p><p><strong>TLS</strong>(Transport Layer Security)运输层安全协议</p><p><strong>TLV</strong>(Type-Length-Value)类型-长度-值</p><p><strong>TPDU</strong>(Transport Protocol Data Unit)运输协议数据单元</p><p><strong>UDP(User Datagram Protocol)用户数据报协议</strong></p><p><strong>URL</strong>(Uniform Resource Locator)统一资源定位符</p><p><strong>UTP</strong>(Unshield Twisted Pair)无屏蔽双绞线</p><p><strong>UWB</strong>(Ultra-Wide Band)超宽带</p><p><strong>VC</strong>(Virtual Circuit)虚电路</p><p><strong>VDSL</strong>(Very high speed DSL)甚高数字用户线</p><p><strong>VLAN</strong>(Virtual LAN)虚拟局域网</p><p><strong>VPN</strong>(Virtual Private Network) 虚拟专用网</p><p><strong>WAN</strong>(Wide Area Network) 广域网</p><p><strong>WDM</strong>(Wavelength Division Multiplexing) 波分复用</p><p><strong>WG</strong>(Working Group)　工作组</p><p><strong>Ｗi-Fi</strong>(Wireless-Fidelity) 无线保真度(无限局域网的同义词)</p><p><strong>WLAN</strong>(Wireless Local Area Network) 无线局域网</p><p><strong>WMAN</strong>(Wireless Metrpolitan Area Network) 无线个城域网</p><p><strong>WPAN</strong>(wireless Personal Area Network) 无线个人区域网</p><p><strong>WSN</strong>(Wireless Sensor Network)　无线传感器网络</p><p><strong>WWW</strong>(World Wide Web) 万维网</p><h2 id="脚注"><em>脚注</em></h2><p>[^ISP]:<code>internet service provider</code> 互联网服务提供商(电信、移动、联通)<br>[^ACK]:ACK是TCP/IP协议中的一个重要标志,表示&quot;确认&quot;(Acknowledgement)<br>[^ALOHA]:ALOHA是夏威夷人表示致意的问候语,这项研究计划的目的是要解决夏威夷群岛之间的通信问题</p><h2 id="待用图片">待用图片</h2><p>ARP</p><p><img src="https://img2.imgtp.com/2024/04/04/lsOMhMkC.png" alt=""></p><!--stackedit_data:eyJoaXN0b3J5IjpbNDUxNDg1MTY5XX0=-->]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis</title>
      <link href="/2023/10/14/mybatis/"/>
      <url>/2023/10/14/mybatis/</url>
      
        <content type="html"><![CDATA[<img src="https://mybatis.org/images/mybatis-logo.png"><h2 id="简介">简介</h2><h3 id="什么是-MyBatis？">什么是 MyBatis？</h3><blockquote><p>MyBatis 是一款优秀的==持久层框架==，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p></blockquote><hr><h3 id="准备工作">准备工作</h3><ul><li><p>新建<code>maven</code>项目</p></li><li><p>在<code>pom.xml</code>文件中导入相关依赖,数据库依赖导入需要的就行</p></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mybatis依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mysql--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.33<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--sqlserver--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.microsoft.sqlserver<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mssql-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>12.2.0.jre8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--测试--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.9.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="核心配置"><a href="https://mybatis.org/mybatis-3/zh/configuration.html">核心配置</a></h2><h3 id="核心配置文件">核心配置文件</h3><blockquote><p>配置标签顺序(核心配置文件中的==标签顺序必须符合下面顺序==)</p></blockquote><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231013140702442.png" alt="图片没了" style="float: left;"><blockquote><p>核心配置文件<code>mybatis-config.xml</code>示例</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--configuration 核心配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--1.加载配置文件，从配置文件中读取数据使用$&#123;&#125;,见下面的数据源配置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>/&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--2.配置日志--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--标准日志工厂配置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--配置log4j日志--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        3.可以给实体类取别名，之后使用类名不需要写全限定类名</span><br><span class="hljs-comment">            3.1 typeAlias标签页实现</span><br><span class="hljs-comment">            3.2 package 扫描包下所有类并起一个默认别名为类名(小写也可以)或</span><br><span class="hljs-comment">                        如果想自定义别名，需要在类名上面加@Alias注解</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;typeAlias type=&quot;com.clb.pojo.User&quot; alias=&quot;User&quot;/&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.clb.pojo&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--4.配置多环境，default指定使用哪个环境--&gt;</span><br>    <span class="hljs-comment">&lt;!--&lt;environments default=&quot;mysql&quot;&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;sqlserver&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--mysql数据源--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.driver&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.url&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.username&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.password&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--sql server数据源--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlserver&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;ms.driver&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;ms.url&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;ms.username&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;ms.password&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    每一个Mapper.xml配置文件都需要在mybatis核心配置文件中注册</span><br><span class="hljs-comment">        1.mapper标签 使用resource指定mapper配置文件注册(无条件!)</span><br><span class="hljs-comment">        2.mapper标签 使用class指定mapper类注册</span><br><span class="hljs-comment">        3.package标签扫描包</span><br><span class="hljs-comment">        总结:第 2,3中方法都需要满足:</span><br><span class="hljs-comment">                条件：1.接口名和它的mapper配置文件名相同</span><br><span class="hljs-comment">                     2.接口文件和它的mapper配置文件在同一个包下</span><br><span class="hljs-comment">            1.所以建议使用第一种方法，指定配置文件路径(使用配置文件时)</span><br><span class="hljs-comment">            2.使用注解开发时，使用方法2,3</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/clb/dao/EmpMapper.xml&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;mapper class=&quot;com.clb.dao.EmpMapper&quot;/&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;package name=&quot;com.clb.dao&quot;/&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>数据源配置文件示例</p></blockquote><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># mysql</span><br><span class="hljs-attr">mysql.driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">mysql.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/clb</span><br><span class="hljs-attr">mysql.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">mysql.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-comment"># sql server</span><br><span class="hljs-attr">ms.driver</span>=<span class="hljs-string">com.microsoft.sqlserver.jdbc.SQLServerDriver</span><br><span class="hljs-comment">#ms.url=jdbc:sqlserver://localhost:1433;trustServerCertificate=true</span><br><span class="hljs-attr">ms.url</span>=<span class="hljs-string">jdbc:sqlserver://192.168.0.88:1433;trustServerCertificate=true</span><br><span class="hljs-attr">ms.username</span>=<span class="hljs-string">sa</span><br><span class="hljs-attr">ms.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><h3 id="Mapper-xml映射文件">Mapper.xml映射文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--把原来的UserDaoImpl类转换成一个xml配置文件--&gt;</span><br><br><span class="hljs-comment">&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.clb.dao.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--结果集映射 type -&gt; 需要将数据库数据映射成user类型 数据库字段名和属性名一致则会自动映射，无需额外配置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--colum 数据库中的列 -&gt; property 实体类中的属性--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        查询语句</span><br><span class="hljs-comment">            id:         对应namespace中的接口的方法名</span><br><span class="hljs-comment">            resultType: sql语句执行的返回类型</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.clb.pojo.User&quot;</span>&gt;</span><br>        select * from mybatis.user<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <br>    <br>    <span class="hljs-comment">&lt;!--根据id查询用户,这里#&#123;id&#125;中的id就是方法中的id变量--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.clb.pojo.User&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>        select * from user where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--模糊查询，concat用于拼接字符串--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.clb.pojo.User&quot;</span>&gt;</span><br>        select * from user where name like concat(&#x27;&#x27;, #&#123;name&#125;, &#x27;&#x27;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--添加一个用户,对象中的属性可以直接取出来，不需要加类名user.--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.clb.pojo.User&quot;</span>&gt;</span><br>        insert into user(id, name, pwd) value (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="MybatisUtils">MybatisUtils</h3><blockquote><p>要使用mybatis执行sql语句，要使用<code>SqlSession</code>对象,可以直接在测试类中获取</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//加载核心配置文件</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-comment">//获取SqlSessionFactory对象</span><br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    <span class="hljs-comment">//获取SqlSession对象</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession()) &#123;<br>        <span class="hljs-comment">//获取Mapper对象，执行xml映射文件中的方法</span><br>        <span class="hljs-type">EmpMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(EmpMapper.class);<br>        List&lt;Emp&gt; emps = mapper.selectBySalary(<span class="hljs-number">5000</span>);<br>        emps.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>但是每次使用都要写这一串代码，<strong>有点麻烦</strong>，前面获取SqlSession对象的代码是固定代码，将这段固定代码提取到工具类<code>MybatisUtils</code>，使用工具类的静态方法获取SqlSession对象</p></blockquote><blockquote><p><strong>MybatisUtils工具类示例</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//sqlSessionFactory --&gt; sqlSession</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MybatisUtils</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">//定义一个SqlSessionFactory对象并使用静态初始化块初始化对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//使用mybatis第一步，获取sqlSessionFactory对象</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMybatisUtils</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//使用工具类直接获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br><br>    <span class="hljs-type">EmpMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(EmpMapper.class);<br>    List&lt;Emp&gt; emps = mapper.selectBySalary(<span class="hljs-number">1000</span>);<br>    emps.forEach(System.out::println);<br><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注解开发">注解开发</h2><blockquote><p>使用注解直接写sql语句代替xml映射文件</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select id, name, pwd password from user&quot;)</span><br>    List&lt;User&gt; <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * @Param()注解:</span><br><span class="hljs-comment">    *   1.基本类型或者String类型需要加上</span><br><span class="hljs-comment">    *   2.引用类型可以不加</span><br><span class="hljs-comment">    *   3.如果只有一个基本类型的话，可以不加，但是建议加上</span><br><span class="hljs-comment">    *   4.在注解中的sql语句中&#123;&#125;中的参数就是@Param注解中的属性名</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@Select(&quot;select id, name, pwd password &quot; +</span><br><span class="hljs-meta">            &quot;from user &quot; +</span><br><span class="hljs-meta">            &quot;where id = #&#123;id&#125; and name=#&#123;name&#125; and pwd=#&#123;password&#125;&quot;)</span><br>    User <span class="hljs-title function_">selectById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-type">int</span> i, <span class="hljs-meta">@Param(&quot;name&quot;)</span>String n, <span class="hljs-meta">@Param(&quot;password&quot;)</span> String p)</span>;<br><br>    <span class="hljs-comment">//#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;中的三个属性均来自参数中对象的属性</span><br>    <span class="hljs-meta">@Insert(&quot;insert into user(id, name, pwd) VALUE (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span>;<br><br>    <span class="hljs-meta">@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id=#&#123;id&#125;&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(User user)</span>;<br><br>    <span class="hljs-meta">@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">deleteUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-type">int</span> id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用<code>@Result</code>注解可以定义结果映射，使用<code>@ResultMap</code>可以引用xml文件中定义的ResultMap结果映射</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from emp where first_name = #&#123;name&#125;;&quot;)</span><br><span class="hljs-meta">@Results(&#123;</span><br><span class="hljs-meta">    @Result(column = &quot;first_name&quot;, property = &quot;firstName&quot;)</span><br><span class="hljs-meta">&#125;)</span><br>Emp <span class="hljs-title function_">getByFirstNameEmp</span><span class="hljs-params">(String name)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//更推荐使用</span><br><span class="hljs-meta">@Select(&quot;select * from emp where first_name = #&#123;name&#125;;&quot;)</span><br><span class="hljs-meta">@ResultMap(&quot;EmpMap&quot;)</span><br>Emp <span class="hljs-title function_">getByFirstNameEmp</span><span class="hljs-params">(String name)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>总结：简单的sql语句使用注解比配置文件来的更方便且更快，但是复杂的sql语句使用注解反而不方便或难以实现，所以==简单的sql使用注解，复杂的使用xml，搭配使用==</p></blockquote><hr><h2 id="动态-SQL"><a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html">动态 SQL</a></h2><blockquote><p>==动态查询==</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。</span><br><span class="hljs-comment">    而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。--&gt;</span><br><br><span class="hljs-comment">&lt;!--动态sql if标签 如果参数不为空就加上条件，否则不加--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pageQuery&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.sky.entity.Category&quot;</span>&gt;</span><br>    select * from category<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span><br>            and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;type != null&quot;</span>&gt;</span><br>            and type = #&#123;type&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    order by sort asc , create_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>==动态更新==</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Category&quot;</span>&gt;</span><br>    update category<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;type != null&quot;</span>&gt;</span><br>            type = #&#123;type&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            name = #&#123;name&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sort != null&quot;</span>&gt;</span><br>            sort = #&#123;sort&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>            status = #&#123;status&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateTime != null&quot;</span>&gt;</span><br>            update_time = #&#123;updateTime&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateUser != null&quot;</span>&gt;</span><br>            update_user = #&#123;updateUser&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>==批量插入，传入参数是一个集合类型，删除同理==</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertBatch&quot;</span>&gt;</span><br>    insert into dish_flavor (dish_id, name, value)values<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;flavors&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;f&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        (#&#123;f.dishId&#125;,#&#123;f.name&#125;,#&#123;f.value&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>更多动态SQL用法见<a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html">官网</a></p><p>接下来，了解进阶框架==mybatis-plus==</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> mybatis </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/08/31/Redis/"/>
      <url>/2023/08/31/Redis/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://redis.io/">Redis</a></h1><h2 id="什么是Nosql">什么是Nosql</h2><blockquote><p>==NoSQL==&gt;&gt;&gt;&gt;&gt;==not only sql==,不仅仅是sql(不是没有sql)</p></blockquote><p>Nosql特点</p><ol><li>方便拓展（数据之间没有关系，很好拓展！）</li><li>大数据量高性能（redis一秒写8万次，读取11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</li><li>数据类型是多样的！（不需要事先设计数据库！随取随用！如果是数据量非常大的表，关系型数据库就很难设计了！）</li><li>传统==RDBMS==(关系型数据库管理系统)和==NoSQL==</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">RDBMS的特点：<br><br>- 基于关系模型，使用表格的存储方式，数据按照行和列进行组织。<br>- 使用SQL语言进行数据的查询和操作，SQL语言是一种通用的、标准化的、结构化的语言，可以进行复杂的查询和分析。<br>- 强调ACID规则（原子性、一致性、隔离性、持久性），可以保证数据的完整性和一致性，适合处理高要求的事务操作。<br>- 通常只能进行纵向扩展，即增加单个服务器的硬件资源来提高性能，这种方式成本高昂且有上限。<br>- 适合处理结构化或半结构化的数据，需要进行复杂查询或分析的场景，例如金融、电商、教育等领域。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">NoSQL的特点：<br><br>- 不基于关系模型，使用键值对、文档、图形等多种存储方式，数据的结构和格式可以灵活变化，不需要预先定义。<br>- 使用非结构化查询语言（UnQL）或者特定的API进行数据的访问和操作，UnQL没有统一的标准，每种NoSQL数据库都有自己的语法和规则。<br>- 通常只提供弱一致性或最终一致性的保证，不能支持复杂的事务操作，但可以提高数据的可用性和并发性。<br>- 通常可以进行横向扩展，即增加多个服务器来分担数据和负载，这种方式成本低廉且可以无限扩展。<br>- 适合处理非结构化或多变的数据，需要高并发或海量数据存储的场景，例如社交网络、游戏、物联网等领域。<br></code></pre></td></tr></table></figure><p>大数据时代的3V:主要是描述问题的</p><ol><li>海量Volume</li><li>多样Variety</li><li>实时Velocity</li></ol><p>大数据时代的3高:主要是对程序的要求</p><ol><li>高并发</li><li>高可扩</li><li>高性能</li></ol><p>实际开发项目一般都是 NoSQL+RDBMS 搭配使用</p><hr><h2 id="redis入门">redis入门</h2><h3 id="概述">概述</h3><blockquote><p>redis是什么？</p></blockquote><ol><li>Redis（==Re==mote ==Di==ctionary ==S==erver )，即远程字典服务</li><li>是一个开源的使用ANSI ==C语言==编写、支持网络、可基于内存亦可持久化的日志型、==Key-Value==数据库，并提供多种语言的API</li><li>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave==(主从)同步==</li><li>免费和开源，是当下最热门的NoSQL技术之一</li></ol><blockquote><p>redis能做什么？</p></blockquote><ol><li>内存存储、==持久化==，内存是断电即失的，所以说持久化很重要！</li><li>效率高，可以用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器（浏览量）</li></ol><blockquote><p>特性</p></blockquote><ol><li>多样的数据类型</li><li>持久化</li><li>事务</li><li>集群</li></ol><h3 id="基本知识">基本知识</h3><blockquote><p>登录redis客户端redis-cli:computer:</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 直接登录 -h ip地址 -p 端口号 -a 密码(不用密码也能登陆，但是没有权限)</span><br>redis-cli -h localhost -p 6379 -a 123456<br><br><span class="hljs-comment"># 推荐登录后再用密码进行认证</span><br><span class="hljs-comment"># 1.登录</span><br>redis-cli (-h localhost -p 6379 如果是本地登陆可以省略)<br><br><span class="hljs-comment"># 2.身份认证 OK &gt;&gt;&gt; 成功</span><br>&gt; auth 123456<br><br><span class="hljs-comment"># 查看命令的帮助信息</span><br><span class="hljs-built_in">help</span> [<span class="hljs-built_in">command</span>]<br></code></pre></td></tr></table></figure><img src="https://img2.imgtp.com/2024/04/04/4WG8EHcc.webp" alt="CopyQ" /><blockquote><p><strong>redis有==16==个数据库(0-15)，默认使用的是==0==，可以使用select切换数据库</strong></p></blockquote><p>切换数据库 <code>select [index]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换数据库为1号</span><br><span class="hljs-keyword">select</span> 1<br></code></pre></td></tr></table></figure><p>查看当前数据库大小<code>dbsize</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">dbsize<br>&gt; (<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><p>设置键值对<code>set [key] [value]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> name clb<br>&gt; OK<br></code></pre></td></tr></table></figure><p>根据键获取值<code>get [key]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">get name<br>&gt; <span class="hljs-string">&quot;clb&quot;</span><br></code></pre></td></tr></table></figure><p>查找所有适配的key <code>keys [pattern] </code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查询所有</span><br>keys *<br>&gt; 1) <span class="hljs-string">&quot;name&quot;</span><br>&gt; 2) <span class="hljs-string">&quot;age&quot;</span><br></code></pre></td></tr></table></figure><p>清空当前数据库<code>flushdb</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">flushdb<br></code></pre></td></tr></table></figure><p>清空所有数据库<code>flushall</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">flushall<br></code></pre></td></tr></table></figure><hr><blockquote><p><strong>==redis是单线程的！==</strong></p></blockquote><p>官方表示，redis是基于内存操作，CPU不是redis的性能瓶颈，redis的性能瓶颈是机器的内存大小和网络带宽，既然单线程更容易实现，那就顺理成章的使用单线程了</p><blockquote><p>==<strong>redis为什么单线程还这么快？</strong>==</p></blockquote><p>误区：</p><ul><li>高性能的服务器一定是多线程的？</li><li>多线程（CPU上下文会切换）一定比单线程效率高？</li></ul><p>==核心==：redis是将所有数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写操作都是在一个CPU上的，在内存情况下，这个就是最佳的方案！</p><hr><h3 id="Redis-Key">Redis-Key</h3><p>查看一个或者多个key是否存在，返回个数<code>exists [key...]</code></p><img src="https://img2.imgtp.com/2024/04/04/kOLycrII.webp" alt="CopyQ" /><p>设置过期时间(多长时间后过期自动从数据库删除)<code>expire [key] [time] 单位默认是秒</code></p><blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">expire name 3<span class="hljs-comment"># 3秒后过期，过期了数据就没了</span><br></code></pre></td></tr></table></figure></blockquote><p>查看key的剩余时间<code>ttl [key]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ttl name<br>&gt; 2<br></code></pre></td></tr></table></figure><p>移动key到其他数据库<code>move [key] [db]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">move name 15<br></code></pre></td></tr></table></figure><p>删除一个或多个key<code>del [key...]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">del name<br>del name age<br></code></pre></td></tr></table></figure><p>查看key的类型<code>type [key]</code>,不存在返回none</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">type</span> name <br>&gt; string<br></code></pre></td></tr></table></figure><hr><h2 id="五大数据类型">五大数据类型</h2><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作==数据库==、==缓存==和==消息中间件==，它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）</p><hr><h3 id="String">String</h3><p>==字符串==</p><p>set、get、keys、exists同上</p><p>追加字符串<code>append [key] [value]</code> 如果name不存在，就等同于set方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">append name nb<br>&gt; (<span class="hljs-built_in">integer</span>) 5<br></code></pre></td></tr></table></figure><p>查询字符串长度<code>strlen [key]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">strlen name<br>&gt; (<span class="hljs-built_in">integer</span>) 5<br></code></pre></td></tr></table></figure><hr><p>增加和减少操作，前提是key对应的值可以转化成integer，否则报错</p><p>自增(++) <code>incr [key]</code>,自减(–)<code>decr [key]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">get views<br>&gt; <span class="hljs-string">&quot;3&quot;</span><br><br>incr views<br>&gt; (<span class="hljs-built_in">integer</span>) 4<br><br>decr views<br>&gt; (<span class="hljs-built_in">integer</span>) 3<br></code></pre></td></tr></table></figure><p>增加(+=)<code>incrby [key] [步长]</code>，减少(-=)<code>decrby [key] [步长]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">get views<br>&gt; <span class="hljs-string">&quot;10&quot;</span><br><br>INCRBY views 5<br>&gt; (<span class="hljs-built_in">integer</span>) 15<br><br>DECRBY views 3<br>&gt; (<span class="hljs-built_in">integer</span>) 12<br></code></pre></td></tr></table></figure><blockquote><p>获取字符串的子串<code>getrange [key] [start] [end]</code></p></blockquote><p>注意：==闭区间==（开始索引和结束索引都包含），==逆序索引从-1开始(倒数第1个索引为-1，倒数第2索引为-2…)==</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">get k<br>&gt; <span class="hljs-string">&quot;hello world!&quot;</span><br><br>getrange k 0 4<span class="hljs-comment">#[0,4]</span><br>&gt; <span class="hljs-string">&quot;hello&quot;</span><br><br>getrange k 0 -1<span class="hljs-comment">#获取全部，0表示头部，-1表示尾部</span><br><span class="hljs-string">&quot;hello world!&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>替换字符串<code>setrange [key] [start] [value]</code>,从start索引开始，用value直接覆盖后面的值，如果原来字符串长度不够，那么补0增加长度后再进行覆盖</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; get str<br><span class="hljs-string">&quot;12345&quot;</span><br><br>127.0.0.1:6379&gt; setrange str 1 abcdefg<br>(<span class="hljs-built_in">integer</span>) 8<br><br>127.0.0.1:6379&gt; get str<br><span class="hljs-string">&quot;1abcdefg&quot;</span><br></code></pre></td></tr></table></figure><p>设置key-value并指定过期时间<code>setex [key] [seconds] [value]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; setex name 10 clb<br>OK<br>127.0.0.1:6379&gt; ttl name<br>(<span class="hljs-built_in">integer</span>) 7<br></code></pre></td></tr></table></figure><blockquote><p>==设置key-value==<code>setnx [key] [value]</code></p></blockquote><p>和set的区别：==如果key已经存在，set方法直接覆盖原来的值，而setnx不会==</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; setnx name cxk<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; setnx name ikun<br>(<span class="hljs-built_in">integer</span>) 0<span class="hljs-comment">#key已经存在，不覆盖</span><br>127.0.0.1:6379&gt; get name<br><span class="hljs-string">&quot;cxk&quot;</span><br></code></pre></td></tr></table></figure><hr><p>批量设置<code>mset [key value ...]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;k3&quot;</span><br>2) <span class="hljs-string">&quot;k1&quot;</span><br>3) <span class="hljs-string">&quot;k2&quot;</span><br></code></pre></td></tr></table></figure><p>批量获取<code>mget [key ...]</code></p><blockquote><p>批量设置<code>msetnx [key value ...]</code>msetnx是一个==<strong>原子性</strong>==操作，要么全部成功，要么全部失败,只要有一个key存在，整个操作全部失败</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; mget k1 k2 k3<br>1) <span class="hljs-string">&quot;v1&quot;</span><br>2) <span class="hljs-string">&quot;v2&quot;</span><br>3) <span class="hljs-string">&quot;v3&quot;</span><br>127.0.0.1:6379&gt; msetnx k1 666 k4 999<br>(<span class="hljs-built_in">integer</span>) 0<span class="hljs-comment"># k1存在，整个操作失败，k4也未赋值</span><br>127.0.0.1:6379&gt; mget k1 k2 k3 k4<br>1) <span class="hljs-string">&quot;v1&quot;</span><br>2) <span class="hljs-string">&quot;v2&quot;</span><br>3) <span class="hljs-string">&quot;v3&quot;</span><br>4) (nil)<br></code></pre></td></tr></table></figure><hr><p>设置一个对象user:1 值用一个json字符串来表示，但是这样不能直接获取到name属性，所以要单独赋值</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> &#123;name:zhangsan,age:<span class="hljs-number">19</span>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里的key的设计：<code>user:&#123;id&#125;:&#123;filed&#125;</code>非常巧妙(这样就能直接获取一个user对象中的各种属性，类似一种层次结构)</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> mset <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span>:name zhangsan <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span>:age <span class="hljs-number">19</span><br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> mget <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span>:name <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span>:age<br><span class="hljs-number">1</span>) &quot;zhangsan&quot;<br><span class="hljs-number">2</span>) &quot;19&quot;<br></code></pre></td></tr></table></figure><hr><blockquote><p>getset方法<code>getset [key] [value]</code>获取key原来对应的value，设置一个新的值，返回原来被替换的值，如果本来就不存在，返回nil</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> getset name ikun<br>(nil)<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> getset name kunkun<br>&quot;ikun&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> name<br>&quot;kunkun&quot;<br></code></pre></td></tr></table></figure><hr><h3 id="List">List</h3><p>==列表==</p><p>插入值</p><ol><li>从左边插入（头插法）<code>lpush [key] [value ...]</code></li><li>从右边插入（尾插法）<code>rpush [key] [value ...]</code></li><li>从左边开始遍历<code>lrange [start] [end]</code></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lpush list <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <br>(<span class="hljs-type">integer</span>) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange list <span class="hljs-number">0</span> <span class="hljs-number">-1</span> # <span class="hljs-number">-1</span>代表尾部，所以是遍历全部<br><span class="hljs-number">1</span>) &quot;3&quot;<br><span class="hljs-number">2</span>) &quot;2&quot;<br><span class="hljs-number">3</span>) &quot;1&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> rpush list <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">6</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange list <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;3&quot;<br><span class="hljs-number">2</span>) &quot;2&quot;<br><span class="hljs-number">3</span>) &quot;1&quot;<br><span class="hljs-number">4</span>) &quot;4&quot;<br><span class="hljs-number">5</span>) &quot;5&quot;<br><span class="hljs-number">6</span>) &quot;6&quot;<br></code></pre></td></tr></table></figure><p>移除元素</p><ol><li>从左边开始移除<code>lpop [key] [count个数] </code></li><li>从右边开始移除<code>rpop [key] [count个数] </code></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange list <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;3&quot;<br><span class="hljs-number">2</span>) &quot;2&quot;<br><span class="hljs-number">3</span>) &quot;1&quot;<br><span class="hljs-number">4</span>) &quot;4&quot;<br><span class="hljs-number">5</span>) &quot;5&quot;<br><span class="hljs-number">6</span>) &quot;6&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lpop list <span class="hljs-number">2</span><br><span class="hljs-number">1</span>) &quot;3&quot;<br><span class="hljs-number">2</span>) &quot;2&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> rpop list <span class="hljs-number">3</span><br><span class="hljs-number">1</span>) &quot;6&quot;<br><span class="hljs-number">2</span>) &quot;5&quot;<br><span class="hljs-number">3</span>) &quot;4&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange list <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;1&quot;<br></code></pre></td></tr></table></figure><p>获取列表中指定索引的值<code>lindex [key] [index]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange lst <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;5&quot;<br><span class="hljs-number">2</span>) &quot;4&quot;<br><span class="hljs-number">3</span>) &quot;3&quot;<br><span class="hljs-number">4</span>) &quot;2&quot;<br><span class="hljs-number">5</span>) &quot;1&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lindex lst <span class="hljs-number">1</span><br>&quot;4&quot;<br></code></pre></td></tr></table></figure><p>获取列表长度<code>llen [key]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange lst <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;5&quot;<br><span class="hljs-number">2</span>) &quot;4&quot;<br><span class="hljs-number">3</span>) &quot;3&quot;<br><span class="hljs-number">4</span>) &quot;2&quot;<br><span class="hljs-number">5</span>) &quot;1&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> llen lst<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><blockquote><p>删除列表中n个指定元素(精确匹配)<code>lrem [key] 3 2</code> &gt;&gt;&gt; 删除list列表中从左往右数的前3个2，返回值为成功删除的个数</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange list <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;2&quot; <br><span class="hljs-number">2</span>) &quot;10&quot;<br><span class="hljs-number">3</span>) &quot;9&quot;<br><span class="hljs-number">4</span>) &quot;6&quot;<br><span class="hljs-number">5</span>) &quot;2&quot;<br><span class="hljs-number">6</span>) &quot;2&quot;<br><span class="hljs-number">7</span>) &quot;2&quot;<br><span class="hljs-number">8</span>) &quot;1&quot;<br><span class="hljs-number">9</span>) &quot;2&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrem list <span class="hljs-number">3</span> <span class="hljs-number">2</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange list <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;10&quot;<br><span class="hljs-number">2</span>) &quot;9&quot;<br><span class="hljs-number">3</span>) &quot;6&quot;<br><span class="hljs-number">4</span>) &quot;2&quot;<br><span class="hljs-number">5</span>) &quot;1&quot;<br><span class="hljs-number">6</span>) &quot;2&quot;<br></code></pre></td></tr></table></figure><p>截取列表指定索引之间的元素<code>ltrim [key] [start] [stop]</code> 截取[start,stop],==这是在原数组上进行修改!==</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange list <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a&quot;<br><span class="hljs-number">2</span>) &quot;b&quot;<br><span class="hljs-number">3</span>) &quot;c&quot;<br><span class="hljs-number">4</span>) &quot;d&quot;<br><span class="hljs-number">5</span>) &quot;e&quot;<br><span class="hljs-number">6</span>) &quot;ok&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> ltrim list <span class="hljs-number">0</span> <span class="hljs-number">2</span><br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange list <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a&quot;<br><span class="hljs-number">2</span>) &quot;b&quot;<br><span class="hljs-number">3</span>) &quot;c&quot;<br></code></pre></td></tr></table></figure><blockquote><p>移除arr1中最右边的元素并从左边插入arr2<code>rpoplpush [source] [destination]</code></p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange arr1 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;1&quot;<br><span class="hljs-number">2</span>) &quot;2&quot;<br><span class="hljs-number">3</span>) &quot;3&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange arr2 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a&quot;<br><span class="hljs-number">2</span>) &quot;b&quot;<br><span class="hljs-number">3</span>) &quot;c&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> rpoplpush arr1 arr2<br>&quot;3&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange arr1 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;1&quot;<br><span class="hljs-number">2</span>) &quot;2&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange arr2 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;3&quot;<br><span class="hljs-number">2</span>) &quot;a&quot;<br><span class="hljs-number">3</span>) &quot;b&quot;<br><span class="hljs-number">4</span>) &quot;c&quot;<br></code></pre></td></tr></table></figure><p>根据索引设置列表中的元素<code>lset [key] [index] [value]</code>，相当于更新操作</p><p>列表不存在或索引超出范围(可以使用负数表示逆序索引)都会报错</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange list <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;v2&quot;<br><span class="hljs-number">3</span>) &quot;v3&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lset list <span class="hljs-number">1</span> <span class="hljs-number">666</span><br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange list <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;666&quot;<br><span class="hljs-number">3</span>) &quot;v3&quot;<br></code></pre></td></tr></table></figure><p>在列表中从左往右数第1个pivot前面/后面插入指定元素</p><p><code>linsert [key] before|after [pivot] [element]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange list <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;kun&quot;<br><span class="hljs-number">2</span>) &quot;cxk&quot;<br><span class="hljs-number">3</span>) &quot;clb&quot;<br><span class="hljs-number">4</span>) &quot;kun&quot;<br><span class="hljs-number">5</span>) &quot;nb&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> linsert list before kun <span class="hljs-number">666</span> # 从左往右第一个kun前插入<span class="hljs-number">666</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">6</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange list <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;666&quot;<br><span class="hljs-number">2</span>) &quot;kun&quot;<br><span class="hljs-number">3</span>) &quot;cxk&quot;<br><span class="hljs-number">4</span>) &quot;clb&quot;<br><span class="hljs-number">5</span>) &quot;kun&quot;<br><span class="hljs-number">6</span>) &quot;nb&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> linsert list after nb ctrl # 从左往右第一个nb后面插入ctrl<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">7</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> lrange list <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;666&quot;<br><span class="hljs-number">2</span>) &quot;kun&quot;<br><span class="hljs-number">3</span>) &quot;cxk&quot;<br><span class="hljs-number">4</span>) &quot;clb&quot;<br><span class="hljs-number">5</span>) &quot;kun&quot;<br><span class="hljs-number">6</span>) &quot;nb&quot;<br><span class="hljs-number">7</span>) &quot;ctrl&quot;<br></code></pre></td></tr></table></figure><blockquote><p>小结：List实际上是一个==双向链表==结构，在两边crud快，中间元素crud相对较慢</p></blockquote><hr><h3 id="Set">Set</h3><p>==集合，不能有重复元素==</p><p>set集合添加元素<code>sadd [key] [member ...]</code>,添加重复元素无效</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sadd <span class="hljs-keyword">set</span> hello ikun cxk ctrl hello<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">4</span> # 因为<span class="hljs-keyword">set</span>不允许有重复元素，所以最后一个hello未被添加<br></code></pre></td></tr></table></figure><p>set查看所有元素<code>smembers [key]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> smembers <span class="hljs-keyword">set</span><br><span class="hljs-number">1</span>) &quot;ctrl&quot;<br><span class="hljs-number">2</span>) &quot;ikun&quot;<br><span class="hljs-number">3</span>) &quot;hello&quot;<br><span class="hljs-number">4</span>) &quot;cxk&quot;<br></code></pre></td></tr></table></figure><p>set是否包含元素<code>sismember [key] [member]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sismember <span class="hljs-keyword">set</span> ikun<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>获取set中元素个数<code>scarg set</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> scard <span class="hljs-keyword">set</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>移除set中指定元素<code>srem [key] [member]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> srem <span class="hljs-keyword">set</span> ikun<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>从set中随机移除几个元素<code>spop [key] [count:个数超出上限则全部移除]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> spop <span class="hljs-keyword">set</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span>) &quot;5&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> spop <span class="hljs-keyword">set</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span>) &quot;4&quot;<br><span class="hljs-number">2</span>) &quot;1&quot;<br></code></pre></td></tr></table></figure><p>从set中随机取出几个元素<code>srandmember [key] [count:个数超出上限则取出全部]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> srandmember <span class="hljs-keyword">set</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span>) &quot;1&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> srandmember <span class="hljs-keyword">set</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span>) &quot;4&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> srandmember <span class="hljs-keyword">set</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span>) &quot;1&quot;<br><span class="hljs-number">2</span>) &quot;4&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> srandmember <span class="hljs-keyword">set</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span>) &quot;2&quot;<br><span class="hljs-number">2</span>) &quot;1&quot;<br><span class="hljs-number">3</span>) &quot;5&quot;<br></code></pre></td></tr></table></figure><p>从一个集合中移动指定元素到另外一个集合<code>smove [source] [destination] member</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sadd s1 ikun cxk<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">2</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sadd s2 ctrl rap<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">2</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> smove s1 s2 ikun<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> SMEMBERS s2<br><span class="hljs-number">1</span>) &quot;ctrl&quot;<br><span class="hljs-number">2</span>) &quot;ikun&quot;<br><span class="hljs-number">3</span>) &quot;rap&quot;<br></code></pre></td></tr></table></figure><p>差集、交集、并集<code>sdiff|sinter|sunion [set1] [set2...]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sadd s1 a b c d<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sadd s2 c d e f<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sdiff s1 s2 # 差集<br><span class="hljs-number">1</span>) &quot;a&quot;<br><span class="hljs-number">2</span>) &quot;b&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sdiff s2 s1 # 差集<br><span class="hljs-number">1</span>) &quot;e&quot;<br><span class="hljs-number">2</span>) &quot;f&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sinter s1 s2 # 交集<br><span class="hljs-number">1</span>) &quot;d&quot;<br><span class="hljs-number">2</span>) &quot;c&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sunion s1 s2 # 并集<br><span class="hljs-number">1</span>) &quot;f&quot;<br><span class="hljs-number">2</span>) &quot;b&quot;<br><span class="hljs-number">3</span>) &quot;a&quot;<br><span class="hljs-number">4</span>) &quot;e&quot;<br><span class="hljs-number">5</span>) &quot;d&quot;<br><span class="hljs-number">6</span>) &quot;c&quot;<br></code></pre></td></tr></table></figure><hr><h3 id="Hash">Hash</h3><p>==键值对，相当于map==</p><p>设置<code>hset|hmset [hash] [key value ...]</code>hset从redis4开始支持批量设置</p><p>获取</p><ol><li>根据key获取一个 值<code>hget [hash] [key]</code></li><li>根据多个key获取多个值<code>hmget [hash] [key ...]</code></li><li>获取所有键和值<code>hgetall [hash]</code></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> hset hash k1 v1 k2 v2 k3 v3<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> hget hash k1<br>&quot;v1&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> hgetall hash<br><span class="hljs-number">1</span>) &quot;k1&quot;<br><span class="hljs-number">2</span>) &quot;v1&quot;<br><span class="hljs-number">3</span>) &quot;k2&quot;<br><span class="hljs-number">4</span>) &quot;v2&quot;<br><span class="hljs-number">5</span>) &quot;k3&quot;<br><span class="hljs-number">6</span>) &quot;v3&quot;<br></code></pre></td></tr></table></figure><p>根据键删除k-v<code>hdel [hash] [key ...]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> hdel hash k1<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>获取键值对个数<code>hlen [hash]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> hlen hash<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>获取所有的key<code>hkeys [hash]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> hkeys hash<br><span class="hljs-number">1</span>) &quot;k2&quot;<br><span class="hljs-number">2</span>) &quot;k3&quot;<br></code></pre></td></tr></table></figure><p>获取所有的value<code>hvals [hash]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> hvals hash<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v3&quot;<br></code></pre></td></tr></table></figure><p><code>hsetnx</code> <code>hincrby</code>用法同string</p><blockquote><p>hash更多应用于存储用户信息！</p></blockquote><hr><h3 id="Zset">Zset</h3><p>==有序集合==，在set基础上增加了一个score，默认根据score升序排序</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> zadd <span class="hljs-keyword">set</span> <span class="hljs-number">-6</span> ikun <span class="hljs-number">66</span> kun <span class="hljs-number">6</span> kunkun <span class="hljs-number">0</span> ctrl<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> zrange <span class="hljs-keyword">set</span> <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;ikun&quot;<br><span class="hljs-number">2</span>) &quot;ctrl&quot;<br><span class="hljs-number">3</span>) &quot;kunkun&quot;<br><span class="hljs-number">4</span>) &quot;kun&quot;<br></code></pre></td></tr></table></figure><p>获取score在-inf(负无穷,可以改为具体数值)到+inf之间元素并带有score(升序)</p><p><code>zrangebyscore [set] [-inf] [+inf] (withscores可以不用)</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> zrangebyscore <span class="hljs-keyword">set</span> <span class="hljs-operator">-</span>inf <span class="hljs-operator">+</span>inf withscores<br><span class="hljs-number">1</span>) &quot;ikun&quot;<br><span class="hljs-number">2</span>) &quot;-6&quot;<br><span class="hljs-number">3</span>) &quot;ctrl&quot;<br><span class="hljs-number">4</span>) &quot;0&quot;<br><span class="hljs-number">5</span>) &quot;kunkun&quot;<br><span class="hljs-number">6</span>) &quot;6&quot;<br><span class="hljs-number">7</span>) &quot;kun&quot;<br><span class="hljs-number">8</span>) &quot;66&quot;<br></code></pre></td></tr></table></figure><p>根据score逆序获取，range前面加<code>rev</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> zrevrange <span class="hljs-keyword">set</span> <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;kun&quot;<br><span class="hljs-number">2</span>) &quot;kunkun&quot;<br><span class="hljs-number">3</span>) &quot;ctrl&quot;<br><span class="hljs-number">4</span>) &quot;ikun&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> ZREVRANGEBYSCORE <span class="hljs-keyword">set</span> <span class="hljs-operator">+</span>inf <span class="hljs-operator">-</span>inf withscores<br><span class="hljs-number">1</span>) &quot;kun&quot;<br><span class="hljs-number">2</span>) &quot;66&quot;<br><span class="hljs-number">3</span>) &quot;kunkun&quot;<br><span class="hljs-number">4</span>) &quot;6&quot;<br><span class="hljs-number">5</span>) &quot;ctrl&quot;<br><span class="hljs-number">6</span>) &quot;0&quot;<br><span class="hljs-number">7</span>) &quot;ikun&quot;<br><span class="hljs-number">8</span>) &quot;-6&quot;<br></code></pre></td></tr></table></figure><blockquote><p>获取有序集合元素个数<code>zcard [set]</code></p></blockquote><blockquote><p>统计score在区间内的元素个数<code>zcount [set] [min] [max]</code>包含两端</p></blockquote><hr><h2 id="三种特殊数据类型">三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="http://www.redis.cn/commands/geoadd.html">Geospatial(地理位置)</a></h3><blockquote><p>==<strong>geoadd</strong>== 添加一个或多个城市信息<code>geoadd [key] [经度 纬度 member ...]</code></p><p>:rocket: ==<strong>这里的key实际上是zset(有序集合),zset方法可以操作这里的key</strong>==</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><blockquote><p>查询所有位置信息</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zrange china:city 0 -1<br>1) <span class="hljs-string">&quot;chongqing&quot;</span><br>2) <span class="hljs-string">&quot;xian&quot;</span><br>3) <span class="hljs-string">&quot;shenzhen&quot;</span><br>4) <span class="hljs-string">&quot;hangzhou&quot;</span><br>5) <span class="hljs-string">&quot;shanghai&quot;</span><br>6) <span class="hljs-string">&quot;beijing&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>==<strong>geopos</strong>== 查询一个或多个城市经度和纬度<code>geopos [key] [member ...]</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; geopos china:city beijing shanghai<br>1) 1) <span class="hljs-string">&quot;116.39999896287918091&quot;</span><br>   2) <span class="hljs-string">&quot;39.90000009167092543&quot;</span><br>2) 1) <span class="hljs-string">&quot;121.47000163793563843&quot;</span><br>   2) <span class="hljs-string">&quot;31.22999903975783553&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>==<strong>geodist</strong>==计算两地之间的距离<code>geodist [key] [member1] [member2] [unit:单位,默认为米]</code></p></blockquote><ul><li><strong>m</strong> 表示单位为米(默认使用)</li><li><strong>km</strong> 表示单位为千米</li><li><strong>mi</strong> 表示单位为英里</li><li><strong>ft</strong> 表示单位为英尺</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; geodist china:city beijing shanghai<br><span class="hljs-string">&quot;1067378.7564&quot;</span><br>127.0.0.1:6379&gt; geodist china:city beijing shanghai km<br><span class="hljs-string">&quot;1067.3788&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>==<strong>georadius</strong>== 以指定点为半径，查找位置在方圆半径内的元素(元素来源于key)，==返回结果按照距离升序排序==</p><p><code>georadius [key] [经度 纬度 距离 单位] [withcoord:输出经纬度] [withdist:输出距离] [count 个数:指定查找的最多个数] </code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找以经纬度坐标(110,30)为中心，方圆500km内的城市信息，只找最近的两个(只找出在china:key中录入的城市)</span><br>127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord withdist count 2<br>1) 1) <span class="hljs-string">&quot;chongqing&quot;</span><br>   2) <span class="hljs-string">&quot;341.9374&quot;</span><br>   3) 1) <span class="hljs-string">&quot;106.49999767541885376&quot;</span><br>      2) <span class="hljs-string">&quot;29.52999957900659211&quot;</span><br>2) 1) <span class="hljs-string">&quot;xian&quot;</span><br>   2) <span class="hljs-string">&quot;483.8340&quot;</span><br>   3) 1) <span class="hljs-string">&quot;108.96000176668167114&quot;</span><br>      2) <span class="hljs-string">&quot;34.25999964418929977&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>==georadiusmember==</strong> 根据已存在点作为中心查找范围内的元素,用法同上</p><p><code>georadiusbymember [key] [member] 200 km</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; georadiusbymember china:city shanghai 200 km<br>1) <span class="hljs-string">&quot;hangzhou&quot;</span><br>2) <span class="hljs-string">&quot;shanghai&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>geohash返回一个位置的geohash字符串(11位字符) <code>geohash [key] [mamber ...]</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; geohash china:city beijing shanghai<br>1) <span class="hljs-string">&quot;wx4fbxxfke0&quot;</span><br>2) <span class="hljs-string">&quot;wtw3sj5zbj0&quot;</span><br></code></pre></td></tr></table></figure><hr><h3 id="Hyperloglog">Hyperloglog</h3><p>==元素不重复，类似于set集合，但是占用内存更小，不过数据量大的时候有一定误差==</p><blockquote><p>添加元素  <code>pfadd [key] [value ...]</code></p><p>统计不重复元素个数 <code>pfcount [key]</code></p><p>合并多个集合 <code>pfmege [destination] [source ...]</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; pfadd set1 1 2 3 4 5<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; pfadd set2 4 5 6 7 8<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; pfmerge set3 set1 set2<br>OK<br>127.0.0.1:6379&gt; pfcount set3<br>(<span class="hljs-built_in">integer</span>) 8<br></code></pre></td></tr></table></figure><hr><h3 id="Bitmap-位图">Bitmap(位图)</h3><p>设置一周打卡信息(1 打卡，0 未打卡)</p><blockquote><p><code>setbit [key] [offset:int数字，此处表示周几] [status 0/1]</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; setbit sign 1 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 2 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 3 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 4 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 5 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 6 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 7 0<br>(<span class="hljs-built_in">integer</span>) 0<br></code></pre></td></tr></table></figure><blockquote><p>获取某天状态 <code>getbit [key] [offset]</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; getbit sign 4<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><blockquote><p>统计状态为1的个数 <code>bitcount [key]</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; bitcount sign<br>(<span class="hljs-built_in">integer</span>) 4<br></code></pre></td></tr></table></figure><hr><h2 id="事务">事务</h2><p>redis事务本质：一组命令的集合，有一致性、顺序性、排他性，</p><p>==redis事务没有隔离级别的概念==，所有命令在事务中并没有直接被执行，只有发起执行命令的时候才会执行</p><p><strong>==redis单条命令保证原子性，但是事务不保证原子性==</strong></p><blockquote><p>redis的事务</p></blockquote><ul><li>开始事务（<code>multi</code> 开启事务之后输入的命令不会直接执行，而是进入命令队列，直到事务被执行，所有的命令才按顺序执行）</li><li>命令入队（<code>...</code>）</li><li>执行事务（<code>exec</code>）</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<span class="hljs-comment"># 开启事务</span><br>OK<br><span class="hljs-comment"># 命令入队</span><br>127.0.0.1:6379(TX)&gt; mset k1 v1 k2 v2 k3 v3<br>QUEUED<br>127.0.0.1:6379(TX)&gt; mget k1 k2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span><span class="hljs-comment"># 执行事务</span><br>1) OK<br>2) 1) <span class="hljs-string">&quot;v1&quot;</span><br>   2) <span class="hljs-string">&quot;v2&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>放弃事务（<code>discard</code>命令入队过程中使用可以放弃事务）</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k1 1231<br>QUEUED<br>127.0.0.1:6379(TX)&gt; discard<br>OK<br></code></pre></td></tr></table></figure><blockquote><p>==编译型异常==（命令有问题，过不了编译），事务中所有命令不执行！</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k1 v1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; setttttt k2 v2<span class="hljs-comment"># 不存在的命令导致编译异常</span><br>(error) ERR unknown <span class="hljs-built_in">command</span> <span class="hljs-string">&#x27;setttttt&#x27;</span>, with args beginning with: <span class="hljs-string">&#x27;k2&#x27;</span> <span class="hljs-string">&#x27;v2&#x27;</span> <br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k3 v3<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span><br>(error) EXECABORT Transaction discarded because of previous errors.<span class="hljs-comment"># 之前的编译异常导致整个事务被放弃</span><br></code></pre></td></tr></table></figure><blockquote><p>==运行时异常==（除0错误，索引越界…）错误命令不执行，其他命令正常执行，==不能保证原子性==</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> k1 v1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; incr k1<span class="hljs-comment"># v1不能转换为integer类型，运行时异常，编译没问题</span><br>QUEUED<br>127.0.0.1:6379(TX)&gt; get k1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span><br>1) OK<br>2) (error) ERR value is not an <span class="hljs-built_in">integer</span> or out of range<br>3) <span class="hljs-string">&quot;v1&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>==<strong>悲观锁</strong>==：很悲观，认为什么时候都会出问题，无论做什么都会加锁</p></blockquote><blockquote><p>==<strong>乐观锁</strong>==：</p><ul><li>很乐观，认为什么时候都不会出现问题，所以不会上锁，更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul></blockquote><p>使用watch当做redis的乐观锁操作 <code>watch [key]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 多线程并发修改</span><br><span class="hljs-comment"># --------------线程1--------------</span><br>127.0.0.1:6379&gt; watch money <span class="hljs-comment"># 监视，想当于加乐观锁</span><br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; incrby money 666<br>QUEUED<br><span class="hljs-comment"># exec还未执行时，线程2开始执行</span><br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span><br>(nil)<span class="hljs-comment"># 执行失败</span><br><br><span class="hljs-comment"># --------------线程2--------------</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> money -6<span class="hljs-comment"># 修改了线程1中加了乐观锁的money</span><br>OK<br></code></pre></td></tr></table></figure><p>执行失败后使用<code>unwatch</code>解锁后再重新监视并执行</p><hr><h2 id="Jedis">Jedis</h2><p>==官方推荐==的java连接开发工具，使用java操作redis的中间件，如果要使用java操作redis，那么一定要对jedis十分的熟悉！</p><ol><li>导入jedis依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入jedis依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.4.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>创建jedis对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个Jedis对象并认证</span><br>jedis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.66.6&quot;</span>, <span class="hljs-number">6379</span>);<br>jedis.auth(<span class="hljs-string">&quot;123456&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li>使用jedis对象调用API,jedis的API基本都是对应redis中的命令</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.flushDB();<br>System.out.println(jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;clb&quot;</span>));<br>System.out.println(jedis.set(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>));<br>System.out.println(jedis.exists(<span class="hljs-string">&quot;name&quot;</span>));<br></code></pre></td></tr></table></figure><blockquote><p>事务操作</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">#事务<br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTX</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    json.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;cxk&quot;</span>);<br>    json.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;34&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> json.toJSONString();<br>    jedis.flushDB();<br><br>    jedis.watch(result);<br>    <span class="hljs-comment">//开启事务</span><br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">multi</span> <span class="hljs-operator">=</span> jedis.multi();<br>    <span class="hljs-keyword">try</span> &#123;<br>        multi.set(<span class="hljs-string">&quot;user1&quot;</span>, result);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// 制造一个运行时异常</span><br>        multi.set(<span class="hljs-string">&quot;user2&quot;</span>, result);<br>        multi.exec(); <span class="hljs-comment">//执行事务</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        multi.discard();<span class="hljs-comment">//放弃事务</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(jedis.get(<span class="hljs-string">&quot;user1&quot;</span>));<br>        System.out.println(jedis.get(<span class="hljs-string">&quot;user2&quot;</span>));<br>        jedis.close(); <span class="hljs-comment">//关闭连接</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="SpringBoot整合">SpringBoot整合</h2><p>SpringBoot2.x之后，原来使用的jedis被替换成了lettuce</p><p>==jedis==：采用直连，多个线程池操作的话，是不安全的，如果想要避免，就要使用<code>jedis pool</code>连接池，更像<code>BIO</code>（阻塞IO）模式</p><p>==<strong>lettuce</strong>==：采用<code>netty</code>，实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据，更像<code>NIO</code>（非阻塞IO）模式</p><ol><li>导入redis依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置文件配置redis</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">data:</span><br>    <span class="hljs-attr">redis:</span><br>      <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.66</span><span class="hljs-number">.6</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><ol start="3"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Redis02SpringbootApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//方法和redis命令一一对应</span><br>        <span class="hljs-comment">//opsForValue()   操作String</span><br>        <span class="hljs-comment">//opsForList()    操作List</span><br>        <span class="hljs-comment">//......</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;坤坤&quot;</span>);<br>      System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>redis中各种数据类型对应的操作方法</p><img src="https://img2.imgtp.com/2024/04/04/HHpI88A1.jpg" alt="1693648470356" /><ol start="4"><li>==序列化== ：<ul><li>在Spring Boot中，序列化是指==将对象转换为可以存储或传输的字节序列的过程==。这可以通过将对象转换为==JSON==或==XML==格式来实现。序列化允许在存储或传输对象时==减少内存使用==，并确保在在不同系统之间交换数据时能够正确表示对象</li><li>实体类一般都要序列化，<code>implements Serializable</code>实现序列化接口就可以了，默认使用的是JDK序列化,也可以使用其他json工具实现，因为默认的jdk序列化存储中文到redis会出现乱码</li></ul></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> NOSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-plus</title>
      <link href="/2023/08/31/mybatis-plus/"/>
      <url>/2023/08/31/mybatis-plus/</url>
      
        <content type="html"><![CDATA[<h1>mybatis-plus</h1><h2 id="简介">简介</h2><blockquote><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis</a>的增强工具，在 MyBatis 的基础上==只做增强不做改变==，为简化开发、提高效率而生。(先了解[[mybatis]]框架)</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/zV34uOPj.png" alt=""></p><h2 id="1-快速开始">1.快速开始</h2><h3 id="1-1-导入依赖">1.1 导入依赖</h3><blockquote><p>导入mybatis-plus依赖,包含了mybatis，==不用额外再导入mybatis依赖==</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-创建Mapper">1.2 创建Mapper</h3><blockquote><p>为了简化单表CRUD，mp已经提供了对于单表的CRUD操作的接口<code>BaseMapper</code>,直接继承BaseMapper接口即可直接使用</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/04/WiwPW9IW.png" alt=""></p><h3 id="1-3-测试CRUD">1.3 测试CRUD</h3><blockquote><p>测试BaseMapper中对单表CRUD操作</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsert</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    <span class="hljs-comment">//user.setId(5L);</span><br>    user.setUsername(<span class="hljs-string">&quot;ikun23&quot;</span>);<br>    user.setPassword(<span class="hljs-string">&quot;123&quot;</span>);<br>    user.setPhone(<span class="hljs-string">&quot;18688990011&quot;</span>);<br>    user.setBalance(<span class="hljs-number">200</span>);<br>    user.setInfo(UserInfo.of(<span class="hljs-number">24</span>,<span class="hljs-string">&quot;英语老师&quot;</span>,<span class="hljs-string">&quot;female&quot;</span>));<br>    user.setCreateTime(LocalDateTime.now());<br>    user.setUpdateTime(LocalDateTime.now());<br>    userMapper.insert(user);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectById</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.selectById(<span class="hljs-number">4L</span>);<br>    System.out.println(user);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectByIds</span><span class="hljs-params">()</span> &#123;<br>    List&lt;User&gt; users = userMapper.selectBatchIds(List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br>    users.forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setId(<span class="hljs-number">5L</span>);<br>    user.setBalance(<span class="hljs-number">3</span>);<br>    user.setInfo(UserInfo.of(<span class="hljs-number">24</span>,<span class="hljs-string">&quot;英语老师&quot;</span>,<span class="hljs-string">&quot;female&quot;</span>));<br>    user.setCreateTime(LocalDateTime.now());<br>    user.setUpdateTime(LocalDateTime.now());<br><br>    userMapper.updateById(user);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDelete</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(userMapper.deleteById(<span class="hljs-number">5L</span>));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：只要继承了<code>BaseMapper</code>，就能直接对单表进行CRUD操作！</p></blockquote><h2 id="2-常见注解">2.常见注解</h2><blockquote><p><strong>问题</strong>：在刚刚的测试中，我们直接调用BaseMapper中的方法就能对表增删改查，在继承<code>BaseMapper</code>的时候我们只是指定了一个泛型<code>&lt;User&gt;</code>,并没有指定是哪张表，那么==mybatis-plus怎么知道我们要操作的是user表呢？它又是怎么知道这张表中的所有字段名呢？==</p><p>解答：其实mp遵从==约定大于配置==的思想,mp从<code>User</code>类推导出数据库中表名为<code>user</code>，然后根据User类中的所有变量名从==驼峰命名==转成==下划线==作为数据库的字段名，从而在调用方法时可以自动生成正确的sql语句。</p><p>如果我们在创建User类和user表的时候遵从驼峰命名和下划线命名，那么我们不需要做额外的配置，如果类名和表名、属性名和字段名直接不是简单的转换，那么我们就不得不使用一些相应的注解来声明表的信息</p></blockquote><h3 id="2-1-TableName">2.1 <a href="https://www.baomidou.com/pages/223848/#tablename">@TableName</a></h3><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableName(&quot;sys_user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-TableId">2.2 <a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/TableId.java"> @TableId</a></h3><ul><li>描述：主键注解</li><li>使用位置：实体类主键字段</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableName(&quot;sys_user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@TableId</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>必须指定</strong></th><th><strong>默认值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>主键字段名</td></tr><tr><td>type</td><td>Enum</td><td>否</td><td>==IdType.NONE==</td><td>指定主键类型</td></tr></tbody></table><p><code>IdType</code>支持的类型有：</p><table><thead><tr><th><strong>值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>AUTO</td><td>数据库 ID 自增</td></tr><tr><td>NONE</td><td>无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td></tr><tr><td>INPUT</td><td>insert 前自行 set 主键值</td></tr><tr><td>ASSIGN_ID</td><td>分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)</td></tr><tr><td>ASSIGN_UUID</td><td>分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)</td></tr><tr><td><s>ID_WORKER</s></td><td>分布式全局唯一 ID 长整型类型(please use ASSIGN_ID)</td></tr><tr><td><s>UUID</s></td><td>32 位 UUID 字符串(please use ASSIGN_UUID)</td></tr><tr><td><s>ID_WORKER_STR</s></td><td>分布式全局唯一 ID 字符串类型(please use ASSIGN_ID)</td></tr></tbody></table><p>这里比较常见的有三种：</p><ul><li><code>AUTO</code>：利用数据库的id自增长</li><li><code>INPUT</code>：手动生成id</li><li><code>ASSIGN_ID</code>：雪花算法生成<code>Long</code>类型的全局唯一id，这是默认的ID策略</li></ul><h3 id="2-3-TableField">2.3 <a href="https://www.baomidou.com/pages/223848/#tablefield">@TableField</a></h3><ul><li>描述：字段注解（非主键）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableName(&quot;sys_user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@TableId</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-meta">@TableField(&quot;nickname&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-常见配置">3.常见配置</h2><p>MybatisPlus也支持基于yaml文件的自定义配置，详见官方文档：<br><a href="https://www.baomidou.com/pages/56bac0/#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">使用配置 | MyBatis-Plus</a></p><p>大多数的配置都有默认值，因此我们都无需配置。但还有一些是没有默认值的，例如:</p><ul><li>实体类的别名扫描包</li><li>全局id类型</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.itheima.mp.domain.po</span><span class="hljs-comment">#别名扫描包</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span> <span class="hljs-comment"># 全局id类型为自增长</span><br></code></pre></td></tr></table></figure><p>需要注意的是，MyBatisPlus也支持手写SQL的，而mapper文件的读取地址可以自己配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="hljs-comment"># Mapper.xml文件地址，当前这个是默认值。</span><br></code></pre></td></tr></table></figure><p>可以看到默认值是<code>classpath*:/mapper/**/*.xml</code>，也就是说我们只要把mapper.xml文件放置这个目录下就一定会被加载。</p><p>使用<code>@MapperScan</code>注解标识mapper类所在目录</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.clb.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(App.class, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>配置了==@MapperScan==注解后，mapper类中无需添加==@Mapper==注解</p></blockquote><hr><h2 id="4-核心功能"><strong>==4.核心功能==</strong></h2><h3 id="4-1-条件构造器">4.1 条件构造器</h3><p>除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此BaseMapper中提供的相关方法除了以<code>id</code>作为<code>where</code>条件以外，还支持更加复杂的<code>where</code>条件。<br><img src="https://img2.imgtp.com/2024/04/04/EYycmHcF.png" alt="image.png"><br>参数中的<code>Wrapper</code>就是条件构造的抽象类，其下有很多默认实现，继承关系如图：<br><img src="https://img2.imgtp.com/2024/04/04/yBBlOx4P.png" alt="image.png"></p><p><code>Wrapper</code>的子类<code>AbstractWrapper</code>提供了where中包含的所有条件构造方法：<br><img src="https://img2.imgtp.com/2024/04/04/mdBy9WoL.png" alt="image.png"><br>而QueryWrapper在AbstractWrapper的基础上拓展了一个select方法，允许指定查询字段：<br><img src="https://img2.imgtp.com/2024/04/04/hpyUpWuQ.png" alt="image.png"><br>而UpdateWrapper在AbstractWrapper的基础上拓展了一个set方法，允许指定SQL中的SET部分：<br><img src="https://img2.imgtp.com/2024/04/04/73APzR7R.png" alt="image.png"></p><p>接下来，我们就来看看如何利用<code>Wrapper</code>实现复杂查询。</p><h4 id="4-1-1-QueryWrapper">4.1.1 QueryWrapper</h4><p>修改、删除、查询都可以使用QueryWrapper构建查询条件</p><p>**查询：**查询名字带有o，且存款大于等于1000的人</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select id,username,info,balance <br>from user<br>where username like %o% and balance &gt;= 1000;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span> &#123;<br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-comment">//构建查询条件</span><br>    wrapper.select(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;balance&quot;</span>)<br>        .like(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>)<br>        .ge(<span class="hljs-string">&quot;balance&quot;</span>, <span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">//查询数据</span><br>    List&lt;User&gt; users = userMapper.selectList(wrapper);<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-2-UpdateWrapper">4.1.2 UpdateWrapper</h4><p>基于BaseMapper中的update方法更新时只能直接赋值，对于一些复杂的需求就难以实现。<br>例如：更新id为<code>1,2,4</code>的用户的余额，扣200，对于的SQL应该是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">200</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>SET的赋值结果是基于字段现有值的，这个时候就要利用UpdateWrapper中的setSql功能了：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateWrapper</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Long&gt; ids = List.of(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">4L</span>);<br>    <span class="hljs-comment">// 1.生成SQL</span><br>    UpdateWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;User&gt;()<br>            .setSql(<span class="hljs-string">&quot;balance = balance - 200&quot;</span>) <span class="hljs-comment">// SET balance = balance - 200</span><br>            .in(<span class="hljs-string">&quot;id&quot;</span>, ids); <span class="hljs-comment">// WHERE id in (1, 2, 4)</span><br><span class="hljs-comment">// 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，</span><br>    <span class="hljs-comment">// 而是基于UpdateWrapper中的setSQL来更新</span><br>    userMapper.update(<span class="hljs-literal">null</span>, wrapper);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-LambdaQueryWrapper">4.1.3 LambdaQueryWrapper</h4><p>无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，可能会出现字符串写错的现象，因此MybatisPlus又提供了一套基于Lambda的Wrapper，包含两个：</p><ul><li><code>LambdaQueryWrapper</code></li><li><code>LambdaUpdateWrapper</code></li></ul><p>分别对应<code>QueryWrapper</code>和<code>UpdateWrapper</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select id,username,info,balance <br>from user<br>where username like %o% and balance &gt;= 1000;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span> &#123;<br>    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-comment">//构建查询条件</span><br>    <span class="hljs-comment">//由原来的字符串变成getter函数对象获取类属性</span><br>    wrapper.select(User::getId, User::getUsername, User::getInfo, User::getBalance)<br>        .like(User::getUsername, <span class="hljs-string">&quot;o&quot;</span>)<br>        .ge(User::getBalance, <span class="hljs-number">1000</span>);<br>    userMapper.selectList(wrapper);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">UPDATE user SET balance = balance - 200 WHERE id in (1, 2, 4);<br></code></pre></td></tr></table></figure><h3 id="4-2-自定义SQL">4.2 自定义SQL</h3><h4 id="4-2-1-基本使用">4.2.1 基本使用</h4><p>在演示<code>UpdateWrapper</code>的案例中，我们在代码中编写了更新的SQL语句：<br><img src="https://img2.imgtp.com/2024/04/04/kpX6ZbUO.png" alt="image.png"><br>这种写法在某些企业也是不允许的，因为SQL语句最好都维护在持久层，而不是业务层。就当前案例来说，由于条件是in语句，只能将SQL写在Mapper.xml文件，利用foreach来生成动态SQL。<br>这实在是太麻烦了。假如查询条件更复杂，动态SQL的编写也会更加复杂。</p><p>所以，MybatisPlus提供了自定义SQL功能，可以让我们利用Wrapper生成查询条件，再结合Mapper.xml或注解编写SQL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">UPDATE user SET balance = balance - 200 WHERE id in (1, 2, 4)<br></code></pre></td></tr></table></figure><p><code>update user set balance = balance - 200</code>使用注解完成</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将wrapper作为ew，并使用ew.customSqlSegment取出条件是固定写法</span><br><span class="hljs-meta">@Update(&quot;update tb_user set balance = balance - #&#123;amount&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">updateBalanceByWrapper</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;amount&quot;)</span> <span class="hljs-type">int</span> amount, <span class="hljs-meta">@Param(&quot;ew&quot;)</span> LambdaQueryWrapper&lt;User&gt; wrapper)</span>;<br></code></pre></td></tr></table></figure><p><code>where id in(1,2,4)</code> 使用自定义sql完成,将wrapper作为参数传入自定义的方法中<code>$&#123;ew.customSqlSegment&#125;</code> ==&gt;<code> where id in (1,2,4)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCustomSql</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">amount</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br>    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    wrapper.in(User::getId, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>    userMapper.updateBalanceByWrapper(amount, wrapper);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-2-多表联查">4.2.2 多表联查</h4><p>理论上来将MyBatisPlus是不支持多表查询的，不过我们可以利用Wrapper中自定义条件结合自定义SQL来实现多表查询的效果。<br>例如，我们要查询出所有收货地址在北京的并且用户id在1、2、4之中的用户<br>要是自己基于mybatis实现SQL，大概是这样的：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryUserByIdAndAddr&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span><br>    SELECT *<br>    FROM user u<br>    INNER JOIN address a ON u.id = a.user_id<br>    WHERE u.id<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;IN (&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    AND a.city = #&#123;city&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看出其中最复杂的就是WHERE条件的编写，如果业务复杂一些，这里的SQL会更变态。但是基于自定义SQL结合Wrapper的玩法，我们就可以利用Wrapper来构建查询条件，然后手写SELECT及FROM部分，实现多表查询。<br>查询条件这样来构建：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testCustomJoinWrapper</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.准备自定义查询条件</span><br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;()<br>            .in(<span class="hljs-string">&quot;u.id&quot;</span>, List.of(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">4L</span>))<br>            .eq(<span class="hljs-string">&quot;a.city&quot;</span>, <span class="hljs-string">&quot;北京&quot;</span>);<br><br>    <span class="hljs-comment">// 2.调用mapper的自定义方法</span><br>    List&lt;User&gt; users = userMapper.queryUserByWrapper(wrapper);<br><br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在UserMapper中自定义方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;&quot;)</span><br>List&lt;User&gt; <span class="hljs-title function_">queryUserByWrapper</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ew&quot;)</span>QueryWrapper&lt;User&gt; wrapper)</span>;<br></code></pre></td></tr></table></figure><p>当然，也可以在<code>UserMapper.xml</code>中写SQL：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryUserByIdAndAddr&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span><br>    SELECT * FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>==总结:where条件可以使用wrapper构建，然后作为参数传递==</p></blockquote><h3 id="4-3-Service接口">4.3 Service接口</h3><p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。<br>通用接口为<code>IService</code>，默认实现为<code>ServiceImpl</code>，其中封装的方法可以分为以下几类：</p><ul><li><code>save</code>：新增</li><li><code>remove</code>：删除</li><li><code>update</code>：更新</li><li><code>get</code>：查询单个结果</li><li><code>list</code>：查询集合结果</li><li><code>count</code>：计数</li><li><code>page</code>：分页查询</li></ul><h4 id="4-3-1-CRUD">4.3.1.CRUD</h4><p>我们先俩看下基本的CRUD接口。<br><strong>新增</strong>：<br><img src="https://img2.imgtp.com/2024/04/04/EHtTllxK.png" alt="image.png"></p><ul><li><code>save</code>是新增单个元素</li><li><code>saveBatch</code>是批量新增</li><li><code>saveOrUpdate</code>是根据id判断，如果数据存在就更新，不存在则新增</li><li><code>saveOrUpdateBatch</code>是批量的新增或修改</li></ul><p><strong>删除：</strong><br><img src="https://img2.imgtp.com/2024/04/04/hTbeEW9j.png" alt="image.png"></p><ul><li><code>removeById</code>：根据id删除</li><li><code>removeByIds</code>：根据id批量删除</li><li><code>removeByMap</code>：根据Map中的键值对为条件删除</li><li><code>remove(Wrapper&lt;T&gt;)</code>：根据Wrapper条件删除</li><li><code>~~removeBatchByIds~~</code>：暂不支持</li></ul><p><strong>修改：</strong><br><img src="https://img2.imgtp.com/2024/04/04/vmqY49oX.png" alt="image.png"></p><ul><li><code>updateById</code>：根据id修改</li><li><code>update(Wrapper&lt;T&gt;)</code>：根据<code>UpdateWrapper</code>修改，<code>Wrapper</code>中包含<code>set</code>和<code>where</code>部分</li><li><code>update(T，Wrapper&lt;T&gt;)</code>：按照<code>T</code>内的数据修改与<code>Wrapper</code>匹配到的数据</li><li><code>updateBatchById</code>：根据id批量修改</li></ul><p><strong>Get：</strong><br><img src="https://img2.imgtp.com/2024/04/04/rtihGb60.png" alt="image.png"></p><ul><li><code>getById</code>：根据id查询1条数据</li><li><code>getOne(Wrapper&lt;T&gt;)</code>：根据<code>Wrapper</code>查询1条数据</li><li><code>getBaseMapper</code>：获取<code>Service</code>内的<code>BaseMapper</code>实现，某些时候需要直接调用<code>Mapper</code>内的自定义<code>SQL</code>时可以用这个方法获取到<code>Mapper</code></li></ul><p><strong>List：</strong><br><img src="https://img2.imgtp.com/2024/04/04/3InxWOnw.png" alt="image.png"></p><ul><li><code>listByIds</code>：根据id批量查询</li><li><code>list(Wrapper&lt;T&gt;)</code>：根据Wrapper条件查询多条数据</li><li><code>list()</code>：查询所有</li></ul><p><strong>Count</strong>：<br><img src="https://img2.imgtp.com/2024/04/04/7ZkniJuS.png" alt="image.png"></p><ul><li><code>count()</code>：统计所有数量</li><li><code>count(Wrapper&lt;T&gt;)</code>：统计符合<code>Wrapper</code>条件的数据数量</li></ul><p><strong>getBaseMapper</strong>：<br>当我们在service中要调用Mapper中自定义SQL时，就必须获取service对应的Mapper，就可以通过这个方法：<br><img src="https://img2.imgtp.com/2024/04/04/xxVjxhlY.png" alt="image.png"></p><h4 id="4-3-2-基本用法">4.3.2 基本用法</h4><p>由于<code>Service</code>中经常需要定义与业务有关的自定义方法，因此我们不能直接使用<code>IService</code>，而是自定义<code>Service</code>接口，然后继承<code>IService</code>以拓展方法。同时，让自定义的<code>Service实现类</code>继承<code>ServiceImpl</code>，这样就不用自己实现<code>IService</code>中的接口了，如下图(<strong>绿色为接口，蓝色为实现类</strong>)</p><p><img src="https://img2.imgtp.com/2024/04/04/eLZIQZta.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义接口继承IService接口，需要指定泛型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;User&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义实现类继承ServiceImpl，实现自定义接口，需要指定对应的Mapper和泛型，对应的Mapper需要继承BaseMapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSave</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    <span class="hljs-comment">//user.setId(5L);</span><br>    user.setUsername(<span class="hljs-string">&quot;kun_&quot;</span>);<br>    user.setPassword(<span class="hljs-string">&quot;123&quot;</span>);<br>    user.setPhone(<span class="hljs-string">&quot;18688990011&quot;</span>);<br>    user.setBalance(<span class="hljs-number">2000</span>);<br>    user.setInfo(UserInfo.of(<span class="hljs-number">24</span>, <span class="hljs-string">&quot;英语老师&quot;</span>, <span class="hljs-string">&quot;female&quot;</span>));<br>    user.setCreateTime(LocalDateTime.now());<br>    user.setUpdateTime(LocalDateTime.now());<br>    user.setStatus(UserStatus.NORMAL);<br>    userService.save(user);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGet</span><span class="hljs-params">()</span> &#123;<br>    List&lt;User&gt; users = userService.list(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;User&gt;().select(User::getUsername, User::getBalance).le(User::getBalance, <span class="hljs-number">999</span>));<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-3-批量新增">4.3.3 批量新增</h4><p>IService中的批量新增功能使用起来非常方便，但有一点注意事项，我们先来测试一下。<br>首先我们测试逐条插入数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveOneByOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;<br>        userService.save(buildUser(i));<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (e - b));<br>&#125;<br><br><span class="hljs-keyword">private</span> User <span class="hljs-title function_">buildUser</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setUsername(<span class="hljs-string">&quot;user_&quot;</span> + i);<br>    user.setPassword(<span class="hljs-string">&quot;123&quot;</span>);<br>    user.setPhone(<span class="hljs-string">&quot;&quot;</span> + (<span class="hljs-number">18688190000L</span> + i));<br>    user.setBalance(<span class="hljs-number">2000</span>);<br>    user.setInfo(<span class="hljs-string">&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;</span>);<br>    user.setCreateTime(LocalDateTime.now());<br>    user.setUpdateTime(user.getCreateTime());<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://img2.imgtp.com/2024/04/04/9hiuZHou.png" alt="image.png"><br>可以看到速度非常慢。</p><p>然后再试试MybatisPlus的批处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveBatch</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 准备10万条数据</span><br>    List&lt;User&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">1000</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;<br>        list.add(buildUser(i));<br>        <span class="hljs-comment">// 每1000条批量插入一次</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>) &#123;<br>            userService.saveBatch(list);<br>            list.clear();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (e - b));<br>&#125;<br></code></pre></td></tr></table></figure><p>执行最终耗时如下：<br><img src="https://img2.imgtp.com/2024/04/04/3m6K4PzT.png" alt="image.png"><br>可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。</p><p>不过，我们简单查看一下<code>MybatisPlus</code>源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">saveBatch</span><span class="hljs-params">(Collection&lt;T&gt; entityList, <span class="hljs-type">int</span> batchSize)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sqlStatement</span> <span class="hljs-operator">=</span> getSqlStatement(SqlMethod.INSERT_ONE);<br>    <span class="hljs-keyword">return</span> executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));<br>&#125;<br><span class="hljs-comment">// ...SqlHelper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">executeBatch</span><span class="hljs-params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="hljs-type">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> &#123;<br>    Assert.isFalse(batchSize &lt; <span class="hljs-number">1</span>, <span class="hljs-string">&quot;batchSize must not be less than one&quot;</span>);<br>    <span class="hljs-keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, sqlSession -&gt; &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idxLimit</span> <span class="hljs-operator">=</span> Math.min(batchSize, size);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (E element : list) &#123;<br>            consumer.accept(sqlSession, element);<br>            <span class="hljs-keyword">if</span> (i == idxLimit) &#123;<br>                sqlSession.flushStatements();<br>                idxLimit = Math.min(idxLimit + batchSize, size);<br>            &#125;<br>            i++;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现其实<code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Preparing: INSERT INTO <span class="hljs-title function_">user</span> <span class="hljs-params">( username, password, phone, info, balance, create_time, update_time )</span> VALUES ( ?, ?, ?, ?, ?, ?, ? )<br>Parameters: user_1, <span class="hljs-number">123</span>, <span class="hljs-number">18688190001</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span><br>Parameters: user_2, <span class="hljs-number">123</span>, <span class="hljs-number">18688190002</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span><br>Parameters: user_3, <span class="hljs-number">123</span>, <span class="hljs-number">18688190003</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span><br></code></pre></td></tr></table></figure><p>而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> ( username, password, phone, info, balance, create_time, update_time )<br><span class="hljs-keyword">VALUES</span> <br>(user_1, <span class="hljs-number">123</span>, <span class="hljs-number">18688190001</span>, &quot;&quot;, <span class="hljs-number">2000</span>, <span class="hljs-number">2023</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span>, <span class="hljs-number">2023</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span>),<br>(user_2, <span class="hljs-number">123</span>, <span class="hljs-number">18688190002</span>, &quot;&quot;, <span class="hljs-number">2000</span>, <span class="hljs-number">2023</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span>, <span class="hljs-number">2023</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span>),<br>(user_3, <span class="hljs-number">123</span>, <span class="hljs-number">18688190003</span>, &quot;&quot;, <span class="hljs-number">2000</span>, <span class="hljs-number">2023</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span>, <span class="hljs-number">2023</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span>),<br>(user_4, <span class="hljs-number">123</span>, <span class="hljs-number">18688190004</span>, &quot;&quot;, <span class="hljs-number">2000</span>, <span class="hljs-number">2023</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span>, <span class="hljs-number">2023</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span>);<br></code></pre></td></tr></table></figure><p>该怎么做呢？</p><p>MySQL的客户端连接参数中有这样的一个参数：<code>rewriteBatchedStatements</code>。顾名思义，就是重写批处理的<code>statement</code>语句。参考文档：<br><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements">cj-conn-prop_rewriteBatchedStatements</a><br>这个参数的默认值是false，我们需要修改连接参数，将其配置为true</p><p>修改项目中的application.yml文件，在jdbc的url后面添加参数<code>&amp;rewriteBatchedStatements=true</code>:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">MySQL123</span><br></code></pre></td></tr></table></figure><p>再次测试插入10万条数据，可以发现速度有非常明显的提升：<br><img src="https://img2.imgtp.com/2024/04/04/3w87AgNv.png" alt="image.png"></p><p>在<code>ClientPreparedStatement</code>的<code>executeBatchInternal</code>中，有判断<code>rewriteBatchedStatements</code>值是否为true并重写SQL的功能：<br><img src="https://img2.imgtp.com/2024/04/04/K0vXKCWw.png" alt="image.png"><br>最终，SQL被重写了：<br><img src="https://img2.imgtp.com/2024/04/04/9y7FQFXY.png" alt="image.png"></p><blockquote><p>总结:</p><ol><li><p>插入大量数据的时候，使用<code>saveBatch</code>批量插入一定数量的数据而不是在循环里面一条一条插入数据<code>save</code></p></li><li><p>mysql配置文件中开启批处理</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/mp？rewriteBatchedStatements=true</span> <span class="hljs-comment">#rewriteBatchedStatements=true 开启批处理</span><br></code></pre></td></tr></table></figure></li></ol></blockquote><h4 id="4-3-4-Lambda">4.3.4 Lambda</h4><p>Service中对<code>LambdaQueryWrapper</code>和<code>LambdaUpdateWrapper</code>的用法进一步做了简化。我们无需自己通过<code>new</code>的方式来创建<code>Wrapper</code>，而是直接调用<code>lambdaQuery</code>和<code>lambdaUpdate</code>方法：</p><p>基于Lambda查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testLambdaQuery</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.查询1个</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">rose</span> <span class="hljs-operator">=</span> userService.lambdaQuery()<br>            .eq(User::getUsername, <span class="hljs-string">&quot;Rose&quot;</span>)<br>            .one(); <span class="hljs-comment">// .one()查询1个</span><br>    System.out.println(<span class="hljs-string">&quot;rose = &quot;</span> + rose);<br><br>    <span class="hljs-comment">// 2.查询多个</span><br>    List&lt;User&gt; users = userService.lambdaQuery()<br>            .like(User::getUsername, <span class="hljs-string">&quot;o&quot;</span>)<br>            .list(); <span class="hljs-comment">// .list()查询集合</span><br>    users.forEach(System.out::println);<br><br>    <span class="hljs-comment">// 3.count统计</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> userService.lambdaQuery()<br>            .like(User::getUsername, <span class="hljs-string">&quot;o&quot;</span>)<br>            .count(); <span class="hljs-comment">// .count()则计数</span><br>    System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现lambdaQuery方法中除了可以构建条件，而且根据链式编程的最后一个方法来判断最终的返回结果，可选的方法有：</p><ul><li><code>.one()</code>：最多1个结果</li><li><code>.list()</code>：返回集合结果</li><li><code>.count()</code>：返回计数结果</li></ul><p>lambdaQuery还支持动态条件查询。比如下面这个需求：</p><blockquote><p>定义一个方法，接收参数为username、status、minBalance、maxBalance，参数可以为空。</p><ul><li>如果username参数不为空，则采用模糊查询;</li><li>如果status参数不为空，则采用精确匹配；</li><li>如果minBalance参数不为空，则余额必须大于minBalance</li><li>如果maxBalance参数不为空，则余额必须小于maxBalance</li></ul></blockquote><p>这个需求就是典型的动态查询，在业务开发中经常碰到，实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryUser</span><span class="hljs-params">()</span> &#123;<br>    List&lt;User&gt; users = queryUser(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>    users.forEach(System.out::println);<br>&#125;<br><br><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">queryUser</span><span class="hljs-params">(String username, Integer status, Integer minBalance, Integer maxBalance)</span> &#123;<br>    <span class="hljs-keyword">return</span> userService.lambdaQuery()<br>            .like(username != <span class="hljs-literal">null</span> , User::getUsername, username)<br>            .eq(status != <span class="hljs-literal">null</span>, User::getStatus, status)<br>            .ge(minBalance != <span class="hljs-literal">null</span>, User::getBalance, minBalance)<br>            .le(maxBalance != <span class="hljs-literal">null</span>, User::getBalance, maxBalance)<br>            .list();<br>&#125;<br></code></pre></td></tr></table></figure><p>基于Lambda更新：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testLambdaUpdate</span><span class="hljs-params">()</span> &#123;<br>    userService.lambdaUpdate()<br>            .set(User::getBalance, <span class="hljs-number">800</span>) <span class="hljs-comment">// set balance = 800</span><br>            .eq(User::getUsername, <span class="hljs-string">&quot;Jack&quot;</span>) <span class="hljs-comment">// where username = &quot;Jack&quot;</span><br>            .update(); <span class="hljs-comment">// 执行Update</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>lambdaUpdate()</code>方法后基于链式编程，可以添加<code>set</code>条件和<code>where</code>条件。但最后一定要跟上<code>update()</code>，否则语句不会执行。</p><p>lambdaUpdate()同样支持动态条件，例如下面的需求：</p><blockquote><p>基于IService中的lambdaUpdate()方法实现一个更新方法，满足下列需求：</p><ul><li>参数为balance、id、username</li><li>id或username至少一个不为空，根据id或username精确匹配用户</li><li>将匹配到的用户余额修改为balance</li><li>如果balance为0，则将用户status修改为冻结状态</li></ul></blockquote><p>实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateBalance</span><span class="hljs-params">()</span> &#123;<br>    updateBalance(<span class="hljs-number">0L</span>, <span class="hljs-number">1L</span>, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateBalance</span><span class="hljs-params">(Long balance, Long id, String username)</span>&#123;<br>    userService.lambdaUpdate()<br>            .set(User::getBalance, balance)<br>            .set(balance == <span class="hljs-number">0</span>, User::getStatus, <span class="hljs-number">2</span>)<br>            .eq(id != <span class="hljs-literal">null</span>, User::getId, id)<br>            .eq(username != <span class="hljs-literal">null</span>, User::getId, username)<br>            .update();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-静态工具">4.4.静态工具</h3><p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以帮助我们实现CRUD功能：<br><img src="https://img2.imgtp.com/2024/04/04/BsapLoQj.png" alt="image.png"></p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testDbGet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> Db.getById(<span class="hljs-number">1L</span>, User.class);<br>    System.out.println(user);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testDbList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 利用Db实现复杂条件查询</span><br>    List&lt;User&gt; list = Db.lambdaQuery(User.class)<br>            .like(User::getUsername, <span class="hljs-string">&quot;o&quot;</span>)<br>            .ge(User::getBalance, <span class="hljs-number">1000</span>)<br>            .list();<br>    list.forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testDbUpdate</span><span class="hljs-params">()</span> &#123;<br>    Db.lambdaUpdate(User.class)<br>            .set(User::getBalance, <span class="hljs-number">2000</span>)<br>            .eq(User::getUsername, <span class="hljs-string">&quot;Rose&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-拓展功能">5.拓展功能</h2><h3 id="5-1-代码生成插件">5.1 代码生成插件</h3><ol><li>安装插件</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/oZkvc41U.png" alt="image.png"></p><ol start="2"><li>配置数据库</li></ol><p><img src="https://img2.imgtp.com/2024/04/04/naMirTBz.png" alt="image.png"></p><p><img src="https://img2.imgtp.com/2024/04/04/uHRd7Xky.png" alt="image.png"></p><ol start="3"><li><p>生成代码</p><p><img src="https://img2.imgtp.com/2024/04/04/85YOQRj9.png" alt="image.png"></p></li></ol><p><img src="https://img2.imgtp.com/2024/04/04/dHdRGTLq.png" alt="image.png"></p><h3 id="5-2-逻辑删除">5.2 逻辑删除</h3><p>对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：</p><ul><li>在表中添加一个字段标记数据是否被删除</li><li>当删除数据时把标记置为true</li><li>查询时过滤掉标记为true的数据</li></ul><p>一旦采用了逻辑删除，所有的查询和删除逻辑都要跟着变化，非常麻烦。为了解决这个问题，MybatisPlus就添加了对逻辑删除的支持。<br>:::warning<br><strong>注意</strong>，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。<br>:::</p><p>例如，我们给<code>address</code>表添加一个逻辑删除字段：</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> address<br><span class="hljs-keyword">add</span> deleted bit <span class="hljs-keyword">default</span> b<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;逻辑删除&#x27;</span>;<br></code></pre></td></tr></table></figure><p>然后给<code>Address</code>实体添加<code>deleted</code>字段：<br><img src="https://img2.imgtp.com/2024/04/04/7yMg8Ned.png" alt="image.png"></p><p>接下来，我们要在<code>application.yml</code>中配置逻辑删除字段：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">deleted</span> <span class="hljs-comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span><br>      <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 逻辑已删除值(默认为 1)</span><br>      <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 逻辑未删除值(默认为 0)</span><br></code></pre></td></tr></table></figure><p>测试：<br>首先，我们执行一个删除操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteByLogic</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 删除方法与以前没有区别</span><br>    addressService.removeById(<span class="hljs-number">59L</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法与普通删除一模一样，但是底层的SQL逻辑变了：<br><img src="https://img2.imgtp.com/2024/04/04/F764ALZ9.png" alt="image.png"></p><p>查询一下试试：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testQuery</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Address&gt; list = addressService.list();<br>    list.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>会发现id为59的确实没有查询出来，而且SQL中也对逻辑删除字段做了判断：<br><img src="https://img2.imgtp.com/2024/04/04/iVAzYJEP.png" alt="image.png"></p><p>综上， 开启了逻辑删除功能以后，我们就可以像普通删除一样做CRUD，基本不用考虑代码逻辑问题。还是非常方便的。</p><p>:::warning<br><strong>注意</strong>：<br>逻辑删除本身也有自己的问题，比如：</p><ul><li>会导致数据库表垃圾数据越来越多，从而影响查询效率</li><li>SQL中全都需要对逻辑删除字段做判断，影响查询效率</li></ul><p>因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。<br>:::</p><h3 id="5-3-通用枚举">5.3 通用枚举</h3><p>User类中有一个用户状态字段：<br><img src="https://img2.imgtp.com/2024/04/04/A2iNFo9N.png" alt="image.png"><br>像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是<code>int</code>类型，对应的PO也是<code>Integer</code>。因此业务操作时必须手动把<code>枚举</code>与<code>Integer</code>转换，非常麻烦。</p><p>因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们<strong>把枚举类型与数据库类型自动转换</strong>。</p><h4 id="5-3-1-定义枚举">5.3.1.定义枚举</h4><p>我们定义一个用户状态的枚举：<br><img src="https://img2.imgtp.com/2024/04/04/3zYvEl0h.png" alt="image.png"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp.enums;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.EnumValue;<br><span class="hljs-keyword">import</span> lombok.Getter;<br><br><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">UserStatus</span> &#123;<br>    NORMAL(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;正常&quot;</span>),<br>    FREEZE(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;冻结&quot;</span>)<br>    ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;<br><br>    UserStatus(<span class="hljs-type">int</span> value, String desc) &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.desc = desc;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后把<code>User</code>类中的<code>status</code>字段改为<code>UserStatus</code> 类型：<br><img src="https://img2.imgtp.com/2024/04/04/uOuWLie2.png" alt="image.png"></p><p>要让<code>MybatisPlus</code>处理枚举与数据库类型自动转换，我们必须告诉<code>MybatisPlus</code>，枚举中的哪个字段的值作为数据库值。<br><code>MybatisPlus</code>提供了<code>@EnumValue</code>注解来标记枚举属性：<br><img src="https://img2.imgtp.com/2024/04/04/2os8O1jy.png" alt="image.png"></p><h4 id="5-3-2-配置枚举处理器">5.3.2.配置枚举处理器</h4><p>在application.yaml文件中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">default-enum-type-handler:</span> <span class="hljs-string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span><br></code></pre></td></tr></table></figure><h4 id="5-3-3-测试">5.3.3.测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testService</span><span class="hljs-params">()</span> &#123;<br>    List&lt;User&gt; list = userService.list();<br>    list.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终，查询出的<code>User</code>类的<code>status</code>字段会是枚举类型：<br><img src="https://img2.imgtp.com/2024/04/04/w6yhRekl.png" alt="image.png"></p><h3 id="5-4-字段类型处理器">5.4 字段类型处理器</h3><p>数据库的user表中有一个<code>info</code>字段，是JSON类型：<br><img src="https://img2.imgtp.com/2024/04/04/aq5pnfGN.png" alt="image.png"><br>格式像这样：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;intro&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;佛系青年&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;gender&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;male&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>而目前<code>User</code>实体类中却是<code>String</code>类型：<br><img src="https://img2.imgtp.com/2024/04/04/bST1cToI.png" alt="image.png"></p><p>这样以来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个<code>Map</code>或者实体类。<br>而一旦我们把<code>info</code>改为<code>对象</code>类型，就需要在写入数据库是手动转为<code>String</code>，再读取数据库时，手动转换为<code>对象</code>，这会非常麻烦。</p><p>因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用<code>JacksonTypeHandler</code>处理器。</p><p>接下来，我们就来看看这个处理器该如何使用。</p><h4 id="5-4-1-定义实体">5.4.1 定义实体</h4><p>首先，我们定义一个单独实体类来与info字段的属性匹配：<br><img src="https://img2.imgtp.com/2024/04/04/k7dLTXuX.png" alt="image.png"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp.domain.po;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfo</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String intro;<br>    <span class="hljs-keyword">private</span> String gender;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-4-2-使用类型处理器">5.4.2 使用类型处理器</h4><p>接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：<br><img src="https://img2.imgtp.com/2024/04/04/WgvyOE3Q.png" alt="image.png"></p><p>测试可以发现，所有数据都正确封装到UserInfo当中了：<br><img src="https://img2.imgtp.com/2024/04/04/3vnjQq6c.png" alt="image.png"></p><h3 id="5-5配置加密">5.5配置加密</h3><p>目前我们配置文件中的很多参数都是明文，如果开发人员发生流动，很容易导致敏感信息的泄露。所以MybatisPlus支持配置文件的加密和解密功能。</p><p>我们以数据库的用户名和密码为例。</p><h4 id="5-5-1-生成秘钥">5.5.1.生成秘钥</h4><p>首先，我们利用AES工具生成一个随机秘钥，然后对用户名、密码加密：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.toolkit.AES;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MpDemoApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 生成 16 位随机 AES 密钥</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">randomKey</span> <span class="hljs-operator">=</span> AES.generateRandomKey();<br>        System.out.println(<span class="hljs-string">&quot;randomKey = &quot;</span> + randomKey);<br><br>        <span class="hljs-comment">// 利用密钥对用户名加密</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> AES.encrypt(<span class="hljs-string">&quot;root&quot;</span>, randomKey);<br>        System.out.println(<span class="hljs-string">&quot;username = &quot;</span> + username);<br><br>        <span class="hljs-comment">// 利用密钥对用户名加密</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> AES.encrypt(<span class="hljs-string">&quot;MySQL123&quot;</span>, randomKey);<br>        System.out.println(<span class="hljs-string">&quot;password = &quot;</span> + password);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">randomKey = 6234633<span class="hljs-type">a66fb399f</span><br><span class="hljs-variable">username</span> <span class="hljs-operator">=</span> px2bAbnUfiY8K/IgsKvscg==<br>password = FGvCSEaOuga3ulDAsxw68Q==<br></code></pre></td></tr></table></figure><h4 id="5-5-2-修改配置">5.5.2.修改配置</h4><p>修改application.yaml文件，把jdbc的用户名、密码修改为刚刚加密生成的密文：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">mpw:QWWVnk1Oal3258x5rVhaeQ==</span> <span class="hljs-comment"># 密文要以 mpw:开头</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">mpw:EUFmeH3cNAzdRGdOQcabWg==</span> <span class="hljs-comment"># 密文要以 mpw:开头</span><br></code></pre></td></tr></table></figure><h4 id="5-5-3-测试">5.5.3.测试</h4><p>在启动项目的时候，需要把刚才生成的秘钥添加到启动参数中，像这样：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">--mpw.key=6234633a66fb399f</span><br></code></pre></td></tr></table></figure><p>单元测试的时候不能添加启动参数，所以要在测试类的注解上配置：<br><img src="https://img2.imgtp.com/2024/04/04/16rM2gf0.png" alt="image.png"></p><p>然后随意运行一个单元测试，可以发现数据库查询正常。</p><h2 id="6-插件功能">6.插件功能</h2><p>MybatisPlus提供了很多的插件功能，进一步拓展其功能。目前已有的插件有：</p><ul><li><code>PaginationInnerInterceptor</code>：自动分页</li><li><code>TenantLineInnerInterceptor</code>：多租户</li><li><code>DynamicTableNameInnerInterceptor</code>：动态表名</li><li><code>OptimisticLockerInnerInterceptor</code>：乐观锁</li><li><code>IllegalSQLInnerInterceptor</code>：sql 性能规范</li><li><code>BlockAttackInnerInterceptor</code>：防止全表更新与删除</li></ul><p>:::warning<br><strong>注意：</strong><br>使用多个分页插件的时候需要注意插件定义顺序，建议使用顺序如下：</p><ul><li>多租户,动态表名</li><li>分页,乐观锁</li><li>sql 性能规范,防止全表更新与删除<br>:::</li></ul><p>这里我们以分页插件为里来学习插件的用法。</p><h2 id="6-1-分页插件">6.1.分页插件</h2><p>在未引入分页插件的情况下，<code>MybatisPlus</code>是不支持分页功能的，<code>IService</code>和<code>BaseMapper</code>中的分页方法都无法正常起效。<br>所以，我们必须配置分页插件。</p><h3 id="6-1-1-配置分页插件">6.1.1.配置分页插件</h3><p>在项目中新建一个配置类：<br><img src="https://img2.imgtp.com/2024/04/04/9PzTCvqq.png" alt="image.png"><br>其代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp.config;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 初始化核心插件</span><br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        <span class="hljs-comment">// 添加分页插件</span><br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));<br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-1-2-分页API">6.1.2.分页API</h3><p>编写一个分页查询的测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPageQuery</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.分页查询，new Page()的两个参数分别是：页码、每页大小</span><br>    Page&lt;User&gt; p = userService.page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 2.总条数</span><br>    System.out.println(<span class="hljs-string">&quot;total = &quot;</span> + p.getTotal());<br>    <span class="hljs-comment">// 3.总页数</span><br>    System.out.println(<span class="hljs-string">&quot;pages = &quot;</span> + p.getPages());<br>    <span class="hljs-comment">// 4.数据</span><br>    List&lt;User&gt; records = p.getRecords();<br>    records.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行的SQL如下：<br><img src="https://img2.imgtp.com/2024/04/04/5PN2uYu4.png" alt="image.png"></p><p>这里用到了分页参数，Page，即可以支持分页参数，也可以支持排序参数。常见的API如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">pageNo</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, pageSize = <span class="hljs-number">5</span>;<br><span class="hljs-comment">// 分页参数</span><br>Page&lt;User&gt; page = Page.of(pageNo, pageSize);<br><span class="hljs-comment">// 排序参数, 通过OrderItem来指定</span><br>page.addOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(<span class="hljs-string">&quot;balance&quot;</span>, <span class="hljs-literal">false</span>));<br><br>userService.page(page);<br></code></pre></td></tr></table></figure><h2 id="6-2-通用分页实体">6.2.通用分页实体</h2><p>现在要实现一个用户分页查询的接口，接口规范如下：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>/users/page</td></tr><tr><td>请求参数</td><td>```json</td></tr><tr><td>{</td><td></td></tr><tr><td>“pageNo”: 1,</td><td></td></tr><tr><td>“pageSize”: 5,</td><td></td></tr><tr><td>“sortBy”: “balance”,</td><td></td></tr><tr><td>“isAsc”: false</td><td></td></tr><tr><td>}</td><td></td></tr></tbody></table><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;total&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100006</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50003</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;list&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1685100878975279298</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;user_9****&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">24</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;intro&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;英文老师&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;gender&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;female&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;正常&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;balance&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2000</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1685100878975279299</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;user_9****&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">24</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;intro&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;英文老师&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;gender&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;female&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;正常&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;balance&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2000</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>|<br>| 特殊说明 | •如果排序字段为空，默认按照更新时间排序<br>•排序字段不为空，则按照排序字段排序 |</p><p>这里需要定义3个实体：</p><ul><li><code>PageQuery</code>：分页查询条件的实体，包含分页、排序参数</li><li><code>PageDTO</code>：分页结果实体，包含总条数、总页数、当前页数据</li><li><code>UserVO</code>：用户页面视图实体</li></ul><p>接下来我们就按照WEB开发的过程来实现这个接口。<br>首先，我们在项目中引入<code>spring-boot-starter-web</code>依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- web依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- hutool 工具包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后，按<code>alt+8</code>打开<code>service</code>控制台，然后添加一个<code>SpringBoot</code>启动项：<br><img src="https://img2.imgtp.com/2024/04/04/1DTOVtUk.png" alt="image.png"><br>弹窗中选择<code>Spring Boot</code>：<br><img src="https://img2.imgtp.com/2024/04/04/ZmNq45SJ.png" alt="image.png"><br>弹窗中填写信息：<br><img src="https://img2.imgtp.com/2024/04/04/E3jepma1.png" alt="image.png"><br>其中不要忘了配置我们之前添加的数据加密的秘钥。</p><h3 id="6-2-1-实体">6.2.1.实体</h3><p>首先是请求参数的<code>PageQuery</code>实体：<br><img src="https://img2.imgtp.com/2024/04/04/MrS9Q87H.png" alt="image.png"><br><code>PageQuery</code>是前端提交的查询参数，一般包含四个属性：</p><ul><li><code>pageNo</code>：页码</li><li><code>pageSize</code>：每页数据条数</li><li><code>sortBy</code>：排序字段</li><li><code>isAsc</code>：是否升序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp.domain.query;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageQuery</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer pageNo;<br>    <span class="hljs-keyword">private</span> Integer pageSize;<br>    <span class="hljs-keyword">private</span> String sortBy;<br>    <span class="hljs-keyword">private</span> Boolean isAsc;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们定义一个<code>UserVO</code>实体：<br><img src="https://img2.imgtp.com/2024/04/04/ZxSIuWqc.png" alt="image.png"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp.domain.vo;<br><br><span class="hljs-keyword">import</span> com.itheima.mp.domain.po.UserInfo;<br><span class="hljs-keyword">import</span> com.itheima.mp.enums.UserStatus;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserVO</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 详细信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> UserInfo info;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用状态（1正常 2冻结）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> UserStatus status;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 账户余额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer balance;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，则是分页实体PageDTO:<br><img src="https://img2.imgtp.com/2024/04/04/LmM2zHnS.png" alt="image.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp.domain.dto;<br><br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageDTO</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Integer total;<br>    <span class="hljs-keyword">private</span> Integer pages;<br>    <span class="hljs-keyword">private</span> List&lt;T&gt; list;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-2-开发接口">6.2.2.开发接口</h3><p>我们定义一个<code>UserController</code>，在<code>controller</code>中我们定义分页查询用户的接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp.controller;<br><br><span class="hljs-keyword">import</span> com.itheima.mp.domain.dto.PageDTO;<br><span class="hljs-keyword">import</span> com.itheima.mp.domain.query.PageQuery;<br><span class="hljs-keyword">import</span> com.itheima.mp.domain.vo.UserVO;<br><span class="hljs-keyword">import</span> com.itheima.mp.service.UserService;<br><span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;users&quot;)</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserService userService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br>    <span class="hljs-keyword">public</span> PageDTO&lt;UserVO&gt; <span class="hljs-title function_">queryUserByPage</span><span class="hljs-params">(PageQuery query)</span>&#123;<br>        <span class="hljs-keyword">return</span> userService.queryUserByPage(query);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后在<code>UserService</code>中创建<code>queryUserByPage</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">PageDTO&lt;UserVO&gt; <span class="hljs-title function_">queryUserByPage</span><span class="hljs-params">(PageQuery query)</span>;<br></code></pre></td></tr></table></figure><p>接下来，在UserServiceImpl中实现该方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PageDTO&lt;UserVO&gt; <span class="hljs-title function_">queryUserByPage</span><span class="hljs-params">(PageQuery query)</span> &#123;<br>    <span class="hljs-comment">// 1.构建条件</span><br>    <span class="hljs-comment">// 1.1.分页条件</span><br>    Page&lt;User&gt; page = Page.of(query.getPageNo(), query.getPageSize());<br>    <span class="hljs-comment">// 1.2.排序条件</span><br>    <span class="hljs-keyword">if</span> (query.getSortBy() != <span class="hljs-literal">null</span>) &#123;<br>        page.addOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(query.getSortBy(), query.getIsAsc()));<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 默认按照更新时间排序</span><br>        page.addOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(<span class="hljs-string">&quot;update_time&quot;</span>, <span class="hljs-literal">false</span>));<br>    &#125;<br>    <span class="hljs-comment">// 2.查询</span><br>    page(page);<br>    <span class="hljs-comment">// 3.数据非空校验</span><br>    List&lt;User&gt; records = page.getRecords();<br>    <span class="hljs-keyword">if</span> (records == <span class="hljs-literal">null</span> || records.size() &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 无数据，返回空结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageDTO</span>&lt;&gt;(page.getTotal(), page.getPages(), Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">// 4.有数据，转换</span><br>    List&lt;UserVO&gt; list = BeanUtil.copyToList(records, UserVO.class);<br>    <span class="hljs-comment">// 5.封装返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageDTO</span>&lt;UserVO&gt;(page.getTotal(), page.getPages(), list);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，为了让UserStatus枚举可以展示为文字描述，再给UserStatus中的desc字段添加<code>@JsonValue</code>注解：<br><img src="https://img2.imgtp.com/2024/04/04/7vsAS771.png" alt="image.png"><br>启动项目，在页面查看：<br><img src="https://img2.imgtp.com/2024/04/04/bugqTciD.png" alt="image.png"></p><h3 id="6-2-3-改造PageQuery实体">6.2.3.改造PageQuery实体</h3><p>在刚才的代码中，从<code>PageQuery</code>到<code>MybatisPlus</code>的<code>Page</code>之间转换的过程还是比较麻烦的。<br>我们完全可以在<code>PageQuery</code>这个实体中定义一个工具方法，简化开发。<br>像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp.domain.query;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.metadata.OrderItem;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageQuery</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer pageNo;<br>    <span class="hljs-keyword">private</span> Integer pageSize;<br>    <span class="hljs-keyword">private</span> String sortBy;<br>    <span class="hljs-keyword">private</span> Boolean isAsc;<br><br>    <span class="hljs-keyword">public</span> &lt;T&gt;  Page&lt;T&gt; <span class="hljs-title function_">toMpPage</span><span class="hljs-params">(OrderItem ... orders)</span>&#123;<br>        <span class="hljs-comment">// 1.分页条件</span><br>        Page&lt;T&gt; p = Page.of(pageNo, pageSize);<br>        <span class="hljs-comment">// 2.排序条件</span><br>        <span class="hljs-comment">// 2.1.先看前端有没有传排序字段</span><br>        <span class="hljs-keyword">if</span> (sortBy != <span class="hljs-literal">null</span>) &#123;<br>            p.addOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(sortBy, isAsc));<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        <span class="hljs-comment">// 2.2.再看有没有手动指定排序字段</span><br>        <span class="hljs-keyword">if</span>(orders != <span class="hljs-literal">null</span>)&#123;<br>            p.addOrder(orders);<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="hljs-title function_">toMpPage</span><span class="hljs-params">(String defaultSortBy, <span class="hljs-type">boolean</span> isAsc)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.toMpPage(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(defaultSortBy, isAsc));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="hljs-title function_">toMpPageDefaultSortByCreateTimeDesc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> toMpPage(<span class="hljs-string">&quot;create_time&quot;</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="hljs-title function_">toMpPageDefaultSortByUpdateTimeDesc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> toMpPage(<span class="hljs-string">&quot;update_time&quot;</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这样我们在开发也时就可以省去对从<code>PageQuery</code>到<code>Page</code>的的转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.构建条件</span><br>Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();<br></code></pre></td></tr></table></figure><h3 id="6-2-4-改造PageDTO实体">6.2.4.改造PageDTO实体</h3><p>在查询出分页结果后，数据的非空校验，数据的vo转换都是模板代码，编写起来很麻烦。</p><p>我们完全可以将其封装到PageDTO的工具方法中，简化整个过程：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp.domain.dto;<br><br><span class="hljs-keyword">import</span> cn.hutool.core.bean.BeanUtil;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;<br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageDTO</span>&lt;V&gt; &#123;<br>    <span class="hljs-keyword">private</span> Long total;<br>    <span class="hljs-keyword">private</span> Long pages;<br>    <span class="hljs-keyword">private</span> List&lt;V&gt; list;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回空分页结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p MybatisPlus的分页结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;V&gt; 目标VO类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;P&gt; 原始PO类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> VO的分页对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="hljs-title function_">empty</span><span class="hljs-params">(Page&lt;P&gt; p)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将MybatisPlus分页结果转为 VO分页结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p MybatisPlus的分页结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> voClass 目标VO类型的字节码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;V&gt; 目标VO类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;P&gt; 原始PO类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> VO的分页对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(Page&lt;P&gt; p, Class&lt;V&gt; voClass)</span> &#123;<br>        <span class="hljs-comment">// 1.非空校验</span><br>        List&lt;P&gt; records = p.getRecords();<br>        <span class="hljs-keyword">if</span> (records == <span class="hljs-literal">null</span> || records.size() &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 无数据，返回空结果</span><br>            <span class="hljs-keyword">return</span> empty(p);<br>        &#125;<br>        <span class="hljs-comment">// 2.数据转换</span><br>        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);<br>        <span class="hljs-comment">// 3.封装返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p MybatisPlus的分页结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> convertor PO到VO的转换函数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;V&gt; 目标VO类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;P&gt; 原始PO类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> VO的分页对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor)</span> &#123;<br>        <span class="hljs-comment">// 1.非空校验</span><br>        List&lt;P&gt; records = p.getRecords();<br>        <span class="hljs-keyword">if</span> (records == <span class="hljs-literal">null</span> || records.size() &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 无数据，返回空结果</span><br>            <span class="hljs-keyword">return</span> empty(p);<br>        &#125;<br>        <span class="hljs-comment">// 2.数据转换</span><br>        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());<br>        <span class="hljs-comment">// 3.封装返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最终，业务层的代码可以简化为：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PageDTO&lt;UserVO&gt; <span class="hljs-title function_">queryUserByPage</span><span class="hljs-params">(PageQuery query)</span> &#123;<br>    <span class="hljs-comment">// 1.构建条件</span><br>    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();<br>    <span class="hljs-comment">// 2.查询</span><br>    page(page);<br>    <span class="hljs-comment">// 3.封装返回</span><br>    <span class="hljs-keyword">return</span> PageDTO.of(page, UserVO.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是希望自定义PO到VO的转换过程，可以这样做：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PageDTO&lt;UserVO&gt; <span class="hljs-title function_">queryUserByPage</span><span class="hljs-params">(PageQuery query)</span> &#123;<br>    <span class="hljs-comment">// 1.构建条件</span><br>    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();<br>    <span class="hljs-comment">// 2.查询</span><br>    page(page);<br>    <span class="hljs-comment">// 3.封装返回</span><br>    <span class="hljs-keyword">return</span> PageDTO.of(page, user -&gt; &#123;<br>        <span class="hljs-comment">// 拷贝属性到VO</span><br>        <span class="hljs-type">UserVO</span> <span class="hljs-variable">vo</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserVO.class);<br>        <span class="hljs-comment">// 用户名脱敏</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> vo.getUsername();<br>        vo.setUsername(username.substring(<span class="hljs-number">0</span>, username.length() - <span class="hljs-number">2</span>) + <span class="hljs-string">&quot;**&quot;</span>);<br>        <span class="hljs-keyword">return</span> vo;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终查询的结果如下：<br><img src="https://img2.imgtp.com/2024/04/04/TISYE7wq.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> mybatis </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令</title>
      <link href="/2023/08/31/linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/08/31/linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1>Linux基础命令</h1><h2 id="Linux的目录结构">Linux的目录结构</h2><p><img src="https://img2.imgtp.com/2024/04/04/UFhpyMWo.png" alt="image-20221027214128453"></p><ul><li><code>/</code>，根目录是最顶级的目录了</li><li>Linux只有一个顶级目录：<code>/</code></li><li>路径描述的层次关系同样适用<code>/</code>来表示</li><li>/home/itheima/a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt</li></ul><h2 id="ls命令">ls命令</h2><p>功能：列出文件夹信息</p><p>语法：<code>ls [-l -h -a] [参数]</code></p><ul><li>参数：被查看的文件夹，不提供参数，表示查看当前工作目录</li><li>-l，以列表形式查看</li><li>-h，配合-l，以更加人性化的方式显示文件大小</li><li>-a，显示隐藏文件</li></ul><h3 id="隐藏文件、文件夹">隐藏文件、文件夹</h3><p>在Linux中以<code>.</code>开头的，均是隐藏的。</p><p>默认不显示出来，需要<code>-a</code>选项才可查看到。</p><h2 id="pwd命令">pwd命令</h2><p>功能：展示当前工作目录</p><p>语法：<code>pwd</code></p><h2 id="cd命令">cd命令</h2><p>功能：切换工作目录</p><p>语法：<code>cd [目标目录]</code></p><p>参数：目标目录，要切换去的地方，不提供默认切换到<code>当前登录用户HOME目录</code></p><h2 id="HOME目录">HOME目录</h2><p>每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。</p><ul><li><p>普通用户的HOME目录，默认在：<code>/home/用户名</code></p></li><li><p>root用户的HOME目录，在：<code>/root</code></p></li></ul><p>FinalShell登陆终端后，默认的工作目录就是用户的HOME目录</p><h2 id="相对路径、绝对路径">相对路径、绝对路径</h2><ul><li><p>相对路径，==非==<code>/</code>开头的称之为相对路径</p><p>相对路径表示以<code>当前目录</code>作为起点，去描述路径，如<code>test/a.txt</code>，表示当前工作目录内的test文件夹内的a.txt文件</p></li><li><p>绝对路径，==以==<code>/</code>开头的称之为绝对路径</p><p>绝对路径从<code>根</code>开始描述路径</p></li></ul><h2 id="特殊路径符">特殊路径符</h2><ul><li><code>.</code>，表示当前，比如./a.txt，表示当前文件夹内的<code>a.txt</code>文件</li><li><code>..</code>，表示上级目录，比如<code>../</code>表示上级目录，<code>../../</code>表示上级的上级目录</li><li><code>~</code>，表示用户的HOME目录，比如<code>cd ~</code>，即可切回用户HOME目录</li></ul><h2 id="mkdir命令">mkdir命令</h2><p>功能：创建文件夹</p><p>语法：<code>mkdir [-p] 参数</code></p><ul><li>参数：被创建文件夹的路径</li><li>选项：-p，可选，表示创建前置路径</li></ul><h2 id="touch命令">touch命令</h2><p>功能：创建文件</p><p>语法：<code>touch 参数</code></p><ul><li>参数：被创建的文件路径</li></ul><h2 id="cat命令">cat命令</h2><p>功能：查看文件内容</p><p>语法：<code>cat 参数</code></p><ul><li>参数：被查看的文件路径</li></ul><h2 id="more命令">more命令</h2><p>功能：查看文件，可以支持翻页查看</p><p>语法：<code>more 参数</code></p><ul><li>参数：被查看的文件路径</li><li>在查看过程中：<ul><li><code>空格</code>键翻页</li><li><code>q</code>退出查看</li></ul></li></ul><h2 id="cp命令">cp命令</h2><p>功能：复制文件、文件夹</p><p>语法：<code>cp [-r] 参数1 参数2</code></p><ul><li>参数1，被复制的</li><li>参数2，要复制去的地方</li><li>选项：-r，可选，复制文件夹使用</li></ul><p>示例：</p><ul><li>cp a.txt b.txt，复制当前目录下a.txt为b.txt</li><li>cp a.txt test/，复制当前目录a.txt到test文件夹内</li><li>cp -r test test2，复制文件夹test到当前文件夹内为test2存在</li></ul><h2 id="mv命令">mv命令</h2><p>功能：移动文件、文件夹</p><p>语法：<code>mv 参数1 参数2</code></p><ul><li>参数1：被移动的</li><li>参数2：要移动去的地方，参数2如果不存在，则会进行改名</li></ul><h2 id="rm命令">rm命令</h2><p>功能：删除文件、文件夹</p><p>语法：<code>rm [-r -f] 参数...参数</code></p><ul><li>参数：支持多个，每一个表示被删除的，空格进行分隔</li><li>选项：-r，删除文件夹使用</li><li>选项：-f，强制删除，不会给出确认提示，一般root用户会用到</li></ul><blockquote><p>rm命令很危险，一定要注意，特别是切换到root用户的时候。</p></blockquote><h2 id="which命令">which命令</h2><p>功能：查看命令的程序本体文件路径</p><p>语法：<code>which 参数</code></p><ul><li>参数：被查看的命令</li></ul><h2 id="find命令">find命令</h2><p>功能：搜索文件</p><p>语法1按文件名搜索：<code>find 路径 -name 参数</code></p><ul><li>路径，搜索的起始路径</li><li>参数，搜索的关键字，支持通配符*， 比如：<code>*</code>test表示搜索任意以test结尾的文件</li></ul><h2 id="grep命令">grep命令</h2><p>功能：过滤关键字</p><p>语法：<code>grep [-n] 关键字 文件路径</code></p><ul><li>选项-n，可选，表示在结果中显示匹配的行的行号。</li><li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来</li><li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li></ul><blockquote><p>参数文件路径，可以作为管道符的输入</p></blockquote><h2 id="wc命令">wc命令</h2><p>功能：统计</p><p>语法：<code>wc [-c -m -l -w] 文件路径</code></p><ul><li>选项，-c，统计bytes数量</li><li>选项，-m，统计字符数量</li><li>选项，-l，统计行数</li><li>选项，-w，统计单词数量</li><li>参数，文件路径，被统计的文件，可作为内容输入端口</li></ul><blockquote><p>参数文件路径，可作为管道符的输入</p></blockquote><h2 id="管道符">管道符|</h2><p>写法：<code>|</code></p><p>功能：将符号左边的结果，作为符号右边的输入</p><p>示例：</p><p><code>cat a.txt | grep itheima</code>，将cat a.txt的结果，作为grep命令的输入，用来过滤<code>itheima</code>关键字</p><p>可以支持嵌套：</p><p><code>cat a.txt | grep itheima | grep itcast</code></p><h2 id="echo命令">echo命令</h2><p>功能：输出内容</p><p>语法：<code>echo 参数</code></p><ul><li>参数：被输出的内容</li></ul><h2 id="反引号">`反引号</h2><p>功能：被两个反引号包围的内容，会作为命令执行</p><p>示例：</p><ul><li>echo `pwd`，会输出当前工作目录</li></ul><h2 id="tail命令">tail命令</h2><p>功能：查看文件尾部内容</p><p>语法：<code>tail [-f] 参数</code></p><ul><li>参数：被查看的文件</li><li>选项：-f，持续跟踪文件修改</li></ul><h2 id="head命令">head命令</h2><p>功能：查看文件头部内容</p><p>语法：<code>head [-n] 参数</code></p><ul><li>参数：被查看的文件</li><li>选项：-n，查看的行数</li></ul><h2 id="重定向符">重定向符</h2><p>功能：将符号左边的结果，输出到右边指定的文件中去</p><ul><li><code>&gt;</code>，表示覆盖输出</li><li><code>&gt;&gt;</code>，表示追加输出</li></ul><h2 id="vi编辑器">vi编辑器</h2><h3 id="命令模式快捷键">命令模式快捷键</h3><p><img src="https://img2.imgtp.com/2024/04/04/aH53Uduc.png" alt="image-20221027215841573"></p><p><img src="https://img2.imgtp.com/2024/04/04/p02DY5QW.png" alt="image-20221027215846581"></p><p><img src="https://img2.imgtp.com/2024/04/04/aNpIGFGY.png" alt="image-20221027215849668"></p><h3 id="底线命令快捷键">底线命令快捷键</h3><p><img src="https://img2.imgtp.com/2024/04/04/iX1KSby5.png" alt="image-20221027215858967"></p><h2 id="命令的选项">命令的选项</h2><p>我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。</p><p>比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I -k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X -1等选项，可以发现选项是极其多的。</p><p>课程中， 并不会将全部的选项都进行讲解，否则，一个ls命令就可能讲解2小时之久。</p><p>课程中，会对常见的选项进行讲解， 足够满足绝大多数的学习、工作场景。</p><h3 id="查看命令的帮助">查看命令的帮助</h3><p>可以通过：<code>命令 --help</code>查看命令的帮助手册</p><p><img src="https://img2.imgtp.com/2024/04/04/RNnIvkHk.png" alt="image-20221027220005610"></p><h3 id="查看命令的详细手册">查看命令的详细手册</h3><p>可以通过：<code>man 命令</code>查看某命令的详细手册</p><p><img src="https://img2.imgtp.com/2024/04/04/ykCettDo.png" alt="image-20221027220009949"></p><h1>Linux常用操作</h1><h2 id="软件安装">软件安装</h2><ul><li>CentOS系统使用：<ul><li>yum [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li><li>Ubuntu系统使用<ul><li>apt [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li></ul><blockquote><p>yum 和 apt 均需要root权限</p></blockquote><h2 id="systemctl">systemctl</h2><p>功能：控制系统服务的启动关闭等</p><p>语法：<code>systemctl start | stop | restart | disable | enable | status 服务名</code></p><ul><li>start，启动</li><li>stop，停止</li><li>status，查看状态</li><li>disable，关闭开机自启</li><li>enable，开启开机自启</li><li>restart，重启</li></ul><h2 id="软链接">软链接</h2><p>功能：创建文件、文件夹软链接（快捷方式）</p><p>语法：<code>ln -s 参数1 参数2</code></p><ul><li>参数1：被链接的</li><li>参数2：要链接去的地方（快捷方式的名称和存放位置）</li></ul><h2 id="日期">日期</h2><p>语法：<code>date [-d] [+格式化字符串]</code></p><ul><li><p>-d 按照给定的字符串显示日期，一般用于日期计算</p></li><li><p>格式化字符串：通过特定的字符串标记，来控制显示的日期格式</p><ul><li>%Y   年%y   年份后两位数字 (00…99)</li><li>%m   月份 (01…12)</li><li>%d   日 (01…31)</li><li>%H   小时 (00…23)</li><li>%M   分钟 (00…59)</li><li>%S   秒 (00…60)</li><li>%s   自 1970-01-01 00:00:00 UTC 到现在的秒数</li></ul></li></ul><p>示例：</p><ul><li><p>按照2022-01-01的格式显示日期</p><p><img src="https://img2.imgtp.com/2024/04/04/7xyxDDbC.png" alt="image-20221027220514640"></p></li><li><p>按照2022-01-01 10:00:00的格式显示日期</p><p><img src="https://img2.imgtp.com/2024/04/04/4RBuGP5V.png" alt="image-20221027220525625"></p></li><li><p>-d选项日期计算</p><p><img src="https://img2.imgtp.com/2024/04/04/S83qGSs2.png" alt="image-20221027220429831"></p><ul><li><p>支持的时间标记为：</p><p><img src="https://img2.imgtp.com/2024/04/04/oOfYmZLC.png" alt="image-20221027220449312"></p></li></ul></li></ul><h2 id="时区">时区</h2><p>修改时区为中国时区</p><p><img src="https://img2.imgtp.com/2024/04/04/q1c0Nuyl.png" alt="image-20221027220554654"></p><h2 id="ntp">ntp</h2><p>功能：同步时间</p><p>安装：<code>yum install -y ntp</code></p><p>启动管理：<code>systemctl start | stop | restart | status | disable | enable ntpd</code></p><p>手动校准时间：<code>ntpdate -u ntp.aliyun.com</code></p><h2 id="ip地址">ip地址</h2><p>格式：a.b.c.d</p><ul><li>abcd为0~255的数字</li></ul><p>特殊IP：</p><ul><li>127.0.0.1，表示本机</li><li>0.0.0.0<ul><li>可以表示本机</li><li>也可以表示任意IP（看使用场景）</li></ul></li></ul><p>查看ip：<code>ifconfig</code></p><h2 id="主机名">主机名</h2><p>功能：Linux系统的名称</p><p>查看：<code>hostname</code></p><p>设置：<code>hostnamectl set-hostname 主机名</code></p><h2 id="配置VMware固定IP">配置VMware固定IP</h2><ol><li><p>修改VMware网络，参阅PPT，图太多</p></li><li><p>设置Linux内部固定IP</p><p>修改文件：<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p>示例文件内容：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">TYPE=&quot;Ethernet&quot;<br>PROXY_METHOD=&quot;none&quot;<br>BROWSER_ONLY=&quot;no&quot;<br>BOOTPROTO=&quot;static&quot;# 改为static，固定IP<br>DEFROUTE=&quot;yes&quot;<br>IPV4_FAILURE_FATAL=&quot;no&quot;<br>IPV6INIT=&quot;yes&quot;<br>IPV6_AUTOCONF=&quot;yes&quot;<br>IPV6_DEFROUTE=&quot;yes&quot;<br>IPV6_FAILURE_FATAL=&quot;no&quot;<br>IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;<br>NAME=&quot;ens33&quot;<br>UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;<br>DEVICE=&quot;ens33&quot;<br>ONBOOT=&quot;yes&quot;<br>IPADDR=&quot;192.168.88.131&quot;# IP地址，自己设置，要匹配网络范围<br>NETMASK=&quot;255.255.255.0&quot;# 子网掩码，固定写法255.255.255.0<br>GATEWAY=&quot;192.168.88.2&quot;# 网关，要和VMware中配置的一致<br>DNS1=&quot;192.168.88.2&quot;# DNS1服务器，和网关一致即可<br></code></pre></td></tr></table></figure></li></ol><h2 id="ps命令">ps命令</h2><p>功能：查看进程信息</p><p>语法：<code>ps -ef</code>，查看全部进程信息，可以搭配grep做过滤：<code>ps -ef | grep xxx</code></p><h2 id="kill命令">kill命令</h2><p><img src="https://img2.imgtp.com/2024/04/04/fzG2yCUX.png" alt="image-20221027221303037"></p><h2 id="nmap命令">nmap命令</h2><p><img src="https://img2.imgtp.com/2024/04/04/ZckyLybr.png" alt="image-20221027221241123"></p><h2 id="netstat命令">netstat命令</h2><p>功能：查看端口占用</p><p>用法：<code>netstat -anp | grep xxx</code></p><h2 id="ping命令">ping命令</h2><p>测试网络是否联通</p><p>语法：<code>ping [-c num] 参数</code></p><p><img src="https://img2.imgtp.com/2024/04/04/Weu7LYY3.png" alt="image-20221027221129782"></p><h2 id="wget命令">wget命令</h2><p><img src="https://img2.imgtp.com/2024/04/04/toiW6T0Z.png" alt="image-20221027221148964"></p><h2 id="curl命令">curl命令</h2><p><img src="https://img2.imgtp.com/2024/04/04/o7Zlsbtq.png" alt="image-20221027221201079"></p><p><img src="https://img2.imgtp.com/2024/04/04/22roDYbk.png" alt="image-20221027221210518"></p><h2 id="top命令">top命令</h2><p>功能：查看主机运行状态</p><p>语法：<code>top</code>，查看基础信息</p><p>可用选项：</p><p><img src="https://img2.imgtp.com/2024/04/04/cXwFstka.png" alt="image-20221027221340729"></p><p>交互式模式中，可用快捷键：</p><p><img src="https://img2.imgtp.com/2024/04/04/XVV4QXh8.png" alt="image-20221027221354137"></p><h2 id="df命令">df命令</h2><p>查看磁盘占用</p><p><img src="https://img2.imgtp.com/2024/04/04/aCglbwOW.png" alt="image-20221027221413787"></p><h2 id="iostat命令">iostat命令</h2><p>查看CPU、磁盘的相关信息</p><p><img src="https://img2.imgtp.com/2024/04/04/OX0Z6uiP.png" alt="image-20221027221439990"></p><p><img src="https://img2.imgtp.com/2024/04/04/PZY82TET.png" alt="image-20221027221514237"></p><h2 id="sar命令">sar命令</h2><p>查看网络统计</p><p><img src="https://img2.imgtp.com/2024/04/04/Jc0zGHH7.png" alt="image-20221027221545822"></p><h2 id="环境变量">环境变量</h2><ul><li>临时设置：export 变量名=变量值</li><li>永久设置：<ul><li>针对用户，设置用户HOME目录内：<code>.bashrc</code>文件</li><li>针对全局，设置<code>/etc/profile</code></li></ul></li></ul><h3 id="PATH变量">PATH变量</h3><p>记录了执行程序的搜索路径</p><p>可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果</p><h2 id="符号">$符号</h2><p>可以取出指定的环境变量的值</p><p>语法：<code>$变量名</code></p><p>示例：</p><p><code>echo $PATH</code>，输出PATH环境变量的值</p><p><code>echo $&#123;PATH&#125;ABC</code>，输出PATH环境变量的值以及ABC</p><p>如果变量名和其它内容混淆在一起，可以使用${}</p><h2 id="压缩解压">压缩解压</h2><h3 id="压缩">压缩</h3><p><code>tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N</code></p><ul><li>-z表示使用gzip，可以不写</li></ul><p><code>zip [-r] 参数1 参数2 参数N</code></p><p><img src="https://img2.imgtp.com/2024/04/04/YymK6Zqf.png" alt="image-20221027221906247"></p><h3 id="解压">解压</h3><p><code>tar -zxvf 被解压的文件 -C 要解压去的地方</code></p><ul><li>-z表示使用gzip，可以省略</li><li>-C，可以省略，指定要解压去的地方，不写解压到当前目录</li></ul><p><code>unzip [-d] 参数</code></p><p><img src="https://img2.imgtp.com/2024/04/04/kbsIwjTL.png" alt="image-20221027221939899"></p><h2 id="su命令">su命令</h2><p>切换用户</p><p>语法：<code>su [-] [用户]</code></p><p><img src="https://img2.imgtp.com/2024/04/04/W3XaUBq4.png" alt="image-20221027222021619"></p><h2 id="sudo命令">sudo命令</h2><p><img src="https://img2.imgtp.com/2024/04/04/4ENGnxRy.png" alt="image-20221027222035337"></p><p>比如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">itheima ALL=(ALL)       NOPASSWD: ALL<br></code></pre></td></tr></table></figure><p>在visudo内配置如上内容，可以让itheima用户，无需密码直接使用<code>sudo</code></p><h2 id="chmod命令">chmod命令</h2><p>修改文件、文件夹权限</p><p>语法：<code>chmod [-R] 权限 参数</code></p><ul><li><p>权限，要设置的权限，比如755，表示：<code>rwxr-xr-x</code></p><p><img src="https://img2.imgtp.com/2024/04/04/DGMPOMyo.png" alt="image-20221027222157276"></p></li><li><p>参数，被修改的文件、文件夹</p></li><li><p>选项-R，设置文件夹和其内部全部内容一样生效</p></li></ul><h2 id="chown命令">chown命令</h2><p>修改文件、文件夹所属用户、组</p><p>语法：<code>chown [-R] [用户][:][用户组] 文件或文件夹</code></p><p><img src="https://img2.imgtp.com/2024/04/04/roaBobET.png" alt="image-20221027222326192"></p><h2 id="用户组管理">用户组管理</h2><p><img src="https://img2.imgtp.com/2024/04/04/2wzs2Nnw.png" alt="image-20221027222354498"></p><h2 id="用户管理">用户管理</h2><p><img src="https://img2.imgtp.com/2024/04/04/uShgLnjQ.png" alt="image-20221027222407618"></p><h2 id="genenv命令">genenv命令</h2><ul><li><p><code>getenv group</code>，查看系统全部的用户组</p><p><img src="https://img2.imgtp.com/2024/04/04/uR58hkBR.png" alt="image-20221027222446514"></p></li><li><p><code>getenv passwd</code>，查看系统全部的用户</p><p><img src="https://img2.imgtp.com/2024/04/04/NkolWyGp.png" alt="image-20221027222512274"></p></li></ul><h2 id="env命令">env命令</h2><p>查看系统全部的环境变量</p><p>语法：<code>env</code></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2023/07/28/mysql/"/>
      <url>/2023/07/28/mysql/</url>
      
        <content type="html"><![CDATA[<h1>MySQL</h1><h2 id="执行编写顺序">执行编写顺序</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 语句编写和执行顺序</span><br><span class="hljs-keyword">select</span>    <span class="hljs-comment">-- 4</span><br>    字段列表<br><span class="hljs-keyword">from</span>    <span class="hljs-comment">-- 1</span><br>    表名列表<br><span class="hljs-keyword">where</span>    <span class="hljs-comment">-- 2</span><br>    条件列表<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-comment">--3</span><br>    分组字段列表<br><span class="hljs-keyword">having</span>     <br>    分组后条件列表<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-comment">--5</span><br>    排序字段列表<br>limit     <span class="hljs-comment">--6</span><br>    分页参数<br></code></pre></td></tr></table></figure><h1>一、数据定义语言DDL</h1><h2 id="1、数据库操作">1、数据库操作</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># DDL<span class="hljs-operator">-</span>数据库操作<br><span class="hljs-keyword">show</span> databases;                          #显示所有数据库<br><span class="hljs-keyword">create</span> database [if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>] 数据库名;    #创建数据库<br>use 数据库名 ;                              #使用数据库<br><span class="hljs-keyword">select</span> database();                          #显示当前在哪个数据库下<br><span class="hljs-keyword">drop</span> database [if <span class="hljs-keyword">exists</span>] 数据库名;            #删库跑路<br></code></pre></td></tr></table></figure><h2 id="2、表操作">2、表操作</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- DDL-表操作</span><br><span class="hljs-keyword">show</span> tables;# 显示所有表<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(字段 字段类型，字段 字段类型……) # 创建表<br><span class="hljs-keyword">desc</span> 表名 #查看表中所有字段<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span>(添加字段)<span class="hljs-operator">/</span>modify(修改字段类型)<span class="hljs-operator">/</span>change(修改字段名及类型)<span class="hljs-operator">/</span><span class="hljs-keyword">drop</span>(删除字段)<span class="hljs-operator">/</span>rename <span class="hljs-keyword">to</span>(修改表名);<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> 表名;# 删除表<br></code></pre></td></tr></table></figure><h1>二、 DML（增删改）</h1><h2 id="insert-update-delete">insert update delete</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 插入一条语句<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(id, name, age, gender)<br><span class="hljs-keyword">values</span> (<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;cxk&#x27;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;男&#x27;</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(id, name, age, gender)<br><span class="hljs-keyword">values</span> (<span class="hljs-number">456</span>, <span class="hljs-string">&#x27;ikun&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;男&#x27;</span>);<br><br># 插入多条语句<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">values</span> (<span class="hljs-number">456</span>, <span class="hljs-string">&#x27;ikun&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;男&#x27;</span>),<br>(<span class="hljs-number">456</span>, <span class="hljs-string">&#x27;ikun&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;男&#x27;</span>),<br>(<span class="hljs-number">456</span>, <span class="hljs-string">&#x27;ikun&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;男&#x27;</span>),<br>(<span class="hljs-number">456</span>, <span class="hljs-string">&#x27;ikun&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;男&#x27;</span>);<br><br># 查看表<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br><br># 修改 把name为ikun的name全部改为小黑子<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;小黑子&#x27;</span><br><span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ikun&#x27;</span>;<br><br># 把name为cxk的 name改为鸡哥，性别改为女<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">set</span> name  <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;鸡哥&#x27;</span>,<br>gender<span class="hljs-operator">=</span><span class="hljs-string">&#x27;女&#x27;</span><br><span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;cxk&#x27;</span>;<br><br># 把所有人的年龄改为<span class="hljs-number">69</span><br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">69</span>;<br><br># 删除 name为小黑子的人<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;小黑子&#x27;</span>;<br><br># 删除所有人<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><h1>三、DQL（查）</h1><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表并插入数据--------------------------------------------</span><br><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> employee;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp<br>(<br>id          <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;编号&#x27;</span>,<br>workno      <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;工号&#x27;</span>,<br>name        <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>gender      <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span>,<br>age         tinyint unsigned comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>idcard      <span class="hljs-type">char</span>(<span class="hljs-number">18</span>) comment <span class="hljs-string">&#x27;身份证号&#x27;</span>,<br>workaddress <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) comment <span class="hljs-string">&#x27;工作地址&#x27;</span>,<br>entrydate   <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span><br>) comment <span class="hljs-string">&#x27;员工表&#x27;</span>;<br><br><span class="hljs-comment">-- 插入数据--------------------------------------------------------</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;00001&#x27;</span>, <span class="hljs-string">&#x27;柳岩&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;123456789012345678&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2000-01-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;00002&#x27;</span>, <span class="hljs-string">&#x27;张无忌&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;123456789012345670&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2005-09-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;00003&#x27;</span>, <span class="hljs-string">&#x27;韦一笑&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">38</span>, <span class="hljs-string">&#x27;123456789712345670&#x27;</span>, <span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-string">&#x27;2005-08-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;00004&#x27;</span>, <span class="hljs-string">&#x27;赵敏&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;123456757123845670&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2009-12-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;00005&#x27;</span>, <span class="hljs-string">&#x27;小昭&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&#x27;123456769012345678&#x27;</span>, <span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-string">&#x27;2007-07-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;00006&#x27;</span>, <span class="hljs-string">&#x27;杨逍&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">28</span>, <span class="hljs-string">&#x27;12345678931234567X&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2006-01-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;00007&#x27;</span>, <span class="hljs-string">&#x27;范瑶&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&#x27;123456789212345670&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2005-05-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;00008&#x27;</span>, <span class="hljs-string">&#x27;黛绮丝&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">38</span>, <span class="hljs-string">&#x27;123456157123645670&#x27;</span>, <span class="hljs-string">&#x27;天津&#x27;</span>, <span class="hljs-string">&#x27;2015-05-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;00009&#x27;</span>, <span class="hljs-string">&#x27;范凉凉&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">45</span>, <span class="hljs-string">&#x27;123156789012345678&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2010-04-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;00010&#x27;</span>, <span class="hljs-string">&#x27;陈友谅&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">53</span>, <span class="hljs-string">&#x27;123456789012345670&#x27;</span>, <span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-string">&#x27;2011-01-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;00011&#x27;</span>, <span class="hljs-string">&#x27;张士诚&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">55</span>, <span class="hljs-string">&#x27;123567897123465670&#x27;</span>, <span class="hljs-string">&#x27;江苏&#x27;</span>, <span class="hljs-string">&#x27;2015-05-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;00012&#x27;</span>, <span class="hljs-string">&#x27;常遇春&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;123446757152345670&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2004-02-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">13</span>, <span class="hljs-string">&#x27;00013&#x27;</span>, <span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">88</span>, <span class="hljs-string">&#x27;123656789012345678&#x27;</span>, <span class="hljs-string">&#x27;江苏&#x27;</span>, <span class="hljs-string">&#x27;2020-11-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">14</span>, <span class="hljs-string">&#x27;00014&#x27;</span>, <span class="hljs-string">&#x27;灭绝&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">65</span>, <span class="hljs-string">&#x27;123456719012345670&#x27;</span>, <span class="hljs-string">&#x27;西安&#x27;</span>, <span class="hljs-string">&#x27;2019-05-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;00015&#x27;</span>, <span class="hljs-string">&#x27;胡青牛&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">70</span>, <span class="hljs-string">&#x27;12345674971234567X&#x27;</span>, <span class="hljs-string">&#x27;西安&#x27;</span>, <span class="hljs-string">&#x27;2018-04-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;00016&#x27;</span>, <span class="hljs-string">&#x27;周芷若&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2012-06-01&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="1、select-from">1、select from</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 基本查询-------------------------------------------------------</span><br><br><span class="hljs-comment">-- 1、查询指定字段 name,workno,age返回</span><br><span class="hljs-keyword">select</span> name, workno, age<br><span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-comment">-- 2、查询返回所有字段</span><br><span class="hljs-keyword">select</span> id,<br> workno,<br> name,<br> gender,<br> age,<br> idcard,<br> workaddress,<br> entrydate<br><span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-comment">-- 也可以查询所有字段，但实际使用中不建议，因为不明确</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-comment">-- 3、查询所有员工的工作地址并 起一个别名(as可以省略)</span><br><span class="hljs-keyword">select</span> workaddress <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;工作地址&#x27;</span> <span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-comment">-- 4、查询所有员工的工作地址并去除重复地址</span><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> workaddress <span class="hljs-string">&#x27;上班地址&#x27;</span> <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><h2 id="2、where">2、where</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 条件查询 where-------------------------------------------------</span><br><br><span class="hljs-comment">-- 1、查询年龄为88的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age<span class="hljs-operator">=</span><span class="hljs-number">88</span>;<br><br><span class="hljs-comment">-- 2、查询年龄小于20的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age<span class="hljs-operator">&lt;</span><span class="hljs-number">20</span>;<br><br><span class="hljs-comment">-- 3、查询没有身份证号码的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br><br><span class="hljs-comment">-- 4、查询有身份证号码的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br><br><span class="hljs-comment">-- 5、查询年龄不等于88的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">!=</span> <span class="hljs-number">88</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">88</span>;<br><br><span class="hljs-comment">-- 6、查询年龄在15到20（两端都包含）之间的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">15</span> <span class="hljs-operator">&amp;&amp;</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">20</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">15</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">20</span>;<br><span class="hljs-comment">-- between and 小的在前面 大的在后面 否则什么都查不到</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">15</span> <span class="hljs-keyword">and</span> <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">-- 7、查询性别为女且年龄小于25的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">25</span>;<br><br><span class="hljs-comment">-- 8、查询年龄或等于18或20或40的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span> <span class="hljs-operator">||</span>age <span class="hljs-operator">=</span> <span class="hljs-number">20</span> <span class="hljs-operator">||</span> age <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">20</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-keyword">in</span> (<span class="hljs-number">18</span>,<span class="hljs-number">20</span>,<span class="hljs-number">40</span>);<br><br><span class="hljs-comment">-- 9、查询名字为两个字的员工的信息 模糊匹配：like _对应单个字符 %对应多个字符</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;__&#x27;</span>;<br><br><span class="hljs-comment">-- 10、查询身份证号最后一位是X的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%X&#x27;</span>;<br># <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;_________________X&#x27;</span>; 这样不太好<br><br><span class="hljs-comment">-- 11、查询身份证号倒数第九位是0的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%0________&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="3、count、max、group">3、count、max、group</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 聚合函数 max min avg:最大最小平均值 sum:整列数据加起来 count:统计整列数据的个数 作用于列 所有聚合函数不参与null的计算--</span><br><br><br><span class="hljs-comment">-- 1、统计企业员工数量</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp; <span class="hljs-comment">-- 16</span><br><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(idcard) <span class="hljs-keyword">from</span> emp; <span class="hljs-comment">-- 15因为有一个员工的身份证号码为null</span><br><br><span class="hljs-comment">-- 2、统计所有员工的平均年龄</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(age) <span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-comment">-- 3、查询最大的年龄</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(age) <span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-comment">-- 4、查询最小的年龄</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(age) <span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-comment">-- 5、统计西安地区员工年龄之和</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(age) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> workaddress <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;西安&#x27;</span>;<br><br><span class="hljs-comment">-- 分组查询 group by   [having 条件]</span><br><br><span class="hljs-comment">-- 1、根据性别分组，分别统计男女人数</span><br><span class="hljs-comment">-- 根据什么字段分组就查询什么字段，查询其他字段无意义</span><br><span class="hljs-comment">-- count(*)此处表示每组的数量</span><br><span class="hljs-keyword">select</span> gender,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br><br><span class="hljs-comment">-- 2、根据性别分组，分别统计男女平均年龄</span><br><span class="hljs-keyword">select</span> gender,<span class="hljs-built_in">avg</span>(age) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br><br><span class="hljs-comment">-- 3、查询年龄小于45的员工，并根据工作地址分组，获取员工数量大于等于3的工作地址</span><br><span class="hljs-comment">-- having后面也接条件，与where不同的是，having对分组后的数据进行操作,having可以对聚合函数进行判断，where不行</span><br><span class="hljs-comment">-- 执行顺序：where&gt;聚合函数&gt;having 分组后查询字段一般为聚合函数或分组字段，因为查询其他字段无意义</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> address_count,workaddress <span class="hljs-keyword">from</span> emp <br><span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">45</span> <br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> workaddress <span class="hljs-keyword">having</span> address_count <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h2 id="4、order-by">4、order by</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 排序查询 order by----------------------------------------------</span><br><br><span class="hljs-comment">-- 1、根据年龄对员工进行排序</span><br><span class="hljs-comment">-- 升序排序</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age; <span class="hljs-comment">-- 默认升序排序</span><br># <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span>;<br><br><span class="hljs-comment">-- 降序排序</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">desc</span>;<br><br><span class="hljs-comment">-- 2、根据入职时间，对员工进行降序排序</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> entrydate <span class="hljs-keyword">desc</span>;<br><br><span class="hljs-comment">-- 3、根据年龄升序排序，若年龄相同，根据入职时间降序排序</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age, entrydate <span class="hljs-keyword">desc</span>;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name <span class="hljs-keyword">desc</span>;<br><br><span class="hljs-comment">-- 分页查询(把所有数据一页一页展示出来) limit 起始索引，查询的个数---------&gt;起始索引=（页码数-1）*每页展示数--------------------------------------------------------------------</span><br><span class="hljs-comment">-- 分页查询limit是MySQL的方言，不同的数据库语言有不同的实现</span><br><br><span class="hljs-comment">-- 1、查询第1页员工数据，查询个数为10</span><br># <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp limit <span class="hljs-number">0</span>,<span class="hljs-number">10</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br>limit <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 第一页的其实索引可以省略</span><br><br><span class="hljs-comment">-- 2、查询第2页员工数据，查询个数为10,不足10条则全部显示</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br>limit <span class="hljs-number">10</span>,<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h2 id="5、案例">5、案例</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- DQL案例--------------------------------------------------------</span><br><br><span class="hljs-comment">-- 1.查询年龄为20,21,22,23岁的员工信息。</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br><span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">21</span><br><span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">22</span><br><span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> age <span class="hljs-keyword">in</span> (<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>);<br><br><span class="hljs-comment">-- 2.查询性别为男，并且年龄在20-40岁（含）以内的姓名为三个字的员工。</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span><br><span class="hljs-keyword">and</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">40</span><br><span class="hljs-keyword">and</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;___&#x27;</span>;<br><br><span class="hljs-comment">-- 3.统计员工表中，年龄小于60岁的，男性员工和女性员工的人数。</span><br><span class="hljs-keyword">select</span> gender, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">60</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br><br><span class="hljs-comment">-- 4.查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序。</span><br><span class="hljs-keyword">select</span> name, age, entrydate<br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">35</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age, entrydate <span class="hljs-keyword">desc</span>;<br><br><span class="hljs-comment">-- 5.查询性别为男，且年龄在20-40岁（含）以内的员工信息，对查询的结果按年龄升序排序，年龄相同按入职时间升序排序,取前5个员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span><br><span class="hljs-keyword">and</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">40</span>;<br></code></pre></td></tr></table></figure><h1>四、 DCL</h1><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- DCL---------------------------------------------------------</span><br><br><span class="hljs-comment">-- 创建用户</span><br><span class="hljs-comment">-- 创建用户‘tanking’，只能在当前主机localhost访问，密码是123456</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;tanking&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><br><span class="hljs-comment">-- 创建用户‘cxk’，能在任意主机访问数据库，密码 ctrljntm,%为通配符</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;cxk&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;ctrljntm&#x27;</span>;<br><br><span class="hljs-comment">-- 修改cxk密码为‘123’</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;cxk&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">with</span> mysql_native_password <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123&#x27;</span>;<br><br><span class="hljs-comment">-- 删除用户‘tanking’</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;tanking&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br><br><span class="hljs-comment">-- 查询权限---------------------------------------------------</span><br><span class="hljs-keyword">show</span> grants <span class="hljs-keyword">for</span> cxk;<br><br><span class="hljs-comment">-- 给 用户cxk 授予 对clb数据库中所有表操作 的 所有权限</span><br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> clb.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;cxk&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br><br><span class="hljs-comment">-- 撤销 cxk对clb数据库中所有表操作的所有权限</span><br><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> clb.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;cxk&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure><h1>五、 函数</h1><h2 id="1、字符串函数">1、字符串函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 字符串函数----------------------------------------------</span><br><span class="hljs-comment">-- concat 拼接字符串</span><br><span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;mysql&#x27;</span>);<br><br><span class="hljs-comment">-- lower 字符串全部小写</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">lower</span>(<span class="hljs-string">&#x27;HelloWorld&#x27;</span>);<br><br><span class="hljs-comment">-- upper 字符串全部大写</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">upper</span>(<span class="hljs-string">&#x27;helloworld&#x27;</span>);<br><br><span class="hljs-comment">-- lpad 左填充 中间的参数表示 字符串的长度，最后参数表示 以什么字符填充</span><br><span class="hljs-keyword">select</span> lpad(<span class="hljs-string">&#x27;cxk&#x27;</span>, <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;-&#x27;</span>);<br><br><span class="hljs-comment">-- rpad 右填充 参数同上</span><br><span class="hljs-keyword">select</span> rpad(<span class="hljs-string">&#x27;cxk&#x27;</span>, <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>);<br><br><span class="hljs-comment">-- trim 去除字符串头尾的空格</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27;  cxk ctrl &#x27;</span>);<br><br><span class="hljs-comment">-- substring(str,1,5) 截取字符串 此处表示截取 从索引1开始截取 字符串str 长度为5 的 子串（注意这个索引是从1开始的）</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;hello_mysql&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><h2 id="2、数值函数">2、数值函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 数值函数----------------------------------------------</span><br><br><span class="hljs-comment">-- ceil 向上取整，只要小数位不是0，就加1</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.1</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.0</span>);<br><br><span class="hljs-comment">-- floor 向下取整</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">floor</span>(<span class="hljs-number">1.9</span>);<br><br><span class="hljs-comment">-- mod 模 （取余数）</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>);<br><br><span class="hljs-comment">-- rand 生成 0~1之间 的随机数</span><br><span class="hljs-keyword">select</span> rand();<br><br><span class="hljs-comment">-- round 四舍五入 保留位数</span><br><span class="hljs-keyword">select</span> round(<span class="hljs-number">2.305</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">-- 对2.305四舍五入，保留2位小数</span><br><br><span class="hljs-comment">-- 案例：生成一个6位数的随机验证码</span><br><span class="hljs-keyword">select</span> lpad(round(rand(), <span class="hljs-number">6</span>) <span class="hljs-operator">*</span> <span class="hljs-number">1000000</span>, <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;0&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="3、日期函数">3、日期函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 日期函数</span><br><br><span class="hljs-comment">-- curdate 返回当前日期</span><br><span class="hljs-keyword">select</span> curdate();<br><br><span class="hljs-comment">-- curtime 返回当前时间</span><br><span class="hljs-keyword">select</span> curtime();<br><br><span class="hljs-comment">-- now 返回当前时间和日期</span><br><span class="hljs-keyword">select</span> now();<br><br><span class="hljs-comment">-- year month day 分别获取 年月日</span><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">year</span>(now());<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">month</span>(now());<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">day</span>(now());<br><br><span class="hljs-comment">-- date_add 指定日期加上一定时间后的日期及时间</span><br><span class="hljs-keyword">select</span> date_add(now(), <span class="hljs-type">interval</span> <span class="hljs-number">66</span> <span class="hljs-keyword">day</span>);    <span class="hljs-comment">-- 从现在往后推66天</span><br><br><span class="hljs-keyword">select</span> date_add(now(), <span class="hljs-type">interval</span> <span class="hljs-number">-10</span> <span class="hljs-keyword">year</span>);  <span class="hljs-comment">-- 从现在往前推10年</span><br><br><span class="hljs-comment">-- datediff 返回两个日期之间相差的天数(前面的日期-后面的日期)</span><br><span class="hljs-keyword">select</span> datediff(now(), <span class="hljs-string">&#x27;2002-10-26&#x27;</span>);   <span class="hljs-comment">-- 从我生日到现在多少天了</span><br><br><br><span class="hljs-comment">-- 案例：查询所有员工入职天数，并按照降序排序</span><br><span class="hljs-keyword">select</span> name,datediff(curdate(),entrydate) <span class="hljs-keyword">as</span> 入职天数 <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 入职天数 <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><h2 id="4、流程控制函数">4、流程控制函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- if(bool,val1,val2) true返回val1 false返回val2</span><br><span class="hljs-keyword">select</span> if(<span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;cxk&#x27;</span>, <span class="hljs-string">&#x27;ikun&#x27;</span>);<br><span class="hljs-comment">-- 类似于三目运算符</span><br><br><span class="hljs-comment">-- ifnull(v1,v2) 如果v1不为null，返回v1,为null返回v2</span><br><span class="hljs-keyword">select</span> ifnull(<span class="hljs-string">&#x27;ok&#x27;</span>, <span class="hljs-string">&#x27;v2&#x27;</span>);<br><br><span class="hljs-keyword">select</span> ifnull(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;v2&#x27;</span>); <span class="hljs-comment">-- 注意空字符串不是null</span><br><br><span class="hljs-keyword">select</span> ifnull(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;v2&#x27;</span>);<br><br><span class="hljs-comment">-- case when then else end</span><br><span class="hljs-comment">-- 查询员工姓名和工作地址，条件 北京/上海 ---&gt; 一线城市 其他 ---&gt; 二线城市</span><br><span class="hljs-keyword">select</span> name,<br> (<span class="hljs-keyword">case</span> workaddress<br>      <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;北京&#x27;</span> <span class="hljs-keyword">then</span> concat(emp.workaddress, <span class="hljs-string">&#x27; 一线城市&#x27;</span>)<br>      <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;上海&#x27;</span> <span class="hljs-keyword">then</span> concat(emp.workaddress, <span class="hljs-string">&#x27; 一线城市&#x27;</span>)<br>      <span class="hljs-keyword">else</span> concat(emp.workaddress, <span class="hljs-string">&#x27; 二线城市&#x27;</span>) <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;工作地址&#x27;</span><br><span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><h3 id="案例">案例</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 案例：统计班级各个学生的成绩，展示规则如下</span><br><span class="hljs-comment">-- &gt;= 85 优秀</span><br><span class="hljs-comment">-- &gt;= 60 及格</span><br><span class="hljs-comment">-- 否则 不及格</span><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> score<br>(<br>    id      <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;编号&#x27;</span>,<br>    name    <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    math    tinyint unsigned comment <span class="hljs-string">&#x27;数学&#x27;</span>,<br>    English tinyint unsigned comment <span class="hljs-string">&#x27;英语&#x27;</span>,<br>    Chinese tinyint unsigned comment <span class="hljs-string">&#x27;语文&#x27;</span><br>) comment <span class="hljs-string">&#x27;成绩表&#x27;</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> score<br><span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">67</span>, <span class="hljs-number">88</span>, <span class="hljs-number">95</span>),<br> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">66</span>, <span class="hljs-number">90</span>),<br> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">98</span>, <span class="hljs-number">76</span>);<br><br><span class="hljs-keyword">select</span> name,<br> (<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> math <span class="hljs-operator">&gt;=</span> <span class="hljs-number">85</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;优秀&#x27;</span> <span class="hljs-keyword">when</span> math <span class="hljs-operator">&gt;=</span> <span class="hljs-number">60</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;及格&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;不及格&#x27;</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;数学&#x27;</span>,<br> (<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> English <span class="hljs-operator">&gt;=</span> <span class="hljs-number">85</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;优秀&#x27;</span> <span class="hljs-keyword">when</span> English <span class="hljs-operator">&gt;=</span> <span class="hljs-number">60</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;及格&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;不及格&#x27;</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;英语&#x27;</span>,<br> (<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> Chinese <span class="hljs-operator">&gt;=</span> <span class="hljs-number">85</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;优秀&#x27;</span> <span class="hljs-keyword">when</span> Chinese <span class="hljs-operator">&gt;=</span> <span class="hljs-number">60</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;及格&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;不及格&#x27;</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;语文&#x27;</span><br><span class="hljs-keyword">from</span> score;<br></code></pre></td></tr></table></figure><h1>六、约束</h1><h2 id="1、基础约束">1、基础约束</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> user2<br>(<br>id     <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment comment <span class="hljs-string">&#x27;主键&#x27;</span>,       <br>    <span class="hljs-comment">-- primary key:主键，auto_increment:id随插入的数据自动增加，无需插入</span><br><br> name   <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">unique</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,          <br>    <span class="hljs-comment">-- not null:不能为空，unique:唯一的，其他行不能出现重复</span><br><br> age    <span class="hljs-type">int</span> <span class="hljs-keyword">check</span> ( age <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">120</span> ) comment <span class="hljs-string">&#x27;年龄&#x27;</span>, <br>    <span class="hljs-comment">-- check(条件):必须满足check中的条件</span><br><br> status <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;1&#x27;</span> comment <span class="hljs-string">&#x27;状态&#x27;</span>,                  <br>    <span class="hljs-comment">-- default:没有指定时的默认值</span><br><br> gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span><br>) comment <span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 插入数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user2(name, age, status, gender) <span class="hljs-comment">-- id为主键，无需插入，插入也没用，会自动更正</span><br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;Tom1&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;男&#x27;</span>),<br>(<span class="hljs-string">&#x27;Tom2&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;男&#x27;</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user2(name, age, status, gender)<br><span class="hljs-keyword">values</span> (<span class="hljs-keyword">null</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;男&#x27;</span>); <span class="hljs-comment">-- 插入的name不能为null，报错</span><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user2 (name, age, status, gender)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;Tom1&#x27;</span>, <span class="hljs-number">11</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;男&#x27;</span>); <span class="hljs-comment">-- 插入的name不能重复，报错,虽然没有成功，但是已经申请到主键，所以会空出一个主键</span><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user2(name, age, status, gender)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;Tom3&#x27;</span>, <span class="hljs-number">80</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;男&#x27;</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user2(name, age, status, gender)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;Tom3&#x27;</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;男&#x27;</span>); <span class="hljs-comment">-- 插入的年龄超出0~120的范围，报错</span><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user2(name, age, gender)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;Tom4&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;男&#x27;</span>); <span class="hljs-comment">-- 不插入status，插入数据后status值默认为1</span><br></code></pre></td></tr></table></figure><h2 id="2、外键约束">2、外键约束</h2><h3 id="1、增、删外键">1、增、删外键</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 外键约束</span><br><br><span class="hljs-comment">-- 准备数据:准备两张表并插入数据</span><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> dept<br>(<br>id   <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span>,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;部门名称&#x27;</span><br>) comment <span class="hljs-string">&#x27;部门表&#x27;</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept(id, name)<br><span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;研发部&#x27;</span>),<br> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;市场部&#x27;</span>),<br> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;财务部&#x27;</span>),<br> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;销售部&#x27;</span>),<br> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;总经办&#x27;</span>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp<br>(<br>id        <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment comment <span class="hljs-string">&#x27;主键&#x27;</span>,<br>name      <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">unique</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>age       <span class="hljs-type">int</span> <span class="hljs-keyword">check</span> ( age <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">120</span> ) comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>job       <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;工作&#x27;</span>,<br>salary    <span class="hljs-type">int</span> <span class="hljs-keyword">check</span> ( salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> ) comment <span class="hljs-string">&#x27;工资&#x27;</span>,<br>entrydate <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span>,<br>managerid <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;直属领导ID&#x27;</span>,<br>dept_id   <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;部门ID&#x27;</span><br>) comment <span class="hljs-string">&#x27;员工表&#x27;</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp(id, name, age, job, salary, entrydate, managerid, dept_id)<br><span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;金庸&#x27;</span>, <span class="hljs-number">66</span>, <span class="hljs-string">&#x27;总裁&#x27;</span>, <span class="hljs-number">20000</span>, <span class="hljs-string">&#x27;2000-01-01&#x27;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>),<br> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;张无忌&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;项目经理&#x27;</span>, <span class="hljs-number">12500</span>, <span class="hljs-string">&#x27;2005-12-05&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;杨逍 &#x27;</span>, <span class="hljs-number">33</span>, <span class="hljs-string">&#x27;开发&#x27;</span>, <span class="hljs-number">8400</span>, <span class="hljs-string">&#x27;2000-11-03&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>),<br> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;韦一笑&#x27;</span>, <span class="hljs-number">48</span>, <span class="hljs-string">&#x27;开发 &#x27;</span>, <span class="hljs-number">11000</span>, <span class="hljs-string">&#x27;2002-02-05&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>),<br> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;常遇春&#x27;</span>, <span class="hljs-number">43</span>, <span class="hljs-string">&#x27;开发&#x27;</span>, <span class="hljs-number">10500</span>, <span class="hljs-string">&#x27;2004-09-07&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>),<br> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;小昭&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;程序员鼓励师&#x27;</span>, <span class="hljs-number">6600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">-- 添加外键</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> fk_emp_dept_id <span class="hljs-keyword">foreign</span> key (dept_id) <span class="hljs-keyword">references</span><br>dept(id);<br><br><span class="hljs-comment">-- 给emp表的dept_id添加外键约束，关联dept表的主键id，dept变为emp的主表</span><br><span class="hljs-comment">-- fk_emp_dept_id:外键名</span><br><br><span class="hljs-comment">-- 删除外键</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">drop</span> <span class="hljs-keyword">foreign</span> key fk_emp_dept_id;<br></code></pre></td></tr></table></figure><h3 id="2、删除、更新行为">2、删除、更新行为</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除、更新行为</span><br><span class="hljs-comment">-- 添加外键 + on cascade</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp<br><span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> fk_emp_dept_id <span class="hljs-keyword">foreign</span> key (dept_id) <span class="hljs-keyword">references</span> dept (id) <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> cascade <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> cascade;<br><br><span class="hljs-comment">-- cascade 在父表中删除/更新外键记录（外键数据）时，检查是否有外键，若有，则子表中的数据也相应的删除/更新</span><br><span class="hljs-comment">-- 通俗：父表删除或更新外键，子表只要有与父表相关的外键，那么子表也跟着更新或删除</span><br><span class="hljs-comment">-- 删除研发部的外键id后，emp表中所有dept_id对应研发部的员工都会被删除</span><br><br><span class="hljs-comment">-- 添加外键 + on set null</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp<br><span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> fk_emp_dept_id <span class="hljs-keyword">foreign</span> key (dept_id) <span class="hljs-keyword">references</span> dept (id) <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">null</span>;<br><br><span class="hljs-comment">-- 通俗：父表删除或更新外键，子表只要有与父表相关的外键，那么子表直接设置为null</span><br></code></pre></td></tr></table></figure><h1>七、多表查询</h1><h2 id="1、概述">1、概述</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建dept表，并插入数据</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> dept<br>(<br>id   <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span> <span class="hljs-keyword">primary</span> key,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;部门名称&#x27;</span><br>) comment <span class="hljs-string">&#x27;部门表&#x27;</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept (id, name)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;研发部&#x27;</span>),<br> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;市场部&#x27;</span>),<br> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;财务部&#x27;</span>),<br> (<span class="hljs-number">4</span>,<br>  <span class="hljs-string">&#x27;销售部&#x27;</span>),<br> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;总经办&#x27;</span>),<br> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;人事部&#x27;</span>);<br><span class="hljs-comment">-- 创建emp表，并插入数据</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp<br>(<br>    id        <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span> <span class="hljs-keyword">primary</span> key,<br>    name      <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    age       <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    job       <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) comment <span class="hljs-string">&#x27;职位&#x27;</span>,<br>    salary    <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;薪资&#x27;</span>,<br>    entrydate <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span>,<br>    managerid <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;直属领导ID&#x27;</span>,<br>    dept_id   <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;部门ID&#x27;</span><br>) comment <span class="hljs-string">&#x27;员工表&#x27;</span>;<br><span class="hljs-comment">-- 添加外键</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp<br><span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> fk_emp_dept_id <span class="hljs-keyword">foreign</span> key (dept_id) <span class="hljs-keyword">references</span><br>  dept (id);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, name, age, job, salary, entrydate, managerid, dept_id)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;金庸&#x27;</span>, <span class="hljs-number">66</span>, <span class="hljs-string">&#x27;总裁&#x27;</span>, <span class="hljs-number">20000</span>, <span class="hljs-string">&#x27;2000-01-01&#x27;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>),<br> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;张无忌&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;项目经理&#x27;</span>, <span class="hljs-number">12500</span>, <span class="hljs-string">&#x27;2005-12-05&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;杨逍&#x27;</span>, <span class="hljs-number">33</span>, <span class="hljs-string">&#x27;开发&#x27;</span>, <span class="hljs-number">8400</span>, <span class="hljs-string">&#x27;2000-11-03&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>),<br> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;韦一笑&#x27;</span>, <span class="hljs-number">48</span>, <span class="hljs-string">&#x27;开发&#x27;</span>, <span class="hljs-number">11000</span>, <span class="hljs-string">&#x27;2002-02-05&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>),<br> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;常遇春&#x27;</span>, <span class="hljs-number">43</span>, <span class="hljs-string">&#x27;开发&#x27;</span>, <span class="hljs-number">10500</span>, <span class="hljs-string">&#x27;2004-09-07&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>),<br> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;小昭&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;程序员鼓励师&#x27;</span>, <span class="hljs-number">6600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>),<br> (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;灭绝&#x27;</span>, <span class="hljs-number">60</span>, <span class="hljs-string">&#x27;财务总监&#x27;</span>, <span class="hljs-number">8500</span>, <span class="hljs-string">&#x27;2002-09-12&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>),<br> (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;周芷若&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;会计&#x27;</span>, <span class="hljs-number">48000</span>, <span class="hljs-string">&#x27;2006-06-02&#x27;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>),<br> (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;丁敏君&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;出纳&#x27;</span>, <span class="hljs-number">5250</span>, <span class="hljs-string">&#x27;2009-05-13&#x27;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>),<br> (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;赵敏&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;市场部总监&#x27;</span>, <span class="hljs-number">12500</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),<br> (<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;鹿杖客&#x27;</span>, <span class="hljs-number">56</span>, <span class="hljs-string">&#x27;职员&#x27;</span>, <span class="hljs-number">3750</span>, <span class="hljs-string">&#x27;2006-10-03&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>),<br> (<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;鹤笔翁&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;职员&#x27;</span>, <span class="hljs-number">3750</span>, <span class="hljs-string">&#x27;2007-05-09&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>),<br> (<span class="hljs-number">13</span>, <span class="hljs-string">&#x27;方东白&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;职员&#x27;</span>, <span class="hljs-number">5500</span>, <span class="hljs-string">&#x27;2009-02-12&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>),<br> (<span class="hljs-number">14</span>, <span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">88</span>, <span class="hljs-string">&#x27;销售总监&#x27;</span>, <span class="hljs-number">14000</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>),<br> (<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;俞莲舟&#x27;</span>, <span class="hljs-number">38</span>, <span class="hljs-string">&#x27;销售&#x27;</span>, <span class="hljs-number">4600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">14</span>, <span class="hljs-number">4</span>),<br> (<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;宋远桥&#x27;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&#x27;销售&#x27;</span>, <span class="hljs-number">4600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">14</span>, <span class="hljs-number">4</span>),<br> (<span class="hljs-number">17</span>, <span class="hljs-string">&#x27;陈友谅&#x27;</span>, <span class="hljs-number">42</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;2011-10-12&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>);<br><br><span class="hljs-comment">-- 多表查询 -- 笛卡尔积（A集合与B集合所有的组合的情况）</span><br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp,<br>dept<br><span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> dept.id;    <span class="hljs-comment">-- 通过条件消除多余的笛卡尔积</span><br></code></pre></td></tr></table></figure><h2 id="2、连接查询">2、连接查询</h2><h3 id="内连接">内连接</h3><blockquote><p>查询两张表中符合条件的数据，不符合条件的不会返回结果</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 内连接演示</span><br><span class="hljs-comment">-- 查询员工姓名，并查询关联部门的名称（隐式内连接实现）</span><br><span class="hljs-comment">-- 表结构：emp，dept</span><br><span class="hljs-comment">-- 条件：emp.dept_id = dept.id</span><br><br># <span class="hljs-keyword">select</span> emp.name, dept.name<br># <span class="hljs-keyword">from</span> emp,<br>#      dept<br># <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> dept.id;<br><span class="hljs-comment">-- 给表起别名，起了别名后不能用原名</span><br><span class="hljs-keyword">select</span> e.name, d.name<br><span class="hljs-keyword">from</span> emp e,<br>dept d<br><span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br><br><br><span class="hljs-comment">-- 查询员工姓名，并查询关联部门的名称（显式内连接实现） -- inner join...on... inner可以省略，on后面接条件</span><br><span class="hljs-comment">-- 表结构：emp，dept</span><br><span class="hljs-comment">-- 条件：emp.dept_id = dept.id</span><br><br><span class="hljs-keyword">select</span> e.name, d.name<br><span class="hljs-keyword">from</span> emp e<br>   <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure><h3 id="外连接">外连接</h3><blockquote><p>左外连接：查询==左表所有数据==和==右表中符合条件的数据==</p><p>右外连接：查询左表所有数据和右表中符合条件的数据</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 外连接演示</span><br><span class="hljs-comment">-- 表结构：emp,dept</span><br><span class="hljs-comment">-- 条件：emp.dept_id = dept.id</span><br><br><span class="hljs-comment">-- 左外连接：查询左表所有数据和右、左表相交的数据 left [outer] join...on... outer可以省略，on后面接条件</span><br><span class="hljs-comment">-- 查询所有员工信息和对应部门信息</span><br><span class="hljs-keyword">select</span> e.name, d.name<br><span class="hljs-keyword">from</span> emp e<br>   <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> d.id <span class="hljs-operator">=</span> e.dept_id;<br><br><span class="hljs-comment">-- 查询右表所有数据和左、右表相交的数据</span><br><span class="hljs-keyword">select</span> d.<span class="hljs-operator">*</span>, e.<span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp e<br>   <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> d.id <span class="hljs-operator">=</span> e.dept_id;<br><span class="hljs-comment">-- 左外连接和右外连接可以互相转化，表的顺序换一下就行了（习惯上左外连接）</span><br></code></pre></td></tr></table></figure><h3 id="自连接">自连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 自连接（自连接时要给表起别名用于区分哪张表）</span><br><br><span class="hljs-comment">-- 表结构：emp</span><br><span class="hljs-comment">-- 内自连接</span><br><span class="hljs-comment">-- 查询员工及其所属领导的名字</span><br><span class="hljs-keyword">select</span> e1.name, e2.name<br><span class="hljs-keyword">from</span> emp e1,<br>emp e2<br><span class="hljs-keyword">where</span> e1.managerid <span class="hljs-operator">=</span> e2.id;<br><br><span class="hljs-comment">-- 外自连接</span><br><span class="hljs-comment">-- 查询员工及其所属领导的名字，没有领导也要查询出来</span><br><span class="hljs-keyword">select</span> a.name <span class="hljs-string">&#x27;员工&#x27;</span>, b.name <span class="hljs-string">&#x27;领导&#x27;</span><br><span class="hljs-keyword">from</span> emp a<br>   <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> emp b <span class="hljs-keyword">on</span> a.managerid <span class="hljs-operator">=</span> b.id;<br></code></pre></td></tr></table></figure><h2 id="union查询">union查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 联合查询 union ，union all</span><br><span class="hljs-comment">-- 将薪资低于5000和年龄大于50的员工全部查询出来</span><br><br><span class="hljs-comment">-- union all 相当于把两张表直接加起来，所以有可能有重复的员工</span><br><span class="hljs-keyword">select</span> name<br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&lt;</span> <span class="hljs-number">5000</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> name<br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span>;<br><br><span class="hljs-comment">-- union 对union all结果去重</span><br><span class="hljs-keyword">select</span> name<br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&lt;</span> <span class="hljs-number">5000</span><br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> name<br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span>;<br><br><span class="hljs-comment">-- 查询的列数必须相同，字段类型也必须相同</span><br></code></pre></td></tr></table></figure><h2 id="3、子查询">3、子查询</h2><h3 id="标量子查询">标量子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 标量子查询:后一个select查询的结果为单个值</span><br><span class="hljs-comment">-- 常用操作符:&gt; &lt; &lt;&gt; &gt;= = &lt;=</span><br><span class="hljs-comment">-- 查询 销售部 所有员工信息</span><br><span class="hljs-comment">-- a.先查询销售部门id</span><br><span class="hljs-keyword">select</span> id<br><span class="hljs-keyword">from</span> dept<br><span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span>;<br><span class="hljs-comment">-- b.根据销售部门id查出员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span>);<br><br><br><span class="hljs-comment">-- 查询在 方东白 入职之后的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> entrydate <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> entrydate <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;方东白&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="列子查询">列子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 列子查询</span><br><span class="hljs-comment">-- 1、查询 销售部 和 市场部 的所有员工信息</span><br><br><span class="hljs-comment">-- a.先查询 销售部 和 市场部 的id</span><br><span class="hljs-keyword">select</span> id<br><span class="hljs-keyword">from</span> dept<br><span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span><br><span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;市场部&#x27;</span>;<br><br><span class="hljs-comment">-- b.根据id查询员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> dept_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;市场部&#x27;</span>);<br><br><span class="hljs-comment">-- 2、查询工资比财务部所有员工工资都高的员工</span><br><br><span class="hljs-comment">-- a.查询财务部所有人的工资</span><br><span class="hljs-keyword">select</span> salary<br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;财务部&#x27;</span>);<br><span class="hljs-comment">-- b.根据上述信息查询比财务部所有人工资都高的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">all</span> (<span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;财务部&#x27;</span>));<br><span class="hljs-comment">--  &gt; all :大于后面查询到的所有数据</span><br><br><span class="hljs-comment">-- 3、查询比研发部至少一人工资高的员工 任意一人：研发部至少存在一个人的工资比我低</span><br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">any</span><br>(<span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>));<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">some</span><br>(<span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>));<br><br><span class="hljs-comment">-- any和some等同</span><br></code></pre></td></tr></table></figure><h3 id="行子查询">行子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 行子查询</span><br><span class="hljs-comment">-- 查询与 张无忌 薪资和直属领导相同的员工信息</span><br><br><span class="hljs-comment">-- a.查询张无忌的薪资和直属领导</span><br><span class="hljs-keyword">select</span> salary, managerid<br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张无忌&#x27;</span><br><br><br><span class="hljs-comment">-- b.查询与 张无忌 薪资和直属领导相同的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> (salary, managerid) <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> salary, managerid <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张无忌&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="表子查询">表子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 表子查询</span><br><span class="hljs-comment">-- 查询和 鹿杖客 宋远桥 职位和薪资相同的员工信息</span><br><br><span class="hljs-comment">-- a.查询鹿杖客 宋远桥 的职位和薪资</span><br><span class="hljs-keyword">select</span> job, salary<br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> name <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;鹿杖客&#x27;</span>, <span class="hljs-string">&#x27;宋远桥&#x27;</span>);<br><br><span class="hljs-comment">-- b.查询和 鹿杖客 宋远桥 职位和薪资相同的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> (job, salary) <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> job, salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;鹿杖客&#x27;</span>, <span class="hljs-string">&#x27;宋远桥&#x27;</span>));<br><br><span class="hljs-comment">-- 查询入职时间是‘2006-01-01’之后的员工及其部门信息</span><br><span class="hljs-comment">-- a.查询入职时间是‘2006-01-01’之后的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> entrydate <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2006-01-01&#x27;</span>;<br><span class="hljs-comment">-- b.查询这些员工的部门信息</span><br><span class="hljs-comment">-- 把上述查询的结果当做需要查询的一张表</span><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, d.<span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> entrydate <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2006-01-01&#x27;</span>) e<br>   <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure><h2 id="4、多表查询案例">4、多表查询案例</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- ---------------&gt;多表查询案例 &lt;--------------</span><br><span class="hljs-comment">-- 准备数据</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> salgrade<br>(<br>grade <span class="hljs-type">int</span>,<br>losal <span class="hljs-type">int</span>,<br>hisal <span class="hljs-type">int</span><br>) comment <span class="hljs-string">&#x27;薪资等级表&#x27;</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade<br><span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade<br><span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-number">3001</span>, <span class="hljs-number">5000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade<br><span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>, <span class="hljs-number">5001</span>, <span class="hljs-number">8000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade<br><span class="hljs-keyword">values</span> (<span class="hljs-number">4</span>, <span class="hljs-number">8001</span>, <span class="hljs-number">10000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade<br><span class="hljs-keyword">values</span> (<span class="hljs-number">5</span>, <span class="hljs-number">10001</span>, <span class="hljs-number">15000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade<br><span class="hljs-keyword">values</span> (<span class="hljs-number">6</span>, <span class="hljs-number">15001</span>, <span class="hljs-number">20000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade<br><span class="hljs-keyword">values</span> (<span class="hljs-number">7</span>, <span class="hljs-number">20001</span>, <span class="hljs-number">25000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade<br><span class="hljs-keyword">values</span> (<span class="hljs-number">8</span>, <span class="hljs-number">25001</span>, <span class="hljs-number">30000</span>);<br><br><br><span class="hljs-comment">-- 1.查询员工的姓名、年龄、职位、部门信息。</span><br><span class="hljs-keyword">select</span> e.name, e.age, e.job, d.<span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp e<br>   <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br><br><span class="hljs-comment">-- 2.查询年龄小于30岁的员工姓名、年龄、职位、部门信息。</span><br><span class="hljs-keyword">select</span> e.name, e.age, e.job, d.<span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp e<br>   <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id<br><span class="hljs-keyword">where</span> e.age <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">-- 3.查询拥有员工的部门ID、部门名称。</span><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> d.id, d.name<br><span class="hljs-keyword">from</span> dept d,<br>emp e<br><span class="hljs-keyword">where</span> d.id <span class="hljs-operator">=</span> e.dept_id;<br><br><span class="hljs-comment">-- 4.查询所有年龄大于40岁的员工，及其归属的部门名称：如果员工没有分配部门，也需要展示出来。</span><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, d.name<br><span class="hljs-keyword">from</span> emp e<br>   <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id<br><span class="hljs-keyword">where</span> e.age <span class="hljs-operator">&gt;</span> <span class="hljs-number">40</span>;<br><br><span class="hljs-comment">-- 5.查询所有员工的工资等级。</span><br><span class="hljs-keyword">select</span> e.name, e.salary, s.losal, s.hisal, s.grade<br><span class="hljs-keyword">from</span> emp e<br>   <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> salgrade s <span class="hljs-keyword">on</span> e.salary <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal;<br><br><span class="hljs-comment">-- 6.查询&quot;研发部”所有员工的信息及工资等级。</span><br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp e,<br>salgrade s,<br>dept d<br><span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id<br><span class="hljs-keyword">and</span> e.salary <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal<br><span class="hljs-keyword">and</span> d.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>;<br><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, grade<br><span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept d <span class="hljs-keyword">where</span> d.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>)) e<br>   <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> salgrade s <span class="hljs-keyword">on</span> e.salary <span class="hljs-operator">&lt;=</span> s.hisal <span class="hljs-keyword">and</span> e.salary <span class="hljs-operator">&gt;=</span> s.losal;<br><br><span class="hljs-comment">-- 7.查询&quot;研发部”员工的平均工资。</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(e.salary)<br><span class="hljs-keyword">from</span> emp e,<br>dept d<br><span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id<br><span class="hljs-keyword">and</span> d.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>;<br><br><span class="hljs-comment">-- 8.查询工资比&quot;灭绝&quot;高的员工信息。</span><br><span class="hljs-comment">-- 子查询</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;灭绝&#x27;</span>);<br><br><span class="hljs-comment">-- 自查询</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp a,<br>emp b<br><span class="hljs-keyword">where</span> a.salary <span class="hljs-operator">&gt;</span> b.salary<br><span class="hljs-keyword">and</span> b.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;灭绝&#x27;</span>;<br><br><span class="hljs-comment">-- 9.查询比平均薪资高的员工信息。</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary)<br><span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary) <span class="hljs-keyword">from</span> emp);<br><br><span class="hljs-comment">-- 10.查询低于本部门平均工资的员工信息。</span><br><span class="hljs-comment">-- 查询某部门平均薪资</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(e.salary)<br><span class="hljs-keyword">from</span> emp e,<br>dept d<br><span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id<br><span class="hljs-keyword">and</span> d.id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 查询低于本部门平均工资的员工信息。</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp e1<br><span class="hljs-keyword">where</span> e1.salary <span class="hljs-operator">&lt;</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(e2.salary)<br>             <span class="hljs-keyword">from</span> emp e2,<br>                  dept d<br>             <span class="hljs-keyword">where</span> e2.dept_id <span class="hljs-operator">=</span> d.id<br>               <span class="hljs-keyword">and</span> d.id <span class="hljs-operator">=</span> e1.dept_id);<br><br><span class="hljs-comment">-- 11.查询所有的部门信息，并统计部门的员工人数。</span><br><span class="hljs-comment">-- 查询所有部门信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> dept;<br><span class="hljs-comment">-- 统计1号部门员工数量</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 查询所有的部门信息，并统计部门的员工人数</span><br><span class="hljs-keyword">select</span> d.id, d.name, (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id) <span class="hljs-string">&#x27;人数&#x27;</span><br><span class="hljs-keyword">from</span> dept d;<br></code></pre></td></tr></table></figure><h1>八、事务</h1><h2 id="1、事务简介">1、事务简介</h2><blockquote><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p></blockquote><h2 id="2、事务操作">2、事务操作</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务</span><br><br><span class="hljs-comment">-- ---&gt; 准备数据 &lt;---------------------</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> account<br>(<br>id    <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key AUTO_INCREMENT comment <span class="hljs-string">&#x27;ID&#x27;</span>,<br>name  <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>money <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>) comment <span class="hljs-string">&#x27;余额&#x27;</span><br>) comment <span class="hljs-string">&#x27;账户表&#x27;</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account(name, money)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">2000</span>),<br> (<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">2000</span>);<br><br><span class="hljs-comment">-- -----------------------------------</span><br><br><span class="hljs-comment">-- 恢复数据操作</span><br><span class="hljs-keyword">update</span> account<br><span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> <span class="hljs-number">2000</span><br><span class="hljs-keyword">where</span> name <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;李四&#x27;</span>);<br><br><br><span class="hljs-keyword">select</span> @<span class="hljs-variable">@autocommit</span>; <span class="hljs-comment">-- 查询事务提交方式 0-手动 1-自动</span><br><br><span class="hljs-comment">-- 方式一</span><br><span class="hljs-keyword">set</span> @<span class="hljs-variable">@autocommit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">-- 设置为手动提交</span><br><br><br><span class="hljs-comment">-- 转账操作（张三转给李四1000元）</span><br><span class="hljs-comment">-- 查询张三余额</span><br><span class="hljs-keyword">select</span> money<br><span class="hljs-keyword">from</span> account<br><span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><br><span class="hljs-comment">-- 张三余额-1000</span><br><span class="hljs-keyword">update</span> account<br><span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">1000</span><br><span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><br><span class="hljs-comment">-- 若此处出现异常，则张三-1000元，但李四并没有+1000元</span><br>异常... <span class="hljs-comment">-- 模拟出错场景</span><br><br><span class="hljs-comment">-- 李四余额+1000</span><br><span class="hljs-keyword">update</span> account<br><span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">1000</span><br><span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李四&#x27;</span>;<br><br><span class="hljs-comment">-- 提交事务</span><br><span class="hljs-keyword">commit</span>;<br><span class="hljs-comment">-- 回滚事务</span><br><span class="hljs-keyword">rollback</span>;<br><br><span class="hljs-comment">-- 方式二</span><br><br><span class="hljs-keyword">set</span> @<span class="hljs-variable">@autocommit</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">-- 设置为自动提交</span><br><br><span class="hljs-keyword">start</span> transaction;<br><br><span class="hljs-comment">-- 转账操作（张三转给李四1000元）</span><br><span class="hljs-comment">-- 查询张三余额</span><br><span class="hljs-keyword">select</span> money<br><span class="hljs-keyword">from</span> account<br><span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><br><span class="hljs-comment">-- 张三余额-1000</span><br><span class="hljs-keyword">update</span> account<br><span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">1000</span><br><span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><br><span class="hljs-comment">-- 若此处出现异常，则张三-1000元，但李四并没有+1000元</span><br>异常...   <span class="hljs-comment">-- 模拟出错场景</span><br><br><span class="hljs-comment">-- 李四余额+1000</span><br><span class="hljs-keyword">update</span> account<br><span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">1000</span><br><span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李四&#x27;</span>;<br><br><span class="hljs-comment">-- 提交事务</span><br><span class="hljs-keyword">commit</span>;<br><span class="hljs-comment">-- 回滚事务</span><br><span class="hljs-keyword">rollback</span>;<br></code></pre></td></tr></table></figure><h2 id="3、事务的四大特性（ACID）">3、事务的四大特性（ACID）</h2><blockquote><ol><li><strong>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</strong></li></ol></blockquote><blockquote><ol start="2"><li><p><strong>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</strong></p></li><li><p><strong>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</strong></p></li></ol></blockquote><blockquote><ol start="3"><li><p><strong>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。</strong></p></li><li><p><strong>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</strong></p></li></ol></blockquote><h2 id="4、并发事务问题">4、并发事务问题</h2><blockquote><p><strong>脏读：一个事务读取到另外一个事务未提交的数据。</strong></p><p><strong>不可重复读：一个事务先后读取同一条数据，但两次读取到的数据不同。</strong></p><p><strong>幻读：一个事务查询数据时没有对应数据，插入该数据时又发现该数据已经存在，好像出现“幻影”。</strong></p></blockquote><h2 id="5、隔离级别">5、隔离级别</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 并发事务与隔离级别</span><br><br><span class="hljs-comment">-- 查询事务隔离级别</span><br><span class="hljs-keyword">select</span> @<span class="hljs-variable">@transaction_isolation</span>;<br><br><span class="hljs-comment">-- 设置事务隔离级别 session-仅当前页面起作用    transaction isolation level-事务隔离级别</span><br><span class="hljs-keyword">set</span> session transaction isolation level read uncommitted;<br><br><span class="hljs-comment">-- repeatable read是默认级别</span><br><span class="hljs-keyword">set</span> session transaction isolation level repeatable read ;<br><br><span class="hljs-comment">-- 隔离级别越高，数据越安全，但是性能越低</span><br></code></pre></td></tr></table></figure><h1>九、JDBC</h1><h2 id="1、jdbc7步编程">1、jdbc7步编程</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JDBC快速入门</span><br><span class="hljs-comment">//1、注册驱动</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><br><span class="hljs-comment">//2、获取连接</span><br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/clb&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>conn = DriverManager.getConnection(url, username, password);<br><br><br><span class="hljs-comment">//3、定义sql</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = 666 where id = 1&quot;</span>;<br><br><span class="hljs-comment">//4、获取执行sql的对象 Statement</span><br><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>stmt = conn.createStatement();<br><br><br><span class="hljs-comment">//5、执行sql</span><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//受影响的行数</span><br>count = stmt.executeUpdate(sql);<br><br><br><span class="hljs-comment">//6、处理结果</span><br>System.out.println(<span class="hljs-string">&quot;受影响的行数有&quot;</span> + count + <span class="hljs-string">&quot;行&quot;</span>);<br><br><span class="hljs-comment">//7、释放资源</span><br>stmt.close();<br>conn.close();<br></code></pre></td></tr></table></figure><h2 id="2、DriverManager">2、DriverManager</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">//1、注册驱动 --&gt;可以省略</span><br>  <span class="hljs-comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><br>  <span class="hljs-comment">//2、获取连接 --&gt;如果连接的是本机的数据库且端口是默认的 3306 则可以简写</span><br>  <span class="hljs-comment">// String url = &quot;jdbc:mysql://localhost:3306/clb&quot;;</span><br>  <span class="hljs-comment">//简写：</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:/clb&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>  <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><br><br>  <span class="hljs-comment">//3、定义sql</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = 1000 where id = 1&quot;</span>;<br><br>  <span class="hljs-comment">//4、获取执行sql的对象 Statement</span><br>  <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  stmt = conn.createStatement();<br><br><br>  <span class="hljs-comment">//5、执行sql</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//受影响的行数</span><br>  count = stmt.executeUpdate(sql);<br><br><br>  <span class="hljs-comment">//6、处理结果</span><br>  System.out.println(<span class="hljs-string">&quot;受影响的行数有&quot;</span> + count + <span class="hljs-string">&quot;行&quot;</span>);<br><br>  <span class="hljs-comment">//7、释放资源</span><br><br>  stmt.close();<br>  conn.close();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    DriverManager有两个作用:</span><br><span class="hljs-comment">    1、注册驱动</span><br><span class="hljs-comment">    2、获取数据库连接</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="3、Connection">3、Connection</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、管理事务       </span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//开启事务</span><br>    conn.setAutoCommit(<span class="hljs-literal">false</span>);<span class="hljs-comment">//将自动提交改为手动</span><br><br>    <span class="hljs-comment">//5、执行sql</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql);<br>    <span class="hljs-comment">//6、处理结果</span><br>    System.out.println(<span class="hljs-string">&quot;受影响的行数有&quot;</span> + count + <span class="hljs-string">&quot;行&quot;</span>);<br><br>    <span class="hljs-comment">//制造异常</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span> / <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//5、执行sql</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count2</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql2);<br>    <span class="hljs-comment">//6、处理结果</span><br>    System.out.println(<span class="hljs-string">&quot;受影响的行数有&quot;</span> + count2 + <span class="hljs-string">&quot;行&quot;</span>);<br><br>    <span class="hljs-comment">//提交事务</span><br>    conn.commit();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">//回滚事务</span><br>    conn.rollback();<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、Statement">4、Statement</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> JDBC;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3Statement</span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  Statement:</span><br><span class="hljs-comment">  1、执行SQL语句</span><br><span class="hljs-comment">  int executeUpdate(sql) -&gt; 执行DML、DDL语句</span><br><span class="hljs-comment">  执行DML语句</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDML</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">//1、注册驱动</span><br>  <span class="hljs-comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><br>  <span class="hljs-comment">//2、获取连接</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/clb&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>  <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  conn = DriverManager.getConnection(url, username, password);<br><br><br>  <span class="hljs-comment">//3、定义sql</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = 666 where id = 1&quot;</span>;<br><br>  <span class="hljs-comment">//4、获取执行sql的对象 Statement</span><br>  <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br><br>  <span class="hljs-comment">//5、执行sql</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql);<br><br>  <span class="hljs-comment">//6、处理结果</span><br>  System.out.println(count &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;修改成功&quot;</span> : <span class="hljs-string">&quot;修改失败&quot;</span>);<br><br>  <span class="hljs-comment">//7、释放资源</span><br>  stmt.close();<br>  conn.close();<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  执行DDL语句</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDDL</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">//1、注册驱动</span><br>  <span class="hljs-comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><br>  <span class="hljs-comment">//2、获取连接</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/clb&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>  <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  conn = DriverManager.getConnection(url, username, password);<br><br>  <span class="hljs-comment">//3、定义sql</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;drop database cxk&quot;</span>;<br><br>  <span class="hljs-comment">//4、获取执行sql的对象 Statement</span><br>  <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br><br>  <span class="hljs-comment">//5、执行sql</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql);<br><br>  <span class="hljs-comment">//6、处理结果</span><br><span class="hljs-comment">//        System.out.println(count &gt; 0 ? &quot;修改成功&quot; : &quot;修改失败&quot;);</span><br>  System.out.println(count);<br><br>  <span class="hljs-comment">//7、释放资源</span><br><br>  stmt.close();<br>  conn.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、ResultSet">5、ResultSet</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> JDBC;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> pojo.Account;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo4ResultSet</span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  ResultSet:</span><br><span class="hljs-comment">  执行DQL查询语句</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ResultSetDemo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">//1、注册驱动</span><br>  <span class="hljs-comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><br>  <span class="hljs-comment">//2、获取连接</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/clb&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>  <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  conn = DriverManager.getConnection(url, username, password);<br>  <span class="hljs-comment">//3、定义sql语句</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from account&quot;</span>;<br>  <span class="hljs-comment">//4、获取statement对象</span><br>  <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br>  <span class="hljs-comment">//5、执行sql</span><br>  <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(sql);<br><br>  <span class="hljs-comment">//6、处理数据，遍历rs中的所有数据</span><br>  <span class="hljs-comment">//6.1光标向下移动一行，判断当前行是否有数据</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  while (rs.next()) &#123;</span><br><span class="hljs-comment">      //6.2 获取数据getXxx()</span><br><span class="hljs-comment">      int id = rs.getInt(1);</span><br><span class="hljs-comment">      String name = rs.getString(2);</span><br><span class="hljs-comment">      double money = rs.getDouble(3);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      System.out.println(id);</span><br><span class="hljs-comment">      System.out.println(name);</span><br><span class="hljs-comment">      System.out.println(money);</span><br><span class="hljs-comment">      System.out.println(&quot;-------------------&quot;);</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">while</span> (rs.next()) &#123;<br>      <span class="hljs-comment">//6.2 获取数据getXxx()</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>      <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>      <span class="hljs-type">double</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> rs.getDouble(<span class="hljs-string">&quot;money&quot;</span>);<br><br>      System.out.println(id);<br>      System.out.println(name);<br>      System.out.println(money);<br>      System.out.println(<span class="hljs-string">&quot;-------------------&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//7、释放资源</span><br>  rs.close();<br>  stmt.close();<br>  conn.close();<br>&#125;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  查询数据库中account表的数据，封装成Account对象，并存储到ArrayList表中</span><br><span class="hljs-comment">  1、定义实体类Account</span><br><span class="hljs-comment">  2、查询数据</span><br><span class="hljs-comment">  3、封装数据到ArrayList表中</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ResultSetDemo2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">//1、注册驱动</span><br>  <span class="hljs-comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><br>  <span class="hljs-comment">//2、获取连接</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/clb&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>  <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  conn = DriverManager.getConnection(url, username, password);<br>  <span class="hljs-comment">//3、定义sql语句</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from account&quot;</span>;<br>  <span class="hljs-comment">//4、获取statement对象</span><br>  <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br>  <span class="hljs-comment">//5、执行sql</span><br>  <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(sql);<br><br>  ArrayList&lt;Account&gt; lst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">while</span> (rs.next()) &#123;<br>      <span class="hljs-comment">//6.2 获取数据getXxx()</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>      <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>      <span class="hljs-type">double</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> rs.getDouble(<span class="hljs-string">&quot;money&quot;</span>);<br>      lst.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(id, name, money));<br>  &#125;<br><br>  System.out.println(lst);<br><br>  <span class="hljs-comment">//7、释放资源</span><br>  rs.close();<br>  stmt.close();<br>  conn.close();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6、用户登陆">6、用户登陆</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> JDBC;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">用户登陆</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserLoginDemo5</span> &#123;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">UserLogin</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">//1、注册驱动</span><br>  Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><br>  <span class="hljs-comment">//2、获取连接</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/clb&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>  <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  conn = DriverManager.getConnection(url, username, password);<br><br>  <span class="hljs-comment">//接收用户名和密码</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cxk&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jntm&quot;</span>;<br><br>  <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from tb_user where name = &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27; and password = &#x27;&quot;</span> + pwd + <span class="hljs-string">&quot;&#x27;&quot;</span>;<br><br>  <span class="hljs-comment">//获取Statement对象</span><br>  <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br><br>  <span class="hljs-comment">//执行sql语句</span><br>  <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(sql);<br><br>  <span class="hljs-comment">//判断是否登陆成功</span><br>  System.out.println(rs.next() ? <span class="hljs-string">&quot;登陆成功&quot;</span> : <span class="hljs-string">&quot;登陆失败&quot;</span>);<br><br>  <span class="hljs-comment">//7、释放资源</span><br>  rs.close();<br>  stmt.close();<br>  conn.close();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  sql注入问题</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">UserLogin_Inject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">//1、注册驱动</span><br>  Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><br>  <span class="hljs-comment">//2、获取连接</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/clb&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>  <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  conn = DriverManager.getConnection(url, username, password);<br><br>  <span class="hljs-comment">//接收用户名和密码 sql注入-&gt;此处密码错误却还能成功登陆</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ikunngmngmngm&quot;</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#x27;or &#x27;1&#x27; = &#x27;1&quot;</span>;<br><br>  <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from tb_user where name = &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27; and password = &#x27;&quot;</span> + pwd + <span class="hljs-string">&quot;&#x27;&quot;</span>;<br><br>  <span class="hljs-comment">//获取Statement对象</span><br>  <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br><br>  <span class="hljs-comment">//执行sql语句</span><br>  <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(sql);<br>  System.out.println(<span class="hljs-string">&quot;sql = &quot;</span> + sql);<br><br>  <span class="hljs-comment">//判断是否登陆成功</span><br>  System.out.println(rs.next() ? <span class="hljs-string">&quot;登陆成功&quot;</span> : <span class="hljs-string">&quot;登陆失败&quot;</span>);<br><br>  <span class="hljs-comment">//7、释放资源</span><br>  rs.close();<br>  stmt.close();<br>  conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7、PrepareStatement">7、PrepareStatement</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> JDBC;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    PrepareStatement解决sql注入问题</span><br><span class="hljs-comment">    将sql语句中的敏感符号加\ 进行转义</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrepareStatementDemo6</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">PrepareStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1、注册驱动</span><br>        Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><br>        <span class="hljs-comment">//2、获取连接</span><br>        <span class="hljs-comment">//useSeverPrepStmts=true 开启预编译功能 ：性能更高</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:/clb?useSSL=false&amp;useSeverPrepStmts=true&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        conn = DriverManager.getConnection(url, username, password);<br><br>        <span class="hljs-comment">//接收用户名和密码 sql注入-&gt;此处密码错误却还能成功登陆</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ikunngmngmngm&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#x27;or &#x27;1&#x27; = &#x27;1&quot;</span>;<br><br>        <span class="hljs-comment">//定义sql语句</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from tb_user where name = ? and password = ?&quot;</span>;<br><br>        <span class="hljs-comment">//获取Statement对象</span><br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br><br>        <span class="hljs-comment">//设置？的值</span><br>        pstmt.setString(<span class="hljs-number">1</span>, name);<br>        pstmt.setString(<span class="hljs-number">2</span>, pwd);<br><br>        <span class="hljs-comment">//执行sql语句</span><br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> pstmt.executeQuery();<br><br>        <span class="hljs-comment">//判断是否登陆成功</span><br>        System.out.println(rs.next() ? <span class="hljs-string">&quot;登陆成功&quot;</span> : <span class="hljs-string">&quot;登陆失败&quot;</span>);<br><br>        <span class="hljs-comment">//7、释放资源</span><br>        rs.close();<br>        pstmt.close();<br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8、Druid数据库连接池">8、Druid数据库连接池</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Druid;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Druid数据库连接池</span><br><span class="hljs-comment"> * */</span><br><br><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DruidDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1、导入jar包</span><br>        <span class="hljs-comment">//2、定义配置文件</span><br>        <span class="hljs-comment">//3、加载配置文件</span><br><br>        <span class="hljs-comment">//4、获取连接池对象</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdbcDemo/src/druid.properties&quot;</span>));<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);<br><br>        <span class="hljs-comment">//5、获取数据库连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        System.out.println(connection);<br><br><br><span class="hljs-comment">//        System.out.println(System.getProperty(&quot;user.dir&quot;));</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//配置文件（根据具体情况配置）</span><br>driverClassName=com.mysql.cj.jdbc.Driver<br>url=jdbc:mysql:/clb?useSSL=<span class="hljs-literal">false</span>&amp;useServerPrepStmts=<span class="hljs-literal">true</span><br>username=root<br>password=<span class="hljs-number">123456</span><br># 初始化连接数量<br>initialSize=<span class="hljs-number">5</span><br># 最大连接数量<br>maxActive=<span class="hljs-number">10</span><br># 最大等待时间-&gt;<span class="hljs-number">3</span>秒<br>maxWait=<span class="hljs-number">30000</span><br></code></pre></td></tr></table></figure><h1>十、进阶</h1><h2 id="1、索引">1、索引</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">-- 索引<br><br>-- 查询表中所有索引<br>show index from tb_user;<br><br>-- 创建索引:  create index 索引名 on 表名(字段名);<br>-- 给表中name字段创建常规索引<br>create index idx_user_name on tb_user (name);<br><br>-- 给表中phone字段创建唯一索引<br>create unique index idx_user_phone on tb_user (phone);<br><br>-- 给表中profession,age,status创建联合索引,字段的顺序是有讲究的<br>create index idx_user_pro_age_sta on tb_user (profession, age, status);<br><br>-- 给表中email字段创建常规索引<br>create index idx_user_email on tb_user (email);<br><br>-- 删除索引:  drop index 索引名 on 表名;<br>drop index idx_user_email on tb_user;<br><br><br>-- SQL性能分析<br>-- 1、查看各种sql语句的执行频率<br>show global status like &#x27;Com_______&#x27;;<br><br>-- 2、慢查询日志,查询语句执行时间超过指定时间（默认10秒）就会记录到慢查询日志<br>show variables like &#x27;slow_query_log&#x27;;<br><br><br><br>-- 3、profile 详情<br>-- 查看是否支持profiling<br>select @@have_profiling;<br><br>-- 查看profiling是否开启 0-未开启 1-开启<br>select @@profiling;<br><br>-- 开启profiling<br>set profiling = 1;<br><br>select *<br>from tb_user;<br><br><br>-- 查看所有查询语句耗时情况<br>show profiles;<br><br>-- 查看指定查询语句的各个阶段的耗时<br>-- show profile for query 10;<br><br>-- 额外查看sql语句cpu消耗<br>-- show profile cpu for query 10;<br><br><br>-- 4、explain 执行计划<br><br>explain<br>select *<br>from tb_user<br>where id = 1;<br><br><br>-- 索引的使用<br>/**<br>1-最左前缀法则：<br>最左边的索引必须存在，否则索引全部失效<br> 如果跳过了某个索引，那么从该索引开始的后面字段的索引失效<br>*/<br><br>show index from tb_user;<br><br>-- 没有跳过索引，索引全部生效<br>explain<br>select *<br>from tb_user<br>where profession = &#x27;软件工程&#x27;<br>and age = 31<br>and status = &#x27;0&#x27;;<br><br>explain<br>select *<br>from tb_user<br>where profession = &#x27;软件工程&#x27;<br>and age = 31;<br><br>explain<br>select *<br>from tb_user<br>where profession = &#x27;软件工程&#x27;;<br><br>-- 跳过最左边的索引，索引全部失效<br>explain<br>select *<br>from tb_user<br>where age = 31<br>and status = &#x27;0&#x27;;<br><br>-- 跳过age索引，后面的status索引失效，前面的profession索引正常<br>explain<br>select *<br>from tb_user<br>where profession = &#x27;软件工程&#x27;<br>and status = &#x27;0&#x27;;<br><br>-- 查询语句的条件的位置不影响索引是否生效<br>-- 没有跳过任何索引，索引全部生效<br>explain<br>select *<br>from tb_user<br>where status = &#x27;0&#x27;<br>and age = 31<br>and profession = &#x27;软件工程&#x27;;<br><br>/**<br>2-出现范围查询(&gt;,&lt;)时，后面的索引失效,使用&gt;=,&lt;=不会<br>*/<br><br>explain<br>select *<br>from tb_user<br>where profession = &#x27;软件工程&#x27;<br>and age &gt; 30<br>and status = &#x27;0&#x27;;<br><br>/**<br>3-索引运算<br>    ·不要在索引上进行运算，否则索引失效<br>    ·字符串字段查询时不加单引号，索引失效<br>*/<br><br>explain<br>select *<br>from tb_user<br>where substring(phone, 10, 2) = &#x27;15&#x27;;<br><br>explain<br>select *<br>from tb_user<br>where phone = 17799990004;<br>-- 没用单引号，索引失效<br><br>/**<br>4-模糊匹配<br>    ·后面加%/_模糊匹配，索引正常<br>    ·前面模糊，索引失效<br>*/<br><br>explain<br>select *<br>from tb_user<br>where profession like &#x27;软件%&#x27;; -- 索引有效<br><br><br>explain<br>select *<br>from tb_user<br>where profession like &#x27;%工程&#x27;;<br><br>/**<br>5-or连接的条件<br>    ·只有两个条件都有索引，索引才会生效，否则失效<br>    ·解决方法：建立相关字段的索引<br>*/<br>explain<br>select *<br>from tb_user<br>where phone = &#x27;17799990004&#x27;<br>or age = 31; -- phone有索引，但是age没有索引，索引失效<br><br>explain<br>select *<br>from tb_user<br>where phone = &#x27;17799990004&#x27;<br>or id = 1;<br>-- phone 和 id都有索引，索引生效<br><br><br>/**<br>6-数据分布影响<br>·如果MySQL评估使用索引比全表更慢，则放弃索引，大部分数据都符合条件时会出现这种情况<br>*/<br><br>explain<br>select *<br>from tb_user<br>where phone &gt; &#x27;0&#x27;;<br>-- 所有电话号码都大于0，使用全表扫描<br><br>-- 使用了索引，具体使用索引还是不使用索引取决表中的数据，符合条件的数据多-&gt;不用，少-&gt;用<br>explain<br>select *<br>from tb_user<br>where profession is null;<br><br>-- 未使用索引<br>explain<br>select *<br>from tb_user<br>where profession is not null;<br><br><br><br>-- SQL提示:是优化数据库的一个重要手段，就是在sql语句中加入一些人为的提示达到优化操作的目的<br>-- 查询一个字段时，如果同时存在单列索引和联合索引，默认使用联合索引<br><br>-- profession有两个索引，默认使用的是联合索引<br>explain<br>select *<br>from tb_user<br>where profession = &#x27;软件工程&#x27;;<br><br>-- use index 建议MySQL使用这个索引，至于用不用，取决于MySQL<br>explain<br>select *<br>from tb_user use index (idx_user_pro)<br>where profession = &#x27;软件工程&#x27;;<br><br>-- ignore index 忽略索引，指定不会使用该索引<br>explain<br>select *<br>from tb_user ignore index (idx_user_pro)<br>where profession = &#x27;软件工程&#x27;;<br><br>-- force index 强制使用，指定必须使用该索引,use可能MySQL并不接受，force强制MySQL使用<br><br>-- ---------------------------------------------------------------<br><br></code></pre></td></tr></table></figure><h2 id="2、SQL优化">2、SQL优化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">-- SQL优化<br><br>-- 1、插入优化:<br>-- 批量插入<br>-- 手动控制事务<br>-- 主键顺序插入<br>-- load指令<br><br>select @@local_infile;<br>set global local_infile = 1;<br><br>load data local infile &#x27;D:/Edge下载/进阶篇/相关SQL脚本/load_user_100w_sort.sql&#x27; into table tb_user fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;<br><br>-- 2、主键优化：<br>-- 尽量降低主键的长度<br>-- 插入数据时，尽量使用顺序插入<br>-- 尽量不要使用UUID或者其他自然主键<br>-- 尽量不对主键进行修改<br><br>-- 3、order by 优化：<br>-- using filesort:效率低<br>-- using index:效率高<br>show index from  tb_user; -- Collation:索引的顺序，A-&gt;升序，D-&gt;降序<br><br>explain select age,phone from tb_user order by age,phone;<br><br>-- 创建age和phone字段的一个联合索引,根据索引查询，结果不需要再进行排序<br>create index idx_user_age_phone on tb_user(age,phone);<br><br>-- 两个条件都是倒序，使用index倒序扫描 Backward index scan; Using index<br>explain select age,phone from tb_user order by age desc,phone desc ;<br><br>-- 先对phone排序，再根据age排序,不符合最左前缀法则，Using index; Using filesort<br>explain select age,phone from tb_user order by phone,age;<br><br>-- 先对age升序，再对phone降序排序<br>explain select age,phone from tb_user order by age,phone desc;<br><br>-- 优化：创建age升序phone降序的索引(默认是升序)<br>create index idx_user_age_phone_ad on tb_user(age,phone desc);<br><br>-- 尽量避免使用select*,否则需要所有字段都建立了联合索引才能走索引，否则就是filesort<br>-- 不可避免使用filesort时，可以适当增大排序文件缓冲区大小<br><br>-- limit 优化<br>select *<br>from tb_user<br>limit 900000,10;<br><br>-- 覆盖索引加子查询的形式<br>select t.*<br>from tb_user t,<br>(select id from tb_user order by id limit 900000,10) e<br>where t.id = e.id;<br><br><br>-- count()优化<br>-- 效率 count(*) ≈ count(1) &gt; count(主键) &gt; count(字段)<br>select count(*)from tb_user;<br>select count(id)from tb_user;<br>select count(1)from tb_user;<br>select count(username) from tb_user;<br><br>-- update 优化<br>-- update更新的数据最好有索引，否则执行update语句时行锁会升级为表锁，并发性能降低<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2023/07/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/07/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-引论">第一章 引论</h2><h3 id="操作系统的定义：">操作系统的定义：</h3><blockquote><p><strong>==操作系统是直接控制和管理计算机软硬件资源，合理地组织计算机工作流程，便于用户使用的程序的集合==</strong></p></blockquote><hr><h3 id="操作系统的功能：（操作系统的主要功能是管理系统中的资源）">操作系统的功能：（操作系统的主要功能是管理系统中的资源）</h3><blockquote><ul><li><strong>==处理器管理==</strong></li><li><strong>==存储器管理==</strong></li><li><strong>==I/O设备管理==</strong></li><li><strong>==文件管理==</strong></li><li><strong>==用户接口==</strong></li></ul></blockquote><hr><h3 id="操作系统的特性">操作系统的特性</h3><ul><li><strong>并发性：操作系统最重要的特性</strong></li><li><strong>共享性</strong></li><li><strong>虚拟性</strong></li><li><strong>异步性</strong></li></ul><hr><h3 id="操作系统的分类">操作系统的分类</h3><ol><li><p><strong>批处理系统：具有批处理功能但不具有交互能力，设计时应优先考虑 周转时间和吞吐量</strong></p></li><li><p><strong>分时系统（重要指标-响应时间）</strong></p><blockquote><p><strong>特点：交互性、同时性、独立性、及时性</strong></p></blockquote></li><li><p><strong>实时操作系统</strong></p><blockquote><p><strong>特点：实时性、高可靠性、安全性</strong></p></blockquote></li><li><p><strong>微机操作系统</strong></p></li><li><p><strong>网络操作系统</strong></p><blockquote><p><strong>两种主要的工作模式：客户/服务器模式、对等模式</strong></p></blockquote></li><li><p><strong>分布式操作系统</strong></p><blockquote><p><strong>特点：分布性、透明性、统一性、健壮性</strong></p></blockquote></li><li><p><strong>嵌入式操作系统</strong></p></li></ol><hr><h3 id="操作系统的结构模型">操作系统的结构模型</h3><ol><li><p><strong>整体式模型：容易使系统陷于死锁</strong></p></li><li><p><strong>层次式模型</strong></p></li><li><p><strong>微内核和客户/服务器模型</strong></p><blockquote><p><strong>微内核优点：可扩展性强、可靠性高、可移植性好</strong></p></blockquote></li><li><p><strong>面向对象模型</strong></p></li></ol><hr><h2 id="第二章-用户与操作系统的接口">第二章 用户与操作系统的接口</h2><h3 id="作业：">作业：</h3><blockquote><p><strong>==用户一次请求计算机系统为其完成任务所进行的工作的总和==</strong></p></blockquote><hr><h3 id="程序级接口">程序级接口</h3><ol><li><p><strong>用户态和核心态</strong></p></li><li><p><strong>特权指令和访管指令</strong></p><blockquote><p><strong>特权指令：只允许在核心态下使用的指令</strong></p><p><strong>访管指令功能</strong></p><ol><li><strong>实现从用户态到核心态的转变</strong></li><li><strong>在核心态下由操作系统代替用户完成其要求</strong></li><li><strong>工作完成后有核心态返回到用户态</strong></li></ol></blockquote></li></ol><hr><h2 id="第三章-进程的描述与控制">第三章 进程的描述与控制</h2><h3 id="1-程序顺序执行">1. 程序顺序执行</h3><blockquote><ol><li><strong>顺序性</strong></li><li><strong>封闭性</strong></li><li><strong>可再现性</strong></li></ol></blockquote><hr><h3 id="2-进程描述">2. 进程描述</h3><blockquote><p><strong>==定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，进程是系统进行资源分配和调度的的一个独立单位。==</strong></p></blockquote><hr><h3 id="3-进程的特性">3. 进程的特性</h3><blockquote><ol><li><strong>动态性：进程最基本的特征，与静态的程序不同</strong></li><li><strong>并发性：多个进程可以同时存在于内存中，在一段时间内并发运行，不是同时执行</strong></li><li><strong>独立性</strong></li><li><strong>异步性</strong></li><li><strong>结构性</strong></li></ol></blockquote><hr><h3 id="4-进程与程序的区别">4. 进程与程序的区别</h3><blockquote><ol><li><strong>进程的动态性</strong></li><li><strong>进程的暂时性</strong></li><li><strong>进程的结构性</strong></li></ol></blockquote><hr><h3 id="5-进程控制块（PCB）">5.进程控制块（PCB）</h3><hr><h3 id="6-进程状态">6. 进程状态</h3><blockquote><p><strong>==基本状态：==</strong></p><ol><li><strong>==就绪态==</strong></li><li><strong>==执行态==</strong></li><li><strong>==阻塞态==</strong></li></ol><p><strong>==状态的转换：==</strong></p><ol><li><strong>==就绪态 -&gt; 执行态：进程调度==</strong></li><li><strong>==执行态 -&gt; 就绪态：时间片到或被强占==</strong></li><li><strong>==执行态 -&gt; 阻塞态：I/O请求或等待某个事件==</strong></li><li><strong>==阻塞态 -&gt; 就绪态：I/O完成或事件发生==</strong></li></ol></blockquote><hr><h3 id="7-原语操作">7. 原语操作</h3><blockquote><ol><li><strong>原语：原子操作，原语中的所有动作要么全做要么全不做，具有不可分割性</strong></li><li><strong>进程控制原语：</strong><ol><li>==<strong>创建原语：进程可以创建子进程，进程只能由其父进程创建</strong>==</li><li>==<strong>撤销原语：进程完成任务后应将其撤销，撤销原语由其父进程发出，一个进程不会撤销自己</strong>==</li><li>==<strong>阻塞原语：进程阻塞是进程的自身行为</strong>==</li><li>==<strong>唤醒原语：由相关进程唤醒，从阻塞态转换为就绪态</strong>==</li><li>==<strong>挂起原语：只能挂起该进程的子孙进程</strong>==</li><li>==<strong>激活原语：只能激活自己的子孙进程</strong>==</li></ol></li></ol></blockquote><hr><h3 id="8-线程（调度和执行的基本的单位）">8. 线程（调度和执行的基本的单位）</h3><blockquote><ol><li>线程引入：==减少时空开销，提高并发性==</li><li>线程的定义：==线程是进程内一个相对独立、可调度的执行单位，是进程中一个单一的控制线索==</li><li>线程可以共享进程的所拥有的全部资源，同一个进程中的所有线程可以并发执行</li></ol></blockquote><hr><h2 id="第四章-进程通信">第四章 进程通信</h2><h3 id="临界资源和临界区">临界资源和临界区</h3><blockquote><ol><li><strong>==临界资源：一次仅允许一个进程使用的资源称为临界资源==</strong></li><li><strong>==临界区：每个进程中访问临界资源的那段程序代码称为临界区==</strong></li></ol></blockquote><hr><h3 id="同步机构设计准则">同步机构设计准则</h3><blockquote><ol><li>==<strong>空闲让进</strong>==</li><li>==<strong>忙则等待</strong>==</li><li>==<strong>有限等待</strong>==</li><li>==<strong>让权等待</strong>==</li></ol></blockquote><hr><h3 id="信号量机制实现互斥和同步（低级方法，只能传递少量信息）">信号量机制实现互斥和同步（低级方法，只能传递少量信息）</h3><hr><h2 id="第五章">第五章</h2><h3 id="作业调度">作业调度</h3><blockquote><p><strong>目标：</strong></p><ol><li><strong>面向系统：</strong><ol><li><strong>吞吐量大：评价批处理系统的重要指标（吞吐量是指单位时间内完成的作业数）</strong></li><li><strong>CPU利用率高</strong></li><li><strong>各类资源的平衡利用</strong></li></ol></li><li><strong>面向用户准则：</strong><ol><li><strong>周转时间短：周转时间=完成时间-创建时间</strong></li><li>==<strong>平均周转时间：周转时间的平均值</strong>==</li><li><strong>平均带权周转时间：带权周转时间=完成时间-创建时间）/运行时间</strong></li><li><strong>省略三点</strong></li></ol></li></ol></blockquote><hr><h3 id="进程调度">进程调度</h3><blockquote><ol><li>时机：<ol><li>==执行完毕或异常终止==</li><li>==自己调用阻塞原语而进入等待状态==</li><li>==时间片用完==</li><li>==执行完系统调用后返回用户进程时==</li><li>==就绪队列某个进程的优先级高于当前的进程==</li></ol></li></ol></blockquote><h3 id="常用的调度算法">常用的调度算法</h3><blockquote><ol><li>==先来先服务（FCFS）==</li><li>==短作业（进程）优先==</li><li>==时间片轮转调度算法：（时间片用完的进程和新进入的进程同时进入就绪队列时，新来的优先）==</li><li>==高优先权优先调度算法==</li><li>==最高响应比优先调度算法：响应比：（等待时间+需要执行的时间）/需要执行的时间==</li></ol></blockquote><hr><h2 id="第六章">第六章</h2><h3 id="死锁的定义">死锁的定义</h3><blockquote><p><strong>==死锁 是一种状态：在系统中，两个或两个以上的进程无限期地等待永远不可能发生的事件，则称这些进程处于死锁状态==</strong></p></blockquote><h3 id="死锁的原因">死锁的原因</h3><blockquote><ol><li><strong>==竞争资源==</strong></li><li><strong>==进程推进顺序不合理==</strong></li></ol></blockquote><h3 id="死锁的必要条件">死锁的必要条件</h3><blockquote><ol><li><strong>==互斥条件：一个进程得到的资源其他进程不能使用==</strong></li><li><strong>==请求和保持条件：进程手上拿着资源不释放的前提下还请求其他资源==</strong></li><li><strong>==环路条件：发生死锁时，必然存在一个进程-资源的环形链==</strong></li></ol></blockquote><h3 id="处理死锁的策略">处理死锁的策略</h3><blockquote><ol><li><strong>预防策略</strong>：==<strong>破坏死锁的四个必要条件中的一个或多个</strong>==从而预防死锁的发生<ol><li>破坏互斥条件</li><li>破坏不剥夺条件</li><li>破坏请求与保持条件：==<strong>静态资源分配法-&gt;必须一次性申请在运行过程中需要的所有资源</strong>==</li><li>破坏环路条件：==<strong>有序资源使用法-&gt;将系统所有资源按类型进行线性排队，并赋予不同序号</strong>==</li></ol></li><li><strong>避免策略</strong>：资源动态分配时**==采用某些办法（银行家算法）防止系统进入不安全状态==**，从而避免死锁<ol><li>==<strong>银行家算法：当系统的资源满足不了任何进程时，就是不安全状态</strong>==</li></ol></li><li><strong>死锁检测</strong>：==<strong>允许系统发生死锁，发生后及时检测出死锁然后解除死锁</strong>==</li><li><strong>解除策略</strong>：==<strong>和死锁检测相配套，发生死锁时，将死锁解除</strong>==</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2023/07/28/C/"/>
      <url>/2023/07/28/C/</url>
      
        <content type="html"><![CDATA[<h1>C++核心编程</h1><p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p><h2 id="1-内存分区模型">1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><h3 id="1-1-程序运行前">1.1 程序运行前</h3><p>​    在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p>​    <strong>代码区：</strong></p><p>​        存放 CPU 执行的机器指令</p><p>​        代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​        代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p>​    <strong>全局区：</strong></p><p>​        全局变量和静态变量存放在此.</p><p>​        全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p><p>​        ==该区域的数据在程序结束后由操作系统释放==.</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//全局变量</span><br><span class="hljs-type">int</span> g_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> g_b = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//全局常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_g_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_g_b = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//局部变量</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">//打印地址</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;b &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="hljs-type">int</span>)&amp;g_a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="hljs-type">int</span>)&amp;g_b &lt;&lt; endl;<br><br>    <span class="hljs-comment">//静态变量</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> s_a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> s_b = <span class="hljs-number">10</span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;s_a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;s_b &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;<span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;<span class="hljs-string">&quot;hello world1&quot;</span> &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_g_a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_g_b &lt;&lt; endl;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> c_l_a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> c_l_b = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_l_a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_l_b &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量  和 字符串常量</li></ul><h3 id="1-2-程序运行后">1.2 程序运行后</h3><p>​    <strong>栈区：</strong></p><p>​        由编译器自动分配释放, 存放函数的参数值,局部变量等</p><p>​        注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> * <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> &amp;a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> *p = <span class="hljs-built_in">func</span>();<br><br>    cout &lt;&lt; *p &lt;&lt; endl;<br>    cout &lt;&lt; *p &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    <strong>堆区：</strong></p><p>​        由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p><p>​        在C++中主要利用new在堆区开辟内存</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> *p = <span class="hljs-built_in">func</span>();<br><br>    cout &lt;&lt; *p &lt;&lt; endl;<br>    cout &lt;&lt; *p &lt;&lt; endl;<br>    <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h3 id="1-3-new操作符">1.3 new操作符</h3><p>​    C++中利用==new==操作符在堆区开辟数据</p><p>​    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p><p>​    语法：<code> new 数据类型</code></p><p>​    利用new创建的数据，会返回该数据对应的类型的指针</p><p><strong>示例1： 基本语法</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> *p = <span class="hljs-built_in">func</span>();<br><br>    cout &lt;&lt; *p &lt;&lt; endl;<br>    cout &lt;&lt; *p &lt;&lt; endl;<br><br>    <span class="hljs-comment">//利用delete释放堆区数据</span><br>    <span class="hljs-keyword">delete</span> p;<br><br>    <span class="hljs-comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例2：开辟数组</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//堆区开辟数组</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        arr[i] = i + <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        cout &lt;&lt; arr[i] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//释放数组 delete 后加 []</span><br>    <span class="hljs-keyword">delete</span>[] arr;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-引用">2 引用</h2><h3 id="2-1-引用的基本使用">2.1 引用的基本使用</h3><p>**作用： **给变量起别名</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> &amp;b = a;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    b = <span class="hljs-number">100</span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-引用注意事项">2.2 引用注意事项</h3><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-comment">//int &amp;c; //错误，引用必须初始化</span><br>    <span class="hljs-type">int</span> &amp;c = a; <span class="hljs-comment">//一旦初始化后，就不可以更改</span><br>    c = b; <span class="hljs-comment">//这是赋值操作，不是更改引用</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-引用做函数参数">2.3 引用做函数参数</h3><p>**作用：**函数传参时，可以利用引用的技术让形参修饰实参</p><p>**优点：**可以简化指针修改实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1. 值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap01</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><br><span class="hljs-comment">//2. 地址传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap02</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br><br><span class="hljs-comment">//3. 引用传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap03</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-built_in">mySwap01</span>(a, b);<br>    cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    <span class="hljs-built_in">mySwap02</span>(&amp;a, &amp;b);<br>    cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    <span class="hljs-built_in">mySwap03</span>(a, b);<br>    cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p></blockquote><h3 id="2-4-引用做函数返回值">2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p><p>注意：<strong>不要返回局部变量引用</strong></p><p>用法：函数调用作为左值</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//返回局部变量引用</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">//局部变量</span><br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-comment">//返回静态变量引用</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//不能返回局部变量的引用</span><br>    <span class="hljs-type">int</span>&amp; ref = <span class="hljs-built_in">test01</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;<br><br>    <span class="hljs-comment">//如果函数做左值，那么必须返回引用</span><br>    <span class="hljs-type">int</span>&amp; ref2 = <span class="hljs-built_in">test02</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br><br>    <span class="hljs-built_in">test02</span>() = <span class="hljs-number">1000</span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><h3 id="2-5-引用的本质">2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p><p>讲解示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//发现是引用，转换为 int* const ref = &amp;a;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; ref)</span></span>&#123;<br>    ref = <span class="hljs-number">100</span>; <span class="hljs-comment">// ref是引用，转换为*ref = 100</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span><br>    <span class="hljs-type">int</span>&amp; ref = a; <br>    ref = <span class="hljs-number">20</span>; <span class="hljs-comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span><br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;<br>    <br>    <span class="hljs-built_in">func</span>(a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="2-6-常量引用">2.6 常量引用</h3><p>**作用：**常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//引用使用的场景，通常用来修饰形参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; v)</span> </span>&#123;<br>    <span class="hljs-comment">//v += 10;</span><br>    cout &lt;&lt; v &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span><br>    <span class="hljs-comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ref = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">//ref = 100;  //加入const后不可以修改变量</span><br>    cout &lt;&lt; ref &lt;&lt; endl;<br><br>    <span class="hljs-comment">//函数中利用常量引用防止误操作修改实参</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">showValue</span>(a);<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-函数提高">3 函数提高</h2><h3 id="3-1-函数默认参数">3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> c = <span class="hljs-number">10</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><br><span class="hljs-comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span><br><span class="hljs-comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>) &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-函数占位参数">3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数占位参数 ，占位参数也可以有默认参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span>)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;this is func&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>); <span class="hljs-comment">//占位参数必须填补</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-函数重载">3.3 函数重载</h3><h4 id="3-3-1-函数重载概述">3.3.1 函数重载概述</h4><p>**作用：**函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li></ul><p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数重载需要函数都在同一个作用域下</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a ,<span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a ,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//函数返回值不可以作为函数重载条件</span><br><span class="hljs-comment">//int func(double a, int b)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//    cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span>);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">3.14</span>);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span> , <span class="hljs-number">10</span>);<br>    <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-函数重载注意事项">3.3.2 函数重载注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数重载注意事项</span><br><span class="hljs-comment">//1、引用作为重载条件</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-comment">//2、函数重载碰到函数默认参数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">func</span>(a); <span class="hljs-comment">//调用无const</span><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//调用有const</span><br><br><br>    <span class="hljs-comment">//func2(10); //碰到默认参数产生歧义，需要避免</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-类和对象"><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：==封装、继承、多态==</p><p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p><p><strong>例如：</strong></p><p>​    人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p><p>​    车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p><p>​    具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p><h3 id="4-1-封装">4.1 封装</h3><h4 id="4-1-1-封装的意义">4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p>​    在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><p>**示例1：**设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//圆周率</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14</span>;<br><br><span class="hljs-comment">//1、封装的意义</span><br><span class="hljs-comment">//将属性和行为作为一个整体，用来表现生活中的事物</span><br><br><span class="hljs-comment">//封装一个圆类，求圆的周长</span><br><span class="hljs-comment">//class代表设计一个类，后面跟着的是类名</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span><br>&#123;<br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">//访问权限  公共的权限</span><br><br>    <span class="hljs-comment">//属性</span><br>    <span class="hljs-type">int</span> m_r;<span class="hljs-comment">//半径</span><br><br>    <span class="hljs-comment">//行为</span><br>    <span class="hljs-comment">//获取到圆的周长</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calculateZC</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//2 * pi  * r</span><br>        <span class="hljs-comment">//获取圆的周长</span><br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">2</span> * PI * m_r;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//通过圆类，创建圆的对象</span><br>    <span class="hljs-comment">// c1就是一个具体的圆</span><br>    Circle c1;<br>    c1.m_r = <span class="hljs-number">10</span>; <span class="hljs-comment">//给圆对象的半径 进行赋值操作</span><br><br>    <span class="hljs-comment">//2 * pi * 10 = = 62.8</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="hljs-built_in">calculateZC</span>() &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//学生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(string name)</span> </span>&#123;<br>        m_name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setID</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>        m_id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showStudent</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="hljs-string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    string m_name;<br>    <span class="hljs-type">int</span> m_id;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    Student stu;<br>    stu.<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;德玛西亚&quot;</span>);<br>    stu.<span class="hljs-built_in">setID</span>(<span class="hljs-number">250</span>);<br>    stu.<span class="hljs-built_in">showStudent</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限</li><li>protected 保护权限</li><li>private      私有权限</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//三种权限</span><br><span class="hljs-comment">//公共权限  public     类内可以访问  类外可以访问</span><br><span class="hljs-comment">//保护权限  protected  类内可以访问  类外不可以访问</span><br><span class="hljs-comment">//私有权限  private    类内可以访问  类外不可以访问</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br>    <span class="hljs-comment">//姓名  公共权限</span><br><span class="hljs-keyword">public</span>:<br>    string m_Name;<br><br>    <span class="hljs-comment">//汽车  保护权限</span><br><span class="hljs-keyword">protected</span>:<br>    string m_Car;<br><br>    <span class="hljs-comment">//银行卡密码  私有权限</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_Password;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_Name = <span class="hljs-string">&quot;张三&quot;</span>;<br>        m_Car = <span class="hljs-string">&quot;拖拉机&quot;</span>;<br>        m_Password = <span class="hljs-number">123456</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    Person p;<br>    p.m_Name = <span class="hljs-string">&quot;李四&quot;</span>;<br>    <span class="hljs-comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span><br>    <span class="hljs-comment">//p.m_Password = 123; //私有权限类外访问不到</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-2-struct和class区别">4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class   默认权限为私有</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span><br>&#123;<br>    <span class="hljs-type">int</span>  m_A; <span class="hljs-comment">//默认是私有权限</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C2</span><br>&#123;<br>    <span class="hljs-type">int</span> m_A;  <span class="hljs-comment">//默认是公共权限</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    C1 c1;<br>    c1.m_A = <span class="hljs-number">10</span>; <span class="hljs-comment">//错误，访问权限是私有</span><br><br>    C2 c2;<br>    c2.m_A = <span class="hljs-number">10</span>; <span class="hljs-comment">//正确，访问权限是公共</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-成员属性设置为私有">4.1.3 成员属性设置为私有</h4><p>**优点1：**将所有成员属性设置为私有，可以自己控制读写权限</p><p>**优点2：**对于写权限，我们可以检测数据的有效性</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//姓名设置可读可写</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(string name)</span> </span>&#123;<br>        m_Name = name;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_Name;<br>    &#125;<br><br><br>    <span class="hljs-comment">//获取年龄 </span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_Age;<br>    &#125;<br>    <span class="hljs-comment">//设置年龄</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">150</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        m_Age = age;<br>    &#125;<br><br>    <span class="hljs-comment">//情人设置为只写</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLover</span><span class="hljs-params">(string lover)</span> </span>&#123;<br>        m_Lover = lover;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    string m_Name; <span class="hljs-comment">//可读可写  姓名</span><br>    <br>    <span class="hljs-type">int</span> m_Age; <span class="hljs-comment">//只读  年龄</span><br><br>    string m_Lover; <span class="hljs-comment">//只写  情人</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    Person p;<br>    <span class="hljs-comment">//姓名设置</span><br>    p.<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="hljs-built_in">getName</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">//年龄设置</span><br>    p.<span class="hljs-built_in">setAge</span>(<span class="hljs-number">50</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="hljs-built_in">getAge</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">//情人设置</span><br>    p.<span class="hljs-built_in">setLover</span>(<span class="hljs-string">&quot;苍井&quot;</span>);<br>    <span class="hljs-comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习案例1：设计立方体类</strong></p><p>设计立方体类(Cube)</p><p>求出立方体的面积和体积</p><p>分别用全局函数和成员函数判断两个立方体是否相等。</p><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/assets/1545533548532.png" alt="1545533548532"></p><p><strong>练习案例2：点和圆的关系</strong></p><p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/assets/1545533829184.png" alt="1545533829184"></p><h3 id="4-2-对象的初始化和清理">4.2 对象的初始化和清理</h3><ul><li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li></ul><h4 id="4-2-1-构造函数和析构函数">4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p>​    一个对象或者变量没有初始状态，对其使用后果是未知</p><p>​    同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号  ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-2-构造函数的分类及调用">4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><p>​    按参数分为： 有参构造和无参构造</p><p>​    按类型分为： 普通构造和拷贝构造</p><p>三种调用方式：</p><p>​    括号法</p><p>​    显示法</p><p>​    隐式转换法</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1、构造函数分类</span><br><span class="hljs-comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span><br><span class="hljs-comment">// 按照类型分类分为 普通构造和拷贝构造</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//无参（默认）构造函数</span><br>    <span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//有参构造函数</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a) &#123;<br>        age = a;<br>        cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>        age = p.age;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">//2、构造函数的调用</span><br><span class="hljs-comment">//调用无参构造函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Person p; <span class="hljs-comment">//调用无参构造函数</span><br>&#125;<br><br><span class="hljs-comment">//调用有参的构造函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//2.1  括号法，常用</span><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span><br>    <span class="hljs-comment">//Person p2();</span><br><br>    <span class="hljs-comment">//2.2 显式法</span><br>    Person p2 = <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>); <br>    Person p3 = <span class="hljs-built_in">Person</span>(p2);<br>    <span class="hljs-comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span><br><br>    <span class="hljs-comment">//2.3 隐式转换法</span><br>    Person p4 = <span class="hljs-number">10</span>; <span class="hljs-comment">// Person p4 = Person(10); </span><br>    Person p5 = p4; <span class="hljs-comment">// Person p5 = Person(p4); </span><br><br>    <span class="hljs-comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span><br>    <span class="hljs-comment">//Person p5(p4);</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-comment">//test02();</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-3-拷贝构造函数调用时机">4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>        mAge = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>        mAge = age;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>        mAge = p.mAge;<br>    &#125;<br>    <span class="hljs-comment">//析构函数在释放内存之前调用</span><br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> mAge;<br>&#125;;<br><br><span class="hljs-comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-function">Person <span class="hljs-title">man</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">//p对象已经创建完毕</span><br>    <span class="hljs-function">Person <span class="hljs-title">newman</span><span class="hljs-params">(man)</span></span>; <span class="hljs-comment">//调用拷贝构造函数</span><br>    Person newman2 = man; <span class="hljs-comment">//拷贝构造</span><br><br>    <span class="hljs-comment">//Person newman3;</span><br>    <span class="hljs-comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span><br>&#125;<br><br><span class="hljs-comment">//2. 值传递的方式给函数参数传值</span><br><span class="hljs-comment">//相当于Person p1 = p;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(Person p1)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    Person p; <span class="hljs-comment">//无参构造函数</span><br>    <span class="hljs-built_in">doWork</span>(p);<br>&#125;<br><br><span class="hljs-comment">//3. 以值方式返回局部对象</span><br><span class="hljs-function">Person <span class="hljs-title">doWork2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p1;<br>    cout &lt;&lt; (<span class="hljs-type">int</span> *)&amp;p1 &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p = <span class="hljs-built_in">doWork2</span>();<br>    cout &lt;&lt; (<span class="hljs-type">int</span> *)&amp;p &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//test01();</span><br>    <span class="hljs-comment">//test02();</span><br>    <span class="hljs-built_in">test03</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-4-构造函数调用规则">4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//无参（默认）构造函数</span><br>    <span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//有参构造函数</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a) &#123;<br>        age = a;<br>        cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>        age = p.age;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span><br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span><br>    Person p1; <span class="hljs-comment">//此时如果用户自己没有提供默认构造，会出错</span><br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//用户提供的有参</span><br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>; <span class="hljs-comment">//此时如果用户没有提供拷贝构造，编译器会提供</span><br><br>    <span class="hljs-comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span><br>    Person p4; <span class="hljs-comment">//此时如果用户自己没有提供默认构造，会出错</span><br>    <span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//此时如果用户自己没有提供有参，会出错</span><br>    <span class="hljs-function">Person <span class="hljs-title">p6</span><span class="hljs-params">(p5)</span></span>; <span class="hljs-comment">//用户自己提供拷贝构造</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-5-深拷贝与浅拷贝">4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//无参（默认）构造函数</span><br>    <span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//有参构造函数</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age ,<span class="hljs-type">int</span> height) &#123;<br>        <br>        cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br><br>        m_age = age;<br>        m_height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(height);<br>        <br>    &#125;<br>    <span class="hljs-comment">//拷贝构造函数  </span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span><br>        m_age = p.m_age;<br>        m_height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.m_height);<br>        <br>    &#125;<br><br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (m_height != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m_height;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_age;<br>    <span class="hljs-type">int</span>* m_height;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>, <span class="hljs-number">180</span>)</span></span>;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="hljs-string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="hljs-string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="4-2-6-初始化列表">4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">////传统方式初始化</span><br>    <span class="hljs-comment">//Person(int a, int b, int c) &#123;</span><br>    <span class="hljs-comment">//    m_A = a;</span><br>    <span class="hljs-comment">//    m_B = b;</span><br>    <span class="hljs-comment">//    m_C = c;</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//初始化列表方式初始化</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c) :<span class="hljs-built_in">m_A</span>(a), <span class="hljs-built_in">m_B</span>(b), <span class="hljs-built_in">m_C</span>(c) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPerson</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-type">int</span> m_B;<br>    <span class="hljs-type">int</span> m_C;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>    p.<span class="hljs-built_in">PrintPerson</span>();<br><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-7-类对象作为类成员">4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>    A a；<br>&#125;<br></code></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Phone</span>(string name)<br>    &#123;<br>        m_PhoneName = name;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Phone构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Phone</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Phone析构&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    string m_PhoneName;<br><br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//初始化列表可以告诉编译器调用哪一个构造函数</span><br>    <span class="hljs-built_in">Person</span>(string name, string pName) :<span class="hljs-built_in">m_Name</span>(name), <span class="hljs-built_in">m_Phone</span>(pName)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person析构&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">playGame</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; m_Name &lt;&lt; <span class="hljs-string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="hljs-string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    string m_Name;<br>    Phone m_Phone;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span><br>    <span class="hljs-comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span><br>    <span class="hljs-comment">//析构顺序与构造相反</span><br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span> , <span class="hljs-string">&quot;苹果X&quot;</span>)</span></span>;<br>    p.<span class="hljs-built_in">playGame</span>();<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-8-静态成员">4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p>**示例1 ：**静态成员变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br>    <br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A; <span class="hljs-comment">//静态成员变量</span><br><br>    <span class="hljs-comment">//静态成员变量特点：</span><br>    <span class="hljs-comment">//1 在编译阶段分配内存</span><br>    <span class="hljs-comment">//2 类内声明，类外初始化</span><br>    <span class="hljs-comment">//3 所有对象共享同一份数据</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_B; <span class="hljs-comment">//静态成员变量也是有访问权限的</span><br>&#125;;<br><span class="hljs-type">int</span> Person::m_A = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> Person::m_B = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//静态成员变量两种访问方式</span><br><br>    <span class="hljs-comment">//1、通过对象</span><br>    Person p1;<br>    p1.m_A = <span class="hljs-number">100</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;<br><br>    Person p2;<br>    p2.m_A = <span class="hljs-number">200</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="hljs-comment">//共享同一份数据</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;<br><br>    <span class="hljs-comment">//2、通过类名</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;<br><br><br>    <span class="hljs-comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>**示例2：**静态成员函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//静态成员函数特点：</span><br>    <span class="hljs-comment">//1 程序共享一个函数</span><br>    <span class="hljs-comment">//2 静态成员函数只能访问静态成员变量</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;func调用&quot;</span> &lt;&lt; endl;<br>        m_A = <span class="hljs-number">100</span>;<br>        <span class="hljs-comment">//m_B = 100; //错误，不可以访问非静态成员变量</span><br>    &#125;<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A; <span class="hljs-comment">//静态成员变量</span><br>    <span class="hljs-type">int</span> m_B; <span class="hljs-comment">// </span><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-comment">//静态成员函数也是有访问权限的</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;func2调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> Person::m_A = <span class="hljs-number">10</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//静态成员变量两种访问方式</span><br><br>    <span class="hljs-comment">//1、通过对象</span><br>    Person p1;<br>    p1.<span class="hljs-built_in">func</span>();<br><br>    <span class="hljs-comment">//2、通过类名</span><br>    Person::<span class="hljs-built_in">func</span>();<br><br><br>    <span class="hljs-comment">//Person::func2(); //私有权限访问不到</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-C-对象模型和this指针">4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储">4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>() &#123;<br>        mA = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//非静态成员变量占对象空间</span><br>    <span class="hljs-type">int</span> mA;<br>    <span class="hljs-comment">//静态成员变量不占对象空间</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> mB; <br>    <span class="hljs-comment">//函数也不占对象空间，所有函数共享一个函数实例</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mA &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//静态成员函数也不占对象空间</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sfunc</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Person) &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-2-this指针概念">4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)<br>    &#123;<br>        <span class="hljs-comment">//1、当形参和成员变量同名时，可用this指针来区分</span><br>        <span class="hljs-keyword">this</span>-&gt;age = age;<br>    &#125;<br><br>    <span class="hljs-function">Person&amp; <span class="hljs-title">PersonAddPerson</span><span class="hljs-params">(Person p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;age += p.age;<br>        <span class="hljs-comment">//返回对象本身</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    p2.<span class="hljs-built_in">PersonAddPerson</span>(p1).<span class="hljs-built_in">PersonAddPerson</span>(p1).<span class="hljs-built_in">PersonAddPerson</span>(p1);<br>    cout &lt;&lt; <span class="hljs-string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-3-空指针访问成员函数">4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//空指针访问成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowClassName</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        cout &lt;&lt; mAge &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> mAge;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person * p = <span class="hljs-literal">NULL</span>;<br>    p-&gt;<span class="hljs-built_in">ShowClassName</span>(); <span class="hljs-comment">//空指针，可以调用成员函数</span><br>    p-&gt;<span class="hljs-built_in">ShowPerson</span>();  <span class="hljs-comment">//但是如果成员函数中用到了this指针，就不可以了</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-4-const修饰成员函数">4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>() &#123;<br>        m_A = <span class="hljs-number">0</span>;<br>        m_B = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//this指针的本质是一个指针常量，指针的指向不可修改</span><br>    <span class="hljs-comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">//const Type* const pointer;</span><br>        <span class="hljs-comment">//this = NULL; //不能修改指针的指向 Person* const this;</span><br>        <span class="hljs-comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span><br><br>        <span class="hljs-comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span><br>        <span class="hljs-keyword">this</span>-&gt;m_B = <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyFunc</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">//mA = 10000;</span><br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B; <span class="hljs-comment">//可修改 可变的</span><br>&#125;;<br><br><br><span class="hljs-comment">//const修饰对象  常对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">const</span> Person person; <span class="hljs-comment">//常量对象  </span><br>    cout &lt;&lt; person.m_A &lt;&lt; endl;<br>    <span class="hljs-comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span><br>    person.m_B = <span class="hljs-number">100</span>; <span class="hljs-comment">//但是常对象可以修改mutable修饰成员变量</span><br><br>    <span class="hljs-comment">//常对象访问成员函数</span><br>    person.<span class="hljs-built_in">MyFunc</span>(); <span class="hljs-comment">//常对象不能调用const的函数</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-友元">4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为  ==friend==</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="4-4-1-全局函数做友元">4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br>    <span class="hljs-comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building * building)</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">Building</span>()<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br>        <span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>    &#125;<br><br><br><span class="hljs-keyword">public</span>:<br>    string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><br><span class="hljs-keyword">private</span>:<br>    string m_BedRoom; <span class="hljs-comment">//卧室</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building * building)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Building b;<br>    <span class="hljs-built_in">goodGay</span>(&amp;b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-2-类做友元">4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">goodGay</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">goodGay</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    Building *building;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br>    <span class="hljs-comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">goodGay</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>();<br><br><span class="hljs-keyword">public</span>:<br>    string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><span class="hljs-keyword">private</span>:<br>    string m_BedRoom;<span class="hljs-comment">//卧室</span><br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>()<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br>    <span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br>goodGay::<span class="hljs-built_in">goodGay</span>()<br>&#123;<br>    building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    goodGay gg;<br>    gg.<span class="hljs-built_in">visit</span>();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-3-成员函数做友元">4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">goodGay</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">goodGay</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit2</span><span class="hljs-params">()</span></span>; <br><br><span class="hljs-keyword">private</span>:<br>    Building *building;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br>    <span class="hljs-comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>();<br><br><span class="hljs-keyword">public</span>:<br>    string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><span class="hljs-keyword">private</span>:<br>    string m_BedRoom;<span class="hljs-comment">//卧室</span><br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>()<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br>    <span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br>goodGay::<span class="hljs-built_in">goodGay</span>()<br>&#123;<br>    building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>    <span class="hljs-comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    goodGay  gg;<br>    gg.<span class="hljs-built_in">visit</span>();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-运算符重载">4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载">4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>() &#123;&#125;;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_A = a;<br>        <span class="hljs-keyword">this</span>-&gt;m_B = b;<br>    &#125;<br>    <span class="hljs-comment">//成员函数实现 + 号运算符重载</span><br>    Person <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>        Person temp;<br>        temp.m_A = <span class="hljs-keyword">this</span>-&gt;m_A + p.m_A;<br>        temp.m_B = <span class="hljs-keyword">this</span>-&gt;m_B + p.m_B;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-type">int</span> m_B;<br>&#125;;<br><br><span class="hljs-comment">//全局函数实现 + 号运算符重载</span><br><span class="hljs-comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span><br><span class="hljs-comment">//    Person temp(0, 0);</span><br><span class="hljs-comment">//    temp.m_A = p1.m_A + p2.m_A;</span><br><span class="hljs-comment">//    temp.m_B = p1.m_B + p2.m_B;</span><br><span class="hljs-comment">//    return temp;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//运算符重载 可以发生函数重载 </span><br>Person <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Person&amp; p2, <span class="hljs-type">int</span> val)  <br>&#123;<br>    Person temp;<br>    temp.m_A = p2.m_A + val;<br>    temp.m_B = p2.m_B + val;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>)</span></span>;<br><br>    <span class="hljs-comment">//成员函数方式</span><br>    Person p3 = p2 + p1;  <span class="hljs-comment">//相当于 p2.operaor+(p1)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="hljs-string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;<br><br><br>    Person p4 = p3 + <span class="hljs-number">10</span>; <span class="hljs-comment">//相当于 operator+(p3,10)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="hljs-string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote><h4 id="4-5-2-左移运算符重载">4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_A = a;<br>        <span class="hljs-keyword">this</span>-&gt;m_B = b;<br>    &#125;<br><br>    <span class="hljs-comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span><br>    <span class="hljs-comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span><br>    <span class="hljs-comment">//&#125;</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-type">int</span> m_B;<br>&#125;;<br><br><span class="hljs-comment">//全局函数实现左移重载</span><br><span class="hljs-comment">//ostream对象只能有一个</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;<br>    out &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; p.m_B;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br><br>    cout &lt;&lt; p1 &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="hljs-comment">//链式编程</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="4-5-3-递增运算符重载">4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInteger</span> &#123;<br><br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyInteger</span>() &#123;<br>        m_Num = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//前置++</span><br>    MyInteger&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        <span class="hljs-comment">//先++</span><br>        m_Num++;<br>        <span class="hljs-comment">//再返回</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//后置++</span><br>    MyInteger <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        <span class="hljs-comment">//先返回</span><br>        MyInteger temp = *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span><br>        m_Num++;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_Num;<br>&#125;;<br><br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;<br>    out &lt;&lt; myint.m_Num;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><br><span class="hljs-comment">//前置++ 先++ 再返回</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    MyInteger myInt;<br>    cout &lt;&lt; ++myInt &lt;&lt; endl;<br>    cout &lt;&lt; myInt &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//后置++ 先返回 再++</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>    MyInteger myInt;<br>    cout &lt;&lt; myInt++ &lt;&lt; endl;<br>    cout &lt;&lt; myInt &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-comment">//test02();</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="4-5-4-赋值运算符重载">4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)<br>    &#123;<br>        <span class="hljs-comment">//将年龄数据开辟到堆区</span><br>        m_Age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(age);<br>    &#125;<br><br>    <span class="hljs-comment">//重载赋值运算符 </span><br>    Person&amp; <span class="hljs-keyword">operator</span>=(Person &amp;p)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (m_Age != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m_Age;<br>            m_Age = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">//编译器提供的代码是浅拷贝</span><br>        <span class="hljs-comment">//m_Age = p.m_Age;</span><br><br>        <span class="hljs-comment">//提供深拷贝 解决浅拷贝的问题</span><br>        m_Age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.m_Age);<br><br>        <span class="hljs-comment">//返回自身</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (m_Age != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m_Age;<br>            m_Age = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//年龄的指针</span><br>    <span class="hljs-type">int</span> *m_Age;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<br><br>    p3 = p2 = p1; <span class="hljs-comment">//赋值操作</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-comment">//int a = 10;</span><br>    <span class="hljs-comment">//int b = 20;</span><br>    <span class="hljs-comment">//int c = 30;</span><br><br>    <span class="hljs-comment">//c = b = a;</span><br>    <span class="hljs-comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span><br>    <span class="hljs-comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br>    <span class="hljs-comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-5-5-关系运算符重载">4.5.5 关系运算符重载</h4><p>**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_Name = name;<br>        <span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>    &#125;;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Person &amp; p)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(Person &amp; p)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    string m_Name;<br>    <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//int a = 0;</span><br>    <span class="hljs-comment">//int b = 0;</span><br><br>    <span class="hljs-function">Person <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (a == b)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a和b相等&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (a != b)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a和b相等&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-5-6-函数调用运算符重载">4.5.6 函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string text)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; text &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//重载的（）操作符 也称为仿函数</span><br>    MyPrint myFunc;<br>    <span class="hljs-built_in">myFunc</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdd</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> v1 + v2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MyAdd add;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><br>    <span class="hljs-comment">//匿名对象调用  </span><br>    cout &lt;&lt; <span class="hljs-string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="hljs-built_in">MyAdd</span>()(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-6-继承">4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="4-6-1-继承的基本语法">4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Java页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//Python页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Python</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//C++页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPP</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//Java页面</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>    Java ja;<br>    ja.<span class="hljs-built_in">header</span>();<br>    ja.<span class="hljs-built_in">footer</span>();<br>    ja.<span class="hljs-built_in">left</span>();<br>    ja.<span class="hljs-built_in">content</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-comment">//Python页面</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>    Python py;<br>    py.<span class="hljs-built_in">header</span>();<br>    py.<span class="hljs-built_in">footer</span>();<br>    py.<span class="hljs-built_in">left</span>();<br>    py.<span class="hljs-built_in">content</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-comment">//C++页面</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>    CPP cp;<br>    cp.<span class="hljs-built_in">header</span>();<br>    cp.<span class="hljs-built_in">footer</span>();<br>    cp.<span class="hljs-built_in">left</span>();<br>    cp.<span class="hljs-built_in">content</span>();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//公共页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePage</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-comment">//Java页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span> : <span class="hljs-keyword">public</span> BasePage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//Python页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Python</span> : <span class="hljs-keyword">public</span> BasePage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//C++页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPP</span> : <span class="hljs-keyword">public</span> BasePage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//Java页面</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>    Java ja;<br>    ja.<span class="hljs-built_in">header</span>();<br>    ja.<span class="hljs-built_in">footer</span>();<br>    ja.<span class="hljs-built_in">left</span>();<br>    ja.<span class="hljs-built_in">content</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-comment">//Python页面</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>    Python py;<br>    py.<span class="hljs-built_in">header</span>();<br>    py.<span class="hljs-built_in">footer</span>();<br>    py.<span class="hljs-built_in">left</span>();<br>    py.<span class="hljs-built_in">content</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-comment">//C++页面</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>    CPP cp;<br>    cp.<span class="hljs-built_in">header</span>();<br>    cp.<span class="hljs-built_in">footer</span>();<br>    cp.<span class="hljs-built_in">left</span>();<br>    cp.<span class="hljs-built_in">content</span>();<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：==可以减少重复的代码==</p><p>class A : public B;</p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="4-6-2-继承方式">4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/assets/clip_image002.png" alt="img"></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_C;<br>&#125;;<br><br><span class="hljs-comment">//公共继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span> :<span class="hljs-keyword">public</span> Base1<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_A; <span class="hljs-comment">//可访问 public权限</span><br>        m_B; <span class="hljs-comment">//可访问 protected权限</span><br>        <span class="hljs-comment">//m_C; //不可访问</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Son1 s1;<br>    s1.m_A; <span class="hljs-comment">//其他类只能访问到公共权限</span><br>&#125;<br><br><span class="hljs-comment">//保护继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_C;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span>:<span class="hljs-keyword">protected</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_A; <span class="hljs-comment">//可访问 protected权限</span><br>        m_B; <span class="hljs-comment">//可访问 protected权限</span><br>        <span class="hljs-comment">//m_C; //不可访问</span><br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myClass2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Son2 s;<br>    <span class="hljs-comment">//s.m_A; //不可访问</span><br>&#125;<br><br><span class="hljs-comment">//私有继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base3</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_C;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son3</span>:<span class="hljs-keyword">private</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_A; <span class="hljs-comment">//可访问 private权限</span><br>        m_B; <span class="hljs-comment">//可访问 private权限</span><br>        <span class="hljs-comment">//m_C; //不可访问</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrandSon3</span> :<span class="hljs-keyword">public</span> Son3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span><br>        <span class="hljs-comment">//m_A;</span><br>        <span class="hljs-comment">//m_B;</span><br>        <span class="hljs-comment">//m_C;</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-6-3-继承中的对象模型">4.6.3 继承中的对象模型</h4><p>**问题：**从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_C; <span class="hljs-comment">//私有成员只是被隐藏了，但是还是会继承下去</span><br>&#125;;<br><br><span class="hljs-comment">//公共继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> :<span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_D;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Son) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用工具查看：</p><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/assets/1545881904150.png" alt="1545881904150"></p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p><p>效果如下图：</p><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/assets/1545882158050.png" alt="1545882158050"></p><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="4-6-4-继承中构造和析构顺序">4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Base</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span><br>    Son s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="4-6-5-继承同名成员处理方式">4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>()<br>    &#123;<br>        m_A = <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son</span>()<br>    &#123;<br>        m_A = <span class="hljs-number">200</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span><br>    <span class="hljs-comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Son s;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;<br><br>    s.<span class="hljs-built_in">func</span>();<br>    s.Base::<span class="hljs-built_in">func</span>();<br>    s.Base::<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="4-6-6-继承同名静态成员处理方式">4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-type">int</span> Base::m_A = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-type">int</span> Son::m_A = <span class="hljs-number">200</span>;<br><br><span class="hljs-comment">//同名成员属性</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//通过对象访问</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;<br>    Son s;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;<br><br>    <span class="hljs-comment">//通过类名访问</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//同名成员函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//通过对象访问</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;<br>    Son s;<br>    s.<span class="hljs-built_in">func</span>();<br>    s.Base::<span class="hljs-built_in">func</span>();<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;<br>    Son::<span class="hljs-built_in">func</span>();<br>    Son::Base::<span class="hljs-built_in">func</span>();<br>    <span class="hljs-comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span><br>    Son::Base::<span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//test01();</span><br>    <span class="hljs-built_in">test02</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="4-6-7-多继承语法">4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base1</span>()<br>    &#123;<br>        m_A = <span class="hljs-number">100</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base2</span>()<br>    &#123;<br>        m_A = <span class="hljs-number">200</span>;  <span class="hljs-comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base1 <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son</span>()<br>    &#123;<br>        m_C = <span class="hljs-number">300</span>;<br>        m_D = <span class="hljs-number">400</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_C;<br>    <span class="hljs-type">int</span> m_D;<br>&#125;;<br><br><br><span class="hljs-comment">//多继承容易产生成员同名的情况</span><br><span class="hljs-comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Son s;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(s) &lt;&lt; endl;<br>    cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;<br>    cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="4-6-8-菱形继承">4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​    两个派生类继承同一个基类</p><p>​    又有某个类同时继承者两个派生类</p><p>​    这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/assets/clip_image002.jpg" alt="IMG_256"></p><p><strong>菱形继承问题：</strong></p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>2. 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。<br><br>**示例：**<br><br>```c++<br>class Animal<br>&#123;<br>public:<br>    int m_Age;<br>&#125;;<br><br>//继承前加virtual关键字后，变为虚继承<br>//此时公共的父类Animal称为虚基类<br>class Sheep : virtual public Animal &#123;&#125;;<br>class Tuo   : virtual public Animal &#123;&#125;;<br>class SheepTuo : public Sheep, public Tuo &#123;&#125;;<br><br>void test01()<br>&#123;<br>    SheepTuo st;<br>    st.Sheep::m_Age = 100;<br>    st.Tuo::m_Age = 200;<br><br>    cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;<br>    cout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;<br>    cout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;<br>&#125;<br><br><br>int main() &#123;<br><br>    test01();<br><br>    system(&quot;pause&quot;);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ol><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><h3 id="4-7-多态">4.7  多态</h3><h4 id="4-7-1-多态的基本概念">4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li></ul><p>下面通过案例进行讲解多态</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//Speak函数就是虚函数</span><br>    <span class="hljs-comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;动物在说话&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> :<span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> :<span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><span class="hljs-comment">//我们希望传入什么对象，那么就调用什么对象的函数</span><br><span class="hljs-comment">//如果函数地址在编译阶段就能确定，那么静态联编</span><br><span class="hljs-comment">//如果函数地址在运行阶段才能确定，就是动态联编</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSpeak</span><span class="hljs-params">(Animal &amp; animal)</span></span><br><span class="hljs-function"></span>&#123;<br>    animal.<span class="hljs-built_in">speak</span>();<br>&#125;<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//多态满足条件： </span><br><span class="hljs-comment">//1、有继承关系</span><br><span class="hljs-comment">//2、子类重写父类中的虚函数</span><br><span class="hljs-comment">//多态使用：</span><br><span class="hljs-comment">//父类指针或引用指向子类对象</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Cat cat;<br>    <span class="hljs-built_in">DoSpeak</span>(cat);<br><br><br>    Dog dog;<br>    <span class="hljs-built_in">DoSpeak</span>(dog);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p><h4 id="4-7-2-多态案例一-计算器类">4.7.2 多态案例一-计算器类</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//普通实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">(string oper)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;+&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> m_Num1 + m_Num2;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;-&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> m_Num1 - m_Num2;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;*&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> m_Num1 * m_Num2;<br>        &#125;<br>        <span class="hljs-comment">//如果要提供新的运算，需要修改源码</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_Num1;<br>    <span class="hljs-type">int</span> m_Num2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//普通实现测试</span><br>    Calculator c;<br>    c.m_Num1 = <span class="hljs-number">10</span>;<br>    c.m_Num2 = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;+&quot;</span>) &lt;&lt; endl;<br><br>    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;-&quot;</span>) &lt;&lt; endl;<br><br>    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;*&quot;</span>) &lt;&lt; endl;<br>&#125;<br><br><br><br><span class="hljs-comment">//多态实现</span><br><span class="hljs-comment">//抽象计算器类</span><br><span class="hljs-comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCalculator</span><br>&#123;<br><span class="hljs-keyword">public</span> :<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m_Num1;<br>    <span class="hljs-type">int</span> m_Num2;<br>&#125;;<br><br><span class="hljs-comment">//加法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_Num1 + m_Num2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//减法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_Num1 - m_Num2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//乘法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_Num1 * m_Num2;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建加法计算器</span><br>    AbstractCalculator *abc = <span class="hljs-keyword">new</span> AddCalculator;<br>    abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>    abc-&gt;m_Num2 = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> abc;  <span class="hljs-comment">//用完了记得销毁</span><br><br>    <span class="hljs-comment">//创建减法计算器</span><br>    abc = <span class="hljs-keyword">new</span> SubCalculator;<br>    abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>    abc-&gt;m_Num2 = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> abc;  <br><br>    <span class="hljs-comment">//创建乘法计算器</span><br>    abc = <span class="hljs-keyword">new</span> MulCalculator;<br>    abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>    abc-&gt;m_Num2 = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> abc;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//test01();</span><br><br>    <span class="hljs-built_in">test02</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="4-7-3-纯虚函数和抽象类">4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为==抽象类==</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//纯虚函数</span><br>    <span class="hljs-comment">//类中只要有一个纯虚函数就称为抽象类</span><br>    <span class="hljs-comment">//抽象类无法实例化对象</span><br>    <span class="hljs-comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> :<span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;func调用&quot;</span> &lt;&lt; endl;<br>    &#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base * base = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//base = new Base; // 错误，抽象类无法实例化对象</span><br>    base = <span class="hljs-keyword">new</span> Son;<br>    base-&gt;<span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">delete</span> base;<span class="hljs-comment">//记得销毁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-7-4-多态案例二-制作饮品">4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/assets/1545985945198.png" alt="1545985945198"></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//抽象制作饮品</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDrinking</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//烧水</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//冲泡</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//倒入杯中</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//加入辅料</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//规定流程</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MakeDrink</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">Boil</span>();<br>        <span class="hljs-built_in">Brew</span>();<br>        <span class="hljs-built_in">PourInCup</span>();<br>        <span class="hljs-built_in">PutSomething</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//制作咖啡</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> : <span class="hljs-keyword">public</span> AbstractDrinking &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//烧水</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//冲泡</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//倒入杯中</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//加入辅料</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//制作茶水</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span> : <span class="hljs-keyword">public</span> AbstractDrinking &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//烧水</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//冲泡</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//倒入杯中</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//加入辅料</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//业务函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoWork</span><span class="hljs-params">(AbstractDrinking* drink)</span> </span>&#123;<br>    drink-&gt;<span class="hljs-built_in">MakeDrink</span>();<br>    <span class="hljs-keyword">delete</span> drink;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">DoWork</span>(<span class="hljs-keyword">new</span> Coffee);<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">DoWork</span>(<span class="hljs-keyword">new</span> Tea);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-7-5-虚析构和纯虚析构">4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><code>类名::~类名()&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">Animal</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//析构函数加上virtual关键字，变成虚析构函数</span><br>    <span class="hljs-comment">//virtual ~Animal()</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span><br>    <span class="hljs-comment">//&#125;</span><br><br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() = <span class="hljs-number">0</span>;<br>&#125;;<br><br>Animal::~<span class="hljs-built_in">Animal</span>()<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cat</span>(string name)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;<br>        m_Name = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(name);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; *m_Name &lt;&lt;  <span class="hljs-string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Cat</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">delete</span> m_Name;<br>            m_Name = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    string *m_Name;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Animal *animal = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>    animal-&gt;<span class="hljs-built_in">Speak</span>();<br><br>    <span class="hljs-comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span><br>    <span class="hljs-comment">//怎么解决？给基类增加一个虚析构函数</span><br>    <span class="hljs-comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span><br>    <span class="hljs-keyword">delete</span> animal;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>​    1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​    2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​    3. 拥有纯虚析构函数的类也属于抽象类</p><h4 id="4-7-6-多态案例三-电脑组装">4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象CPU类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPU</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//抽象的计算函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//抽象显卡类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VideoCard</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//抽象的显示函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//抽象内存条类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memory</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//抽象的存储函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//电脑类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)<br>    &#123;<br>        m_cpu = cpu;<br>        m_vc = vc;<br>        m_mem = mem;<br>    &#125;<br><br>    <span class="hljs-comment">//提供工作的函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//让零件工作起来，调用接口</span><br>        m_cpu-&gt;<span class="hljs-built_in">calculate</span>();<br><br>        m_vc-&gt;<span class="hljs-built_in">display</span>();<br><br>        m_mem-&gt;<span class="hljs-built_in">storage</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//提供析构函数 释放3个电脑零件</span><br>    ~<span class="hljs-built_in">Computer</span>()<br>    &#123;<br><br>        <span class="hljs-comment">//释放CPU零件</span><br>        <span class="hljs-keyword">if</span> (m_cpu != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m_cpu;<br>            m_cpu = <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//释放显卡零件</span><br>        <span class="hljs-keyword">if</span> (m_vc != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m_vc;<br>            m_vc = <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//释放内存条零件</span><br>        <span class="hljs-keyword">if</span> (m_mem != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m_mem;<br>            m_mem = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    CPU * m_cpu; <span class="hljs-comment">//CPU的零件指针</span><br>    VideoCard * m_vc; <span class="hljs-comment">//显卡零件指针</span><br>    Memory * m_mem; <span class="hljs-comment">//内存条零件指针</span><br>&#125;;<br><br><span class="hljs-comment">//具体厂商</span><br><span class="hljs-comment">//Intel厂商</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelCPU</span> :<span class="hljs-keyword">public</span> CPU<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelVideoCard</span> :<span class="hljs-keyword">public</span> VideoCard<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelMemory</span> :<span class="hljs-keyword">public</span> Memory<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//Lenovo厂商</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoCPU</span> :<span class="hljs-keyword">public</span> CPU<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoVideoCard</span> :<span class="hljs-keyword">public</span> VideoCard<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoMemory</span> :<span class="hljs-keyword">public</span> Memory<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//第一台电脑零件</span><br>    CPU * intelCpu = <span class="hljs-keyword">new</span> IntelCPU;<br>    VideoCard * intelCard = <span class="hljs-keyword">new</span> IntelVideoCard;<br>    Memory * intelMem = <span class="hljs-keyword">new</span> IntelMemory;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">//创建第一台电脑</span><br>    Computer * computer1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(intelCpu, intelCard, intelMem);<br>    computer1-&gt;<span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">delete</span> computer1;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">//第二台电脑组装</span><br>    Computer * computer2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(<span class="hljs-keyword">new</span> LenovoCPU, <span class="hljs-keyword">new</span> LenovoVideoCard, <span class="hljs-keyword">new</span> LenovoMemory);;<br>    computer2-&gt;<span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">delete</span> computer2;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">//第三台电脑组装</span><br>    Computer * computer3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(<span class="hljs-keyword">new</span> LenovoCPU, <span class="hljs-keyword">new</span> IntelVideoCard, <span class="hljs-keyword">new</span> LenovoMemory);;<br>    computer3-&gt;<span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">delete</span> computer3;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-文件操作">5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="5-1文本文件">5.1文本文件</h3><h4 id="5-1-1写文件">5.1.1写文件</h4><p>写文件步骤如下：</p><ol><li><p>包含头文件</p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象</p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p>**例如：**用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ofstream ofs;<br>    ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::out);<br><br>    ofs &lt;&lt; <span class="hljs-string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;<br>    ofs &lt;&lt; <span class="hljs-string">&quot;性别：男&quot;</span> &lt;&lt; endl;<br>    ofs &lt;&lt; <span class="hljs-string">&quot;年龄：18&quot;</span> &lt;&lt; endl;<br><br>    ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h4 id="5-1-2读文件">5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件</p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象</p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ifstream ifs;<br>    ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::in);<br><br>    <span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//第一种方式</span><br>    <span class="hljs-comment">//char buf[1024] = &#123; 0 &#125;;</span><br>    <span class="hljs-comment">//while (ifs &gt;&gt; buf)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    cout &lt;&lt; buf &lt;&lt; endl;</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//第二种</span><br>    <span class="hljs-comment">//char buf[1024] = &#123; 0 &#125;;</span><br>    <span class="hljs-comment">//while (ifs.getline(buf,sizeof(buf)))</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    cout &lt;&lt; buf &lt;&lt; endl;</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//第三种</span><br>    <span class="hljs-comment">//string buf;</span><br>    <span class="hljs-comment">//while (getline(ifs, buf))</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    cout &lt;&lt; buf &lt;&lt; endl;</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">while</span> ((c = ifs.<span class="hljs-built_in">get</span>()) != EOF)<br>    &#123;<br>        cout &lt;&lt; c;<br>    &#125;<br><br>    ifs.<span class="hljs-built_in">close</span>();<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>读文件可以利用 ifstream  ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件</li></ul><h3 id="5-2-二进制文件">5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 ==ios::binary==</p><h4 id="5-2-1-写文件">5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span> m_Name[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-comment">//二进制文件  写文件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1、包含头文件</span><br><br>    <span class="hljs-comment">//2、创建输出流对象</span><br>    <span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;<br>    <br>    <span class="hljs-comment">//3、打开文件</span><br>    <span class="hljs-comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span><br><br>    Person p = &#123;<span class="hljs-string">&quot;张三&quot;</span>  , <span class="hljs-number">18</span>&#125;;<br><br>    <span class="hljs-comment">//4、写文件</span><br>    ofs.<span class="hljs-built_in">write</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(p));<br><br>    <span class="hljs-comment">//5、关闭文件</span><br>    ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件">5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span> m_Name[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    Person p;<br>    ifs.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(p));<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>便携小空调 - 为你的夏日带去清凉!</title>
      <link href="/air-conditioner/index.html"/>
      <url>/air-conditioner/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>吹赛博空调，过电子人生</p></blockquote><style>.copyright-box a {  border-bottom: none !important;  padding: 0 !important;}</style><div id="air-conditioner-vue"></div><script defer data-pjax src='https://npm.elemecdn.com/anzhiyu-air-conditioner@1.0.1/index.3f125bc6.js'></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>charts</title>
      <link href="/charts/index.html"/>
      <url>/charts/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>即刻短文</title>
      <link href="/essay/index.html"/>
      <url>/essay/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;}div#menus {    font-family: "ZhuZiAYuanJWD";}h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title {    font-family: ZhuZiAYuanJWD;}.iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;}/* 时间轴生肖icon */svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;}.icon-zhongbiao::before {    color: #f7c768;}/* bilibli番剧插件 */#article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;}a.bangumi-tab:hover {    text-decoration: none !important;}.bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;}a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;}.bangumi-button {    padding: 5px 10px !important;}a.bangumi-tab {    padding: 5px 10px !important;}svg.icon.faa-tada {    font-size: 1.1em;}.bangumi-info-item {    border-right: 1px solid #f2b94b;}.bangumi-info-item span {    color: #f2b94b;}.bangumi-info-item em {    color: #f2b94b;}/* 解决artitalk的图标问题 */#uploadSource>svg {    width: 1.19em;    height: 1.5em;}/*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */#page-header:not(.not-top-img):before {    background-color: transparent !important;}/* 首页文章卡片 */#recent-posts>.recent-post-item {    background: rgba(255, 255, 255, 0.9);}/* 首页侧栏卡片 */#aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);}/* 文章页面正文背景 */div#post {    background: rgba(255, 255, 255, 0.9);}/* 分页页面 */div#page {    background: rgba(255, 255, 255, 0.9);}/* 归档页面 */div#archive {    background: rgba(255, 255, 255, 0.9);}/* 标签页面 */div#tag {    background: rgba(255, 255, 255, 0.9);}/* 分类页面 */div#category {    background: rgba(255, 255, 255, 0.9);}/*夜间模式伪类遮罩层透明*/[data-theme="dark"] #recent-posts>.recent-post-item {    background: #121212;}[data-theme="dark"] .card-widget {    background: #121212 !important;}[data-theme="dark"] div#post {    background: #121212 !important;}[data-theme="dark"] div#tag {    background: #121212 !important;}[data-theme="dark"] div#archive {    background: #121212 !important;}[data-theme="dark"] div#page {    background: #121212 !important;}[data-theme="dark"] div#category {    background: #121212 !important;}[data-theme="dark"] div#category {    background: transparent !important;}/* 页脚透明 */#footer {    background: transparent !important;}/* 头图透明 */#page-header {    background: transparent !important;}#rightside>div>button {    border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {    width: 10px;    height: 10px;}::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #3b70fc;}/* 音乐播放器 *//* .aplayer .aplayer-lrc {  display: none !important;} */.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */}.aplayer.aplayer-fixed {    z-index: 999999 !important;}/* 评论框  */.vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;}/* 设置评论框 */.vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;}/* md网站下划线 */#article-container a:hover {    text-decoration: none !important;}#article-container #hpp_talk p img {    display: inline;}/* 404页面 */#error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);}#error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;}#error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;}#error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;}#error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;}#error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);}#body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;}#body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;}#body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;}#body-wrap.error .aside-list .aside-list-item .content time {    display: none;}/* 代码框主题 */#article-container figure.highlight {    border-radius: 10px;    background-color: transparent;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/self/one-light-theme.css"/>
      <url>/self/one-light-theme.css</url>
      
        <content type="html"><![CDATA[/** 抖音字效 **/@-webkit-keyframes uk-text-shadow-glitch {  0% {    text-shadow: none;  }  25% {    text-shadow: -1px -1px 0 #ff0048, 1px 1px 0 #3234ff;  }  50% {    text-shadow: 1px -1px 0 #ff0048, -1px 1px 0 #3234ff;  }  75% {    text-shadow: -1px 1px 0 #ff0048, 1px -1px 0 #3234ff;  }  to {    text-shadow: 1px 1px 0 #ff0048, -1px -1px 0 #3234ff;  }}@keyframes uk-text-shadow-glitch {  0% {    text-shadow: none;  }  25% {    text-shadow: -1px -1px 0 #ff0048, 1px 1px 0 #3234ff;  }  50% {    text-shadow: 1px -1px 0 #ff0048, -1px 1px 0 #3234ff;  }  75% {    text-shadow: -1px 1px 0 #ff0048, 1px -1px 0 #3234ff;  }  to {    text-shadow: 1px 1px 0 #ff0048, -1px -1px 0 #3234ff;  }}/* 一级标题 */h1 {  font-size: 50px;  text-align: center;  -webkit-animation: uk-text-shadow-glitch 0.95s cubic-bezier(1, -1.91, 0, 2.79)    0s infinite normal both running;  animation: uk-text-shadow-glitch 0.95s cubic-bezier(1, -1.91, 0, 2.79) 0s    infinite normal both running;}/* 引用框 */blockquote {  border-top-right-radius: 10px;  border-bottom-right-radius: 10px;  margin-bottom: 16px;  padding: 10px 10px 10px 20px;  font-size: 0.9em;  background: #ffffff;  border-left: 5px solid #166ff3;  color: #6a737d;  overflow: auto;  box-shadow: 4px 5px 10px 2px rgb(173 173 173);  -webkit-overflow-scrolling: touch;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/self/onedark.css"/>
      <url>/self/onedark.css</url>
      
        <content type="html"><![CDATA[/*!  Theme: OneDark  Author: Lalit Magant (http://github.com/tilal6991)  License: ~ MIT (or more permissive) [via base16-schemes-source]  Maintainer: @highlightjs/core-team  Version: 2021.09.0*//*  WARNING: DO NOT EDIT THIS FILE DIRECTLY.  This theme file was auto-generated from the Base16 scheme onedark  by the Highlight.js Base16 template builder.  - https://github.com/highlightjs/base16-highlightjs*//* 新添加的内容  -------------------------------------   --hl-color                  代码框字体顔色 【必须】 (把下面.hljs的 color复制到这里来)  --hl-bg                     代码框背景色 【必须】 (把下面.hljs的 background复制到这里来)  --hltools-bg: #321a0f       代码框顶部工具栏背景色 【可选】(如果你关掉了 copy、lang 和 shrink,可不用配置这个）  --hltools-color: #fff       代码框顶部工具栏字体顔色 【可选】(如果你关掉了 copy、lang 和 shrink,可不用配置这个）  --hlnumber-bg: #221a0f      代码框行数背景色 【可选】(如果已经关掉 line_number,可以不用配置这个)  --hlnumber-color: #fff      代码框行数字体顔色 【可选】 (如果已经关掉 line_number,可以不用配置这个)  --hlscrollbar-bg: #d3af86   代码框滚动条顔色 【可选】（默认为主题主顔色）  --hlexpand-bg: #d3af86      代码框底部展开背景色 【可选】(如果已经关掉 highlight_height_limit,可以不用配置这个)*/:root {  --hl-color: #abb2bf;  --hl-bg: #282c34;  --hltools-bg: #282c34;  --hltools-color: #fff;  --hlnumber-bg: #282c34;  --hlnumber-color: #353b45;  --hlexpand-bg: #282c34;}/*base00  #282c34  Default Backgroundbase01  #353b45  Lighter Background (Used for status bars, line number and folding marks)base02  #3e4451  Selection Backgroundbase03  #545862  Comments, Invisibles, Line Highlightingbase04  #565c64  Dark Foreground (Used for status bars)base05  #abb2bf  Default Foreground, Caret, Delimiters, Operatorsbase06  #b6bdca  Light Foreground (Not often used)base07  #c8ccd4  Light Background (Not often used)base08  #e06c75  Variables, XML Tags, Markup Link Text, Markup Lists, Diff Deletedbase09  #d19a66  Integers, Boolean, Constants, XML Attributes, Markup Link Urlbase0A  #e5c07b  Classes, Markup Bold, Search Text Backgroundbase0B  #98c379  Strings, Inherited Class, Markup Code, Diff Insertedbase0C  #56b6c2  Support, Regular Expressions, Escape Characters, Markup Quotesbase0D  #61afef  Functions, Methods, Attribute IDs, Headingsbase0E  #c678dd  Keywords, Storage, Selector, Markup Italic, Diff Changedbase0F  #be5046  Deprecated, Opening/Closing Embedded Language Tags, e.g. <?php ?>*/pre code.hljs {  display: block;  overflow-x: auto;  padding: 1em;}code.hljs {  padding: 3px 5px;}.hljs {  color: #abb2bf;  /* background: #171717; */  background: #00282c34;}.hljs::selection,.hljs ::selection {  background-color: #3e4451;  color: #abb2bf;}/* purposely do not highlight these things */.hljs-formula,.hljs-params,.hljs-property {}/* base03 - #545862 -  Comments, Invisibles, Line Highlighting */.hljs-comment {  color: #545862;}/* base04 - #565c64 -  Dark Foreground (Used for status bars) */.hljs-tag {  color: #565c64;}/* base05 - #abb2bf -  Default Foreground, Caret, Delimiters, Operators */.hljs-subst,.hljs-punctuation,.hljs-operator {  color: #abb2bf;}.hljs-operator {  opacity: 0.7;}/* base08 - Variables, XML Tags, Markup Link Text, Markup Lists, Diff Deleted */.hljs-bullet,.hljs-variable,.hljs-template-variable,.hljs-selector-tag,.hljs-name,.hljs-deletion {  color: #e06c75;}/* base09 - Integers, Boolean, Constants, XML Attributes, Markup Link Url */.hljs-symbol,.hljs-number,.hljs-link,.hljs-attr,.hljs-variable.constant_,.hljs-literal {  color: #d19a66;}/* base0A - Classes, Markup Bold, Search Text Background */.hljs-title,.hljs-class .hljs-title,.hljs-title.class_ {  color: #e5c07b;}.hljs-strong {  font-weight: bold;  color: #e5c07b;}/* base0B - Strings, Inherited Class, Markup Code, Diff Inserted */.hljs-code,.hljs-addition,.hljs-title.class_.inherited__,.hljs-string {  color: #98c379;}/* base0C - Support, Regular Expressions, Escape Characters, Markup Quotes */.hljs-built_in,.hljs-doctag, /* guessing */.hljs-quote,.hljs-keyword.hljs-atrule,.hljs-regexp {  color: #56b6c2;}/* base0D - Functions, Methods, Attribute IDs, Headings */.hljs-function .hljs-title,.hljs-attribute,.ruby .hljs-property,.hljs-title.function_,.hljs-section {  color: #61afef;}/* base0E - Keywords, Storage, Selector, Markup Italic, Diff Changed */.hljs-type,/* .hljs-selector-id, *//* .hljs-selector-class, *//* .hljs-selector-attr, *//* .hljs-selector-pseudo, */.hljs-template-tag,.diff .hljs-meta,.hljs-keyword {  color: #c678dd;}.hljs-emphasis {  color: #c678dd;  font-style: italic;}/* base0F - Deprecated, Opening/Closing Embedded Language Tags, e.g. <?php ?> */.hljs-meta,/*  prevent top level .keyword and .string scopes  from leaking into meta by accident*/.hljs-meta .hljs-keyword,.hljs-meta .hljs-string {  color: #be5046;}.hljs-meta .hljs-keyword,/* for v10 compatible themes */.hljs-meta-keyword {  font-weight: bold;}]]></content>
      
    </entry>
    
    
  
</search>
